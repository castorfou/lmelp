# Design Document

## Overview

Cette fonctionnalit√© ajoute une capacit√© de recherche par livre √† l'application Streamlit "Le Masque et la Plume". Le design s'appuie sur l'architecture MongoDB existante et introduit de nouveaux composants pour l'extraction, l'indexation et la recherche des livres mentionn√©s dans les avis critiques.

L'approche consiste √† :
1. Extraire automatiquement les livres des avis critiques existants et futurs
2. Cr√©er une nouvelle collection MongoDB pour indexer les relations livre-√©pisode
3. Modifier l'interface utilisateur pour offrir deux modes de navigation
4. Impl√©menter un syst√®me de recherche et filtrage similaire √† la page auteurs

## Architecture

### Architecture Actuelle
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   episodes      ‚îÇ    ‚îÇ avis_critiques  ‚îÇ    ‚îÇ     livres      ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ - _id           ‚îÇ    ‚îÇ - episode_oid   ‚îÇ    ‚îÇ - nom           ‚îÇ
‚îÇ - titre         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚î§ - summary       ‚îÇ    ‚îÇ - auteur        ‚îÇ
‚îÇ - date          ‚îÇ    ‚îÇ - created_at    ‚îÇ    ‚îÇ - editeur       ‚îÇ
‚îÇ - transcription ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           
                                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                              ‚îÇ    auteurs      ‚îÇ
                                              ‚îÇ                 ‚îÇ
                                              ‚îÇ - nom           ‚îÇ
                                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Architecture Propos√©e
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   episodes      ‚îÇ    ‚îÇ avis_critiques  ‚îÇ    ‚îÇ     livres      ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ - _id           ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚î§ - episode_oid   ‚îÇ    ‚îÇ - nom           ‚îÇ
‚îÇ - titre         ‚îÇ    ‚îÇ - summary       ‚îÇ    ‚îÇ - auteur        ‚îÇ
‚îÇ - date          ‚îÇ    ‚îÇ - created_at    ‚îÇ    ‚îÇ - editeur       ‚îÇ
‚îÇ - transcription ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ                       ‚ñ≤
        ‚ñ≤                       ‚îÇ                       ‚îÇ
        ‚îÇ                       ‚ñº                       ‚îÇ
        ‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
        ‚îÇ            ‚îÇ episode_livres  ‚îÇ                ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ - episode_oid   ‚îÇ
                     ‚îÇ - livre_titre   ‚îÇ
                     ‚îÇ - livre_auteur  ‚îÇ
                     ‚îÇ - note          ‚îÇ
                     ‚îÇ - section       ‚îÇ
                     ‚îÇ - created_at    ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Components and Interfaces

### 1. Parser d'Avis Critiques (`AvisCritiquesParser`)

**Responsabilit√© :** Extraire les livres et m√©tadonn√©es des avis critiques au format markdown.

```python
class AvisCritiquesParser:
    def extract_books_from_summary(self, summary_text: str) -> List[BookMention]:
        """Extrait les livres d'un r√©sum√© d'avis critique"""
        
    def parse_markdown_table(self, table_section: str) -> List[Dict]:
        """Parse une section de tableau markdown"""
        
    def extract_rating(self, rating_html: str) -> Optional[float]:
        """Extrait la note num√©rique du HTML color√©"""
```

**Interface BookMention :**
```python
@dataclass
class BookMention:
    titre: str
    auteur: str
    note: Optional[float]
    section: str  # "programme" ou "coups_de_coeur"
    commentaire: Optional[str]
```

### 2. Gestionnaire Episode-Livre (`EpisodeLivre`)

**Responsabilit√© :** G√©rer la collection `episode_livres` qui fait le lien entre √©pisodes et livres.

```python
class EpisodeLivre(BaseEntity):
    collection: str = "episode_livres"
    
    def __init__(self, episode_oid: ObjectId, livre_titre: str, livre_auteur: str):
        self.episode_oid = episode_oid
        self.livre_titre = livre_titre
        self.livre_auteur = livre_auteur
        self.note = None
        self.section = None
        
    @classmethod
    def find_by_book(cls, livre_titre: str = None, livre_auteur: str = None) -> List['EpisodeLivre']:
        """Trouve tous les √©pisodes mentionnant un livre ou auteur"""
        
    @classmethod
    def get_all_books(cls) -> List[Dict[str, str]]:
        """Retourne tous les livres uniques avec leurs auteurs"""
```

### 3. Moteur de Recherche (`AvisSearchEngine`)

**Responsabilit√© :** Fournir les fonctionnalit√©s de recherche et filtrage pour l'interface utilisateur.

```python
class AvisSearchEngine:
    def __init__(self):
        self.episode_livre = EpisodeLivre
        
    def search_books(self, query: str) -> List[Dict]:
        """Recherche floue dans les titres et auteurs"""
        
    def get_book_episodes(self, livre_titre: str, livre_auteur: str) -> List[Dict]:
        """R√©cup√®re tous les √©pisodes mentionnant un livre"""
        
    def get_all_books_formatted(self) -> List[str]:
        """Retourne tous les livres format√©s pour l'affichage"""
```

### 4. Interface Utilisateur Modifi√©e

**Structure de la page `4_avis_critiques.py` :**

```python
def main():
    st.title("üìù Avis Critiques")
    
    # Options de navigation (radio buttons)
    mode = st.radio(
        "Mode de navigation :",
        ["Par √âpisode", "Par Livre"],
        horizontal=True
    )
    
    if mode == "Par √âpisode":
        afficher_selection_episode()  # Code existant inchang√©
    else:
        afficher_recherche_livre()   # Nouvelle fonctionnalit√©

def afficher_recherche_livre():
    """Nouvelle interface de recherche par livre"""
    search_engine = AvisSearchEngine()
    
    # Champ de filtre (similaire √† la page auteurs)
    filtre = st.text_input("Filtrer les livres:", "")
    
    # Liste filtr√©e des livres
    livres_filtres = search_engine.filter_books(filtre)
    
    # S√©lection et affichage
    if livre_selectionne := st.selectbox("S√©lectionnez un livre:", livres_filtres):
        episodes = search_engine.get_book_episodes(livre_selectionne)
        afficher_avis_pour_livre(episodes)
```

## Data Models

### Collection `episode_livres`

```javascript
{
  "_id": ObjectId,
  "episode_oid": ObjectId,        // R√©f√©rence vers episodes._id
  "livre_titre": String,          // Titre du livre
  "livre_auteur": String,         // Auteur du livre
  "note": Number,                 // Note attribu√©e (optionnel)
  "section": String,              // "programme" ou "coups_de_coeur"
  "commentaire": String,          // Commentaire de la critique (optionnel)
  "created_at": Date,             // Date de cr√©ation
  "updated_at": Date              // Date de mise √† jour
}
```

### Index MongoDB Recommand√©s

```javascript
// Index compos√© pour la recherche par livre
db.episode_livres.createIndex({ "livre_titre": 1, "livre_auteur": 1 })

// Index pour la recherche par auteur seul
db.episode_livres.createIndex({ "livre_auteur": 1 })

// Index pour la recherche textuelle
db.episode_livres.createIndex({ 
  "livre_titre": "text", 
  "livre_auteur": "text" 
})

// Index pour les requ√™tes par √©pisode
db.episode_livres.createIndex({ "episode_oid": 1 })
```

## Error Handling

### 1. Parsing des Avis Critiques

**Erreurs Possibles :**
- Format markdown invalide ou inattendu
- Tableaux malform√©s
- Notes non parsables

**Strat√©gie :**
```python
try:
    books = parser.extract_books_from_summary(summary)
except ParsingError as e:
    logger.warning(f"Erreur parsing √©pisode {episode_id}: {e}")
    # Continuer le traitement, logger l'erreur
    books = []
```

### 2. Recherche et Affichage

**Erreurs Possibles :**
- Aucun r√©sultat trouv√©
- Erreurs de connexion MongoDB
- Donn√©es corrompues

**Strat√©gie :**
```python
def afficher_recherche_livre():
    try:
        search_engine = AvisSearchEngine()
        # ... logique de recherche
    except DatabaseError:
        st.error("Erreur de connexion √† la base de donn√©es")
    except Exception as e:
        st.error(f"Erreur inattendue: {e}")
        logger.exception("Erreur dans recherche livre")
```

### 3. Migration des Donn√©es

**Erreurs Possibles :**
- Avis critiques corrompus
- √âchec d'insertion en base
- Interruption du processus

**Strat√©gie :**
```python
def migrate_existing_avis():
    failed_episodes = []
    for avis in all_avis:
        try:
            process_avis(avis)
        except Exception as e:
            failed_episodes.append((avis['episode_oid'], str(e)))
            continue
    
    # Rapport final
    print(f"Migration termin√©e. {len(failed_episodes)} √©checs.")
```

## Testing Strategy

### 1. Tests Unitaires

**Parser (`test_avis_critiques_parser.py`) :**
```python
def test_extract_books_from_valid_summary():
    """Test extraction avec un r√©sum√© valide"""
    
def test_extract_books_with_malformed_table():
    """Test robustesse avec tableau malform√©"""
    
def test_extract_rating_from_html():
    """Test extraction des notes color√©es"""
```

**EpisodeLivre (`test_episode_livre.py`) :**
```python
def test_create_episode_livre():
    """Test cr√©ation d'une relation √©pisode-livre"""
    
def test_find_by_book():
    """Test recherche par livre"""
    
def test_get_all_books():
    """Test r√©cup√©ration de tous les livres"""
```

**Moteur de Recherche (`test_avis_search.py`) :**
```python
def test_search_books_fuzzy():
    """Test recherche floue"""
    
def test_filter_books():
    """Test filtrage des livres"""
    
def test_get_book_episodes():
    """Test r√©cup√©ration des √©pisodes d'un livre"""
```

### 2. Tests d'Int√©gration

**Migration (`test_migration.py`) :**
```python
def test_full_migration_process():
    """Test du processus complet de migration"""
    
def test_migration_with_corrupted_data():
    """Test migration avec donn√©es corrompues"""
```

**Interface Utilisateur (`test_ui_integration.py`) :**
```python
def test_episode_mode_unchanged():
    """V√©rifier que le mode √©pisode fonctionne comme avant"""
    
def test_book_search_mode():
    """Test du nouveau mode de recherche par livre"""
```

### 3. Tests de Performance

**Recherche (`test_performance.py`) :**
```python
def test_search_performance_1000_books():
    """Test performance avec 1000+ livres"""
    
def test_filter_response_time():
    """Test temps de r√©ponse du filtrage"""
```

### 4. Tests de R√©gression

**Compatibilit√© (`test_regression.py`) :**
```python
def test_existing_functionality_unchanged():
    """V√©rifier que les fonctionnalit√©s existantes ne sont pas impact√©es"""
    
def test_avis_generation_still_works():
    """V√©rifier que la g√©n√©ration d'avis fonctionne toujours"""
```

## Migration Strategy

### Phase 1 : Infrastructure
1. Cr√©er les nouveaux modules (`AvisCritiquesParser`, `EpisodeLivre`, `AvisSearchEngine`)
2. Cr√©er la collection `episode_livres` avec les index appropri√©s
3. Tests unitaires complets

### Phase 2 : Migration des Donn√©es
1. Script de migration pour traiter tous les avis existants
2. Validation des donn√©es migr√©es
3. Tests d'int√©gration

### Phase 3 : Interface Utilisateur
1. Modification de la page `4_avis_critiques.py`
2. Ajout du mode de recherche par livre
3. Tests de r√©gression pour s'assurer que le mode √©pisode fonctionne toujours

### Phase 4 : Int√©gration Continue
1. Modification du processus de g√©n√©ration d'avis pour extraire automatiquement les livres
2. Tests end-to-end
3. Documentation utilisateur