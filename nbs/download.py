# AUTOGENERATED! DO NOT EDIT! File to edit: 08 download mp3 from db info.ipynb.

# %% auto 0
__all__ = ["AUDIO_PATH", "get_audio_path", "download_all_mp3_livres"]

# %% 08 download mp3 from db info.ipynb 2
AUDIO_PATH = "audios"


# %% 08 download mp3 from db info.ipynb 6
import os
from git import Repo


def get_audio_path(audio_path=AUDIO_PATH):
    """
    return full audio path and create dir if it doesn t exist
    """

    def get_git_root(path):
        git_repo = Repo(path, search_parent_directories=True)
        return git_repo.git.rev_parse("--show-toplevel")

    project_root = get_git_root(os.getcwd())
    full_audio_path = os.path.join(project_root, audio_path)

    # create dir if it doesn t exist
    if not os.path.exists(full_audio_path):
        os.makedirs(full_audio_path)

    return full_audio_path


# %% 08 download mp3 from db info.ipynb 10
import requests


def download_all_mp3_livres(collection, audio_path=AUDIO_PATH, verbose=False):
    """
    on boucle dans tous les documents de la collection et telecharge les fichiers mp3
    si :
    - le champ type vaut livres
    - le champ url existe
    - le champ duree existe et est superieur a 15 minutes (ajouter un parametrage apres)
    - le mp3 n existe pas deja dans audio_path

    si on veut forcer le telechargement, il faut manuellement supprimer le fichier mp3 dans audio_path

    collection: pymongo collection
    audio_path: str, path to save audio files, default is 'AUDIO_PATH', abreviated, and is created if it doesn t exist
    """

    full_audio_path = get_audio_path(audio_path)
    if verbose:
        print(f"audio path: {full_audio_path}")
    # Récupération de toutes les entrées dans la collection
    entries = collection.find()

    for entry in entries:

        # Vérification si le type est bien "livres"
        if entry.get("type") != "livres":
            continue

        # verfiication si la duree est > 15 minutes
        duree = entry.get("duree")
        if duree is None or duree < 15:
            continue

        url = entry.get("url")
        if url is None:
            continue
        if verbose:
            print(f'{entry["type"]} - {entry.get("description")} - {url}')

        filename = os.path.join(full_audio_path, os.path.basename(url))

        # Vérification si le fichier existe déjà
        if not os.path.exists(filename):
            if verbose:
                print(f"Téléchargement de {url} vers {filename}")
            response = requests.get(url)
            with open(filename, "wb") as file:
                file.write(response.content)
        else:
            if verbose:
                print(f"Le fichier {filename} existe déjà. Ignoré.")
