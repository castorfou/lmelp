# AUTOGENERATED! DO NOT EDIT! File to edit: 08 download mp3 from db info.ipynb.

# %% auto 0
__all__ = [
    "AUDIO_PATH",
    "get_audio_path",
    "download_mp3_livres",
    "download_all_mp3_livres",
    "get_oid_from_mp3_filename",
]

# %% 08 download mp3 from db info.ipynb 2
AUDIO_PATH = "audios"

# %% 08 download mp3 from db info.ipynb 6
import os
from git import Repo


def get_audio_path(audio_path=AUDIO_PATH):
    """
    audio_path: str
        relative path to audio files
    return full audio path and create dir if it doesn t exist
    """

    def get_git_root(path):
        git_repo = Repo(path, search_parent_directories=True)
        return git_repo.git.rev_parse("--show-toplevel")

    project_root = get_git_root(os.getcwd())
    full_audio_path = os.path.join(project_root, audio_path)

    # create dir if it doesn t exist
    if not os.path.exists(full_audio_path):
        os.makedirs(full_audio_path)

    return full_audio_path


# %% 08 download mp3 from db info.ipynb 10
import requests
from bson import ObjectId


def download_mp3_livres(collection, oid, audio_path=AUDIO_PATH, verbose=False):
    """
    on telecharge le fichier mp3 du document avec l oid specifie
    si :
    - le champ type vaut livres
    - le champ url existe
    - le champ duree existe et est superieur a 15 minutes (ajouter un parametrage apres)
    - le mp3 n existe pas deja dans audio_path

    si on veut forcer le telechargement, il faut manuellement supprimer le fichier mp3 dans audio_path

    collection: pymongo collection
    oid: str, oid du document
    audio_path: str, path to save audio files, default is 'AUDIO_PATH', abreviated, and is created if it doesn t exist
    """

    full_audio_path = get_audio_path(audio_path)
    if verbose:
        print(f"audio path: {full_audio_path}")

    # Récupération du document
    document_entry = collection.find_one({"_id": ObjectId(oid)})

    if document_entry is None:
        if verbose:
            print(f"Document avec l'oid {oid} non trouvé")
        return

    # Vérification si le type est bien "livres"
    if document_entry.get("type") != "livres":
        if verbose:
            print(f"Document avec l'oid {oid} n'est pas de type livres")
        return

    # verfiication si la duree est > 15 minutes
    duree = document_entry.get("duree")
    if duree is None or duree < 15:
        if verbose:
            print(f"Document avec l'oid {oid} n'est fait moins de 15 minutes")
        return

    url = document_entry.get("url")
    if url is None:
        if verbose:
            print(f"Document avec l'oid {oid} n'a pas d'url")
        return
    if verbose:
        print(f'{document_entry["type"]} - {document_entry.get("description")} - {url}')

    filename = os.path.join(full_audio_path, os.path.basename(url))

    # Vérification si le fichier existe déjà
    if not os.path.exists(filename):
        if verbose:
            print(f"Téléchargement de {url} vers {filename}")
        response = requests.get(url)
        with open(filename, "wb") as file:
            file.write(response.content)
    else:
        if verbose:
            print(f"Le fichier {filename} existe déjà. Ignoré.")


# %% 08 download mp3 from db info.ipynb 13
import requests


def download_all_mp3_livres(collection, audio_path=AUDIO_PATH, verbose=False):
    """
    on boucle dans tous les documents de la collection et telecharge les fichiers mp3
    si :
    - le champ type vaut livres
    - le champ url existe
    - le champ duree existe et est superieur a 15 minutes (ajouter un parametrage apres)
    - le mp3 n existe pas deja dans audio_path

    si on veut forcer le telechargement, il faut manuellement supprimer le fichier mp3 dans audio_path

    collection: pymongo collection
    audio_path: str, path to save audio files, default is 'AUDIO_PATH', abreviated, and is created if it doesn t exist
    """

    full_audio_path = get_audio_path(audio_path)
    if verbose:
        print(f"audio path: {full_audio_path}")
    # Récupération de toutes les entrées dans la collection
    entries = collection.find()

    for entry in entries:

        # get oid
        oid = entry["_id"]
        if verbose:
            print(oid)

        download_mp3_livres(collection, oid, audio_path, verbose)


# %% 08 download mp3 from db info.ipynb 16
def get_oid_from_mp3_filename(collection, full_mp3_filename):
    """
    on retourne l oid du document qui a le champ url contenant un abreviated full_mp3_filename
    collection: pymongo collection
    full_mp3_filename: str, nom du fichier mp3 complet
    return oidm None si non trouve
    """
    # Extraire le nom de fichier abrégé à partir du chemin complet
    mp3_filename = os.path.basename(full_mp3_filename)

    # Rechercher le document avec le champ url contenant le nom de fichier MP3 abrégé
    document = collection.find_one({"url": {"$regex": mp3_filename}})

    if document:
        return document["_id"]
    else:
        return None
