# AUTOGENERATED! DO NOT EDIT! File to edit: avis_critiques_parser.ipynb.

# %% auto 0
__all__ = [
    "AvisCritiquesParser",
    "BookData",
]

# %% avis_critiques_parser.ipynb 1
import re
import logging
from dataclasses import dataclass
from typing import List, Optional, Dict, Any
from datetime import datetime
from bson import ObjectId

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class BookData:
    """Structure de données pour un livre extrait d'un avis critique"""

    auteur: str
    titre: str
    editeur: str
    note_moyenne: Optional[float] = None
    nb_critiques: Optional[int] = None
    coup_de_coeur: Optional[str] = None
    chef_doeuvre: Optional[str] = None
    avis_details: Optional[str] = None

    def __post_init__(self):
        """Nettoie les données après initialisation"""
        self.auteur = self._clean_string(self.auteur)
        self.titre = self._clean_string(self.titre)
        self.editeur = self._clean_string(self.editeur)
        if self.coup_de_coeur:
            self.coup_de_coeur = self._clean_string(self.coup_de_coeur)
        if self.chef_doeuvre:
            self.chef_doeuvre = self._clean_string(self.chef_doeuvre)

    def _clean_string(self, s: str) -> str:
        """Nettoie une chaîne de caractères"""
        if not s:
            return ""
        # Supprimer les espaces en trop et les caractères de contrôle
        s = re.sub(r"\s+", " ", s.strip())
        # Supprimer les caractères de pipe en début/fin
        s = s.strip("|").strip()
        return s

    def to_dict(self) -> Dict[str, Any]:
        """Convertit en dictionnaire pour MongoDB"""
        return {
            "auteur": self.auteur,
            "titre": self.titre,
            "editeur": self.editeur,
            "note_moyenne": self.note_moyenne,
            "nb_critiques": self.nb_critiques,
            "coup_de_coeur": self.coup_de_coeur,
            "chef_doeuvre": self.chef_doeuvre,
            "avis_details": self.avis_details,
        }


# %% avis_critiques_parser.ipynb 2
class AvisCritiquesParser:
    """Parser pour extraire les livres et auteurs des avis critiques existants"""

    def __init__(self):
        """Initialise le parser avec les patterns regex"""
        # Pattern pour identifier le début du tableau des livres
        self.table_start_pattern = re.compile(
            r"\|\s*Auteur\s*\|\s*Titre\s*\|\s*Éditeur.*?\n" r"\|[-\s|]+\n",
            re.IGNORECASE | re.MULTILINE,
        )

        # Pattern pour extraire les lignes de données du tableau
        self.table_row_pattern = re.compile(
            r"^\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]*)\s*\|\s*([^|]*)\s*\|",
            re.MULTILINE,
        )

        # Pattern pour extraire la note moyenne depuis le HTML span
        self.note_pattern = re.compile(
            r"<span[^>]*>([0-9]+\.?[0-9]*)</span>", re.IGNORECASE
        )

        # Pattern pour extraire le nombre de critiques
        self.nb_critiques_pattern = re.compile(r"(\d+)")

    def extract_books_from_summary(
        self, summary: str, episode_oid: str = None
    ) -> List[BookData]:
        """
        Extrait les livres depuis un résumé d'avis critiques

        Args:
            summary (str): Le résumé markdown contenant les tableaux
            episode_oid (str): ObjectId de l'épisode (pour logging)

        Returns:
            List[BookData]: Liste des livres extraits
        """
        try:
            books = []

            # Rechercher le début du tableau
            table_match = self.table_start_pattern.search(summary)
            if not table_match:
                logger.warning(f"Aucun tableau trouvé pour l'épisode {episode_oid}")
                return books

            # Extraire la partie après l'en-tête du tableau
            table_content = summary[table_match.end() :]

            # Extraire chaque ligne de données
            for match in self.table_row_pattern.finditer(table_content):
                try:
                    book_data = self._parse_table_row(match.groups())
                    if book_data and book_data.auteur and book_data.titre:
                        books.append(book_data)
                        logger.debug(
                            f"Livre extrait: {book_data.auteur} - {book_data.titre}"
                        )
                except Exception as e:
                    logger.error(
                        f"Erreur parsing ligne tableau pour épisode {episode_oid}: {e}"
                    )
                    continue

            logger.info(f"Extraits {len(books)} livres pour l'épisode {episode_oid}")
            return books

        except Exception as e:
            logger.error(f"Erreur extraction livres pour épisode {episode_oid}: {e}")
            return []

    def _parse_table_row(self, row_data: tuple) -> Optional[BookData]:
        """
        Parse une ligne du tableau markdown

        Args:
            row_data (tuple): Données de la ligne (auteur, titre, editeur, avis, note, nb, coeur, chef)

        Returns:
            Optional[BookData]: Données du livre ou None si erreur
        """
        try:
            if len(row_data) < 8:
                logger.warning(f"Ligne tableau incomplète: {len(row_data)} colonnes")
                return None

            auteur, titre, editeur, avis_details, note_col, nb_col, coup_coeur, chef = (
                row_data
            )

            # Filtrer les lignes génériques ou vides
            if (
                auteur.strip().lower() in ["auteur", ""]
                or titre.strip().lower() in ["titre", ""]
                or auteur.strip() == titre.strip() == "N/A"
            ):
                logger.debug(f"Ligne générique ignorée: {auteur} - {titre}")
                return None

            # Extraire la note moyenne
            note_moyenne = self._extract_note_moyenne(note_col)

            # Extraire le nombre de critiques
            nb_critiques = self._extract_nb_critiques(nb_col)

            return BookData(
                auteur=auteur,
                titre=titre,
                editeur=editeur,
                note_moyenne=note_moyenne,
                nb_critiques=nb_critiques,
                coup_de_coeur=coup_coeur if coup_coeur.strip() else None,
                chef_doeuvre=chef if chef.strip() else None,
                avis_details=avis_details,
            )

        except Exception as e:
            logger.error(f"Erreur parsing ligne: {e}")
            return None

    def _extract_note_moyenne(self, note_col: str) -> Optional[float]:
        """Extrait la note moyenne depuis la colonne note (format HTML span)"""
        try:
            match = self.note_pattern.search(note_col)
            if match:
                return float(match.group(1))
        except (ValueError, AttributeError) as e:
            logger.debug(f"Impossible d'extraire la note: {e}")
        return None

    def _extract_nb_critiques(self, nb_col: str) -> Optional[int]:
        """Extrait le nombre de critiques"""
        try:
            match = self.nb_critiques_pattern.search(nb_col)
            if match:
                return int(match.group(1))
        except (ValueError, AttributeError) as e:
            logger.debug(f"Impossible d'extraire le nombre de critiques: {e}")
        return None

    def parse_markdown_tables(self, markdown_text: str) -> List[Dict[str, Any]]:
        """
        Parse tous les tableaux markdown d'un texte

        Args:
            markdown_text (str): Texte markdown contenant des tableaux

        Returns:
            List[Dict]: Liste des livres sous forme de dictionnaires
        """
        books = self.extract_books_from_summary(markdown_text)
        return [book.to_dict() for book in books]

    def validate_extraction(self, books: List[BookData]) -> Dict[str, Any]:
        """
        Valide l'extraction et retourne des statistiques

        Args:
            books (List[BookData]): Liste des livres extraits

        Returns:
            Dict[str, Any]: Statistiques de validation
        """
        stats = {
            "total_books": len(books),
            "books_with_notes": len([b for b in books if b.note_moyenne is not None]),
            "books_with_coup_coeur": len([b for b in books if b.coup_de_coeur]),
            "books_with_chef_doeuvre": len([b for b in books if b.chef_doeuvre]),
            "unique_authors": len(set(b.auteur for b in books)),
            "unique_editors": len(set(b.editeur for b in books)),
            "validation_errors": [],
        }

        # Vérifications de qualité
        for i, book in enumerate(books):
            if not book.auteur.strip():
                stats["validation_errors"].append(f"Livre {i}: auteur vide")
            if not book.titre.strip():
                stats["validation_errors"].append(f"Livre {i}: titre vide")
            if book.note_moyenne and (book.note_moyenne < 0 or book.note_moyenne > 10):
                stats["validation_errors"].append(
                    f"Livre {i}: note invalide {book.note_moyenne}"
                )

        return stats


# %% avis_critiques_parser.ipynb 3
def test_parser_functionality():
    """Fonction de test pour valider le parser"""
    # Exemple de données de test basées sur les vrais formats
    test_summary = """
## 1. LIVRES DISCUTÉS AU PROGRAMME du 29 juin 2025
| Auteur | Titre | Éditeur | Avis détaillés des critiques | Note moyenne | Nb critiques | Coup de cœur | Chef d'œuvre |
|--------|-------|---------|------------------------------|--------------|--------------|-------------|-------------|
| Aslak Nord | Piège à loup | Le bruit du monde | **Patricia Martin**: "Largement au-dessus du lot" (10) | <span style="background-color: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold;">8.8</span> | 4 | Patricia Martin | Patricia Martin |
| Mario Vargas Llosa | Je vous dédie mon silence | Gallimard | **Jean-Marc Proust**: "Œuvre crépusculaire" (6) | <span style="background-color: #CDDC39; color: black; padding: 2px 6px; border-radius: 3px; font-weight: bold;">6.8</span> | 4 | Arnaud Viviant | |
"""

    parser = AvisCritiquesParser()
    books = parser.extract_books_from_summary(test_summary, "test_episode")

    print(f"=== TEST PARSER ===")
    print(f"Livres extraits: {len(books)}")

    for book in books:
        print(
            f"- {book.auteur} - {book.titre} ({book.editeur}) - Note: {book.note_moyenne}"
        )

    # Validation
    stats = parser.validate_extraction(books)
    print(f"\n=== STATISTIQUES ===")
    for key, value in stats.items():
        print(f"{key}: {value}")

    return len(books) > 0


if __name__ == "__main__":
    test_parser_functionality()
