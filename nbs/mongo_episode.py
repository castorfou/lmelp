# AUTOGENERATED! DO NOT EDIT! File to edit: py mongo helper episodes.ipynb.

# %% auto 0
__all__ = [
    "AUDIO_PATH",
    "DATE_FORMAT",
    "LOG_DATE_FORMAT",
    "RSS_DUREE_MINI_MINUTES",
    "RSS_DATE_FORMAT",
    "WEB_DATE_FORMAT",
    "get_audio_path",
    "prevent_sleep",
    "extract_whisper",
    "Episode",
    "RSS_episode",
    "WEB_episode",
    "Episodes",
]

# %% py mongo helper episodes.ipynb 3
import os
from git import Repo

AUDIO_PATH = "audios"


def get_audio_path(audio_path=AUDIO_PATH, year: str = "2024"):
    """
    audio_path: str
        relative path to audio files
    will add year as subdirectory
    return full audio path and create dir if it doesn t exist
    """

    def get_git_root(path):
        git_repo = Repo(path, search_parent_directories=True)
        return git_repo.git.rev_parse("--show-toplevel")

    project_root = get_git_root(os.getcwd())
    full_audio_path = os.path.join(project_root, audio_path, year)

    # create dir if it doesn t exist
    if not os.path.exists(full_audio_path):
        os.makedirs(full_audio_path)

    return full_audio_path


# %% py mongo helper episodes.ipynb 6
import torch
from transformers import AutoModelForSpeechSeq2Seq, AutoProcessor, pipeline
from datasets import load_dataset

import dbus
import time
from functools import wraps


def prevent_sleep(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        # Connexion au bus D-Bus
        bus = dbus.SessionBus()
        proxy = bus.get_object(
            "org.freedesktop.ScreenSaver", "/org/freedesktop/ScreenSaver"
        )
        interface = dbus.Interface(proxy, "org.freedesktop.ScreenSaver")

        # Prévenir la mise en veille
        cookie = interface.Inhibit("my_script", "Long running process")
        print("Mise en veille désactivée")

        try:
            # Exécuter la fonction décorée
            result = func(*args, **kwargs)
            return result
        finally:
            # Réactiver la mise en veille normale
            interface.UnInhibit(cookie)
            print("Mise en veille normale réactivée")

    return wrapper


@prevent_sleep
def extract_whisper(mp3_filename):

    device = "cuda:0" if torch.cuda.is_available() else "cpu"
    torch_dtype = torch.float16 if torch.cuda.is_available() else torch.float32

    model_id = "openai/whisper-large-v3-turbo"

    model = AutoModelForSpeechSeq2Seq.from_pretrained(
        model_id, torch_dtype=torch_dtype, low_cpu_mem_usage=True, use_safetensors=True
    )
    model.to(device)

    processor = AutoProcessor.from_pretrained(model_id)

    pipe = pipeline(
        "automatic-speech-recognition",
        model=model,
        tokenizer=processor.tokenizer,
        feature_extractor=processor.feature_extractor,
        torch_dtype=torch_dtype,
        device=device,
    )

    dataset = load_dataset(
        "distil-whisper/librispeech_long", "clean", split="validation"
    )
    sample = dataset[0]["audio"]

    result = pipe(
        mp3_filename,
        return_timestamps=True,
    )

    return result["text"]


# %% py mongo helper episodes.ipynb 7
from bson import ObjectId
from mongo import get_collection, get_DB_VARS, mongolog
from datetime import datetime
import requests
from typing import Dict, List
from llm import get_azure_llm
from llama_index.core.llms import ChatMessage
import json


DATE_FORMAT = "%Y-%m-%dT%H:%M:%S"
LOG_DATE_FORMAT = "%d %b %Y %H:%M"


class Episode:
    def __init__(self, date: str, titre: str, collection_name: str = "episodes"):
        """
        Episode is a class that represents a generic Episode entity in the database.
        :param date: The date for this episode at the format "2024-12-22T09:59:39" parsed by "%Y-%m-%dT%H:%M:%S".
        :param titre: The title of this episode.
        :param collection_name: The name of the collection. default: "episodes".

        if this episode already exists in DB, loads it
        """
        DB_HOST, DB_NAME, _ = get_DB_VARS()
        self.collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name
        )
        self.date = Episode.get_date_from_string(date)
        self.titre = titre

        if self.exists():
            episode = self.collection.find_one({"titre": self.titre, "date": self.date})
            self.description = episode.get("description")
            self.url_telechargement = episode.get("url")
            self.audio_rel_filename = episode.get("audio_rel_filename")
            self.transcription = episode.get("transcription")
            self.type = episode.get("type")
            self.duree = episode.get("duree")
        else:
            self.description = None
            self.url_telechargement = None
            self.audio_rel_filename = None
            self.transcription = None
            self.type = None
            self.duree = -1  # in seconds

    @classmethod
    def from_oid(cls, oid: ObjectId, collection_name: str = "episodes") -> "Episode":
        """
        Create an episode from an oid of a mongo entry.
        :param oid: oid as ObjectId.
        :return: The Eepisode.
        """

        DB_HOST, DB_NAME, _ = get_DB_VARS()
        collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name
        )

        document = collection.find_one({"_id": oid})

        date_doc_str = cls.get_string_from_date(document.get("date"), DATE_FORMAT)
        inst = cls(date=date_doc_str, titre=document.get("titre"))
        return inst

    @classmethod
    def from_date(cls, date: datetime, collection_name: str = "episodes") -> "Episode":
        """
        Create an episode from a date of a mongo entry.
        :param date: date as datetime.
        :return: The Episode.
        """
        DB_HOST, DB_NAME, _ = get_DB_VARS()
        collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name
        )

        # Convertir la date en début et fin de journée pour la requête
        start_date = datetime(date.year, date.month, date.day)
        end_date = datetime(date.year, date.month, date.day, 23, 59, 59)

        # Rechercher un document dont la date est dans l'intervalle
        document = collection.find_one({"date": {"$gte": start_date, "$lte": end_date}})

        if document:
            date_doc_str = cls.get_string_from_date(document.get("date"), DATE_FORMAT)
            inst = cls(date=date_doc_str, titre=document.get("titre"))
            return inst
        else:
            return None

    def exists(self) -> bool:
        """
        Check if the episode exists in the database.
        :return: True if the episode exists, False otherwise.
        """
        return (
            self.collection.find_one({"titre": self.titre, "date": self.date})
            is not None
        )

    def keep(self) -> int:
        """
        download the audio file if needed
        Keep the episode in the database

        retourne 1 si 1 entree est creee en base
        0 sinon
        """
        message_log = f"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}"
        if not self.exists():
            print(
                f"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} nouveau: Duree: {self.duree}, Type: {self.type}"
            )
            mongolog("insert", self.collection.name, message_log)
            self.download_audio(verbose=True)
            self.collection.insert_one(
                {
                    "titre": self.titre,
                    "date": self.date,
                    "description": self.description,
                    "url": self.url_telechargement,
                    "audio_rel_filename": self.audio_rel_filename,
                    "transcription": self.transcription,
                    "type": self.type,
                    "duree": self.duree,
                }
            )
            return 1
        else:
            print(
                f"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} deja existant"
            )
            mongolog("update", self.collection.name, message_log)
            return 0

    def update_date(self, new_date: datetime):
        """
        Update the date of the episode.
        :param new_date: The new date of the episode, datetime format.
        """
        self.collection.update_one(
            {"_id": self.get_oid()}, {"$set": {"date": new_date}}
        )
        message_log = f"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre} -> {Episode.get_string_from_date(new_date, format=LOG_DATE_FORMAT)}"
        self.date = new_date
        mongolog("force_update", self.collection.name, message_log)

    def remove(self):
        """
        Remove the episode from the database.
        """
        message_log = f"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}"
        self.collection.delete_one({"titre": self.titre, "date": self.date})
        mongolog("delete", self.collection.name, message_log)

    def get_oid(self) -> ObjectId:
        """
        Get the object id of the episode.
        :return: The object id of the episode. (bson.ObjectId)
        None if does not exist.
        """
        document = self.collection.find_one({"titre": self.titre, "date": self.date})
        if document:
            return document["_id"]
        else:
            return None

    @staticmethod
    def get_date_from_string(date: str, DATE_FORMAT: str = DATE_FORMAT) -> datetime:
        """
        Get the datetime object from a string.
        :param date: The date string.
        :return: The datetime object.
        """
        return datetime.strptime(date, DATE_FORMAT)

    @staticmethod
    def get_string_from_date(date: datetime, format: str = None) -> str:
        """
        Get the string from a datetime object.
        :param date: The datetime object.
        :param format: The format of the string. default: None and DATE_FORMAT will be used.
        :return: The date string.
        """
        if format is not None:
            return date.strftime(format)
        else:
            return date.strftime(DATE_FORMAT)

    @staticmethod
    def format_duration(seconds: int) -> str:
        """Convert duration in seconds to HH:MM:SS format."""
        if seconds < 0:
            return f"-{Episode.format_duration(seconds*(-1))}"
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        seconds = seconds % 60
        return f"{hours:02}:{minutes:02}:{seconds:02}"

    def __str__(self):
        return f"""
        _oid: {self.get_oid()}
        Date: {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)}
        Titre: {self.titre}
        Description: {self.description}
        URL de téléchargement: {self.url_telechargement}
        Fichier audio: {self.audio_rel_filename}
        Duree: {self.duree} en secondes ({Episode.format_duration(self.duree)})
        Transcription: {self.transcription[:100] if self.transcription else 'No transcription yet available'}...
        """

    def __repr__(self):
        return self.__str__()

    def download_audio(self, verbose=False):
        """
        based on url_telechargement
        will download audio file and store in AUDIO_PATH/year
        """
        if self.url_telechargement is None:
            return
        year = str(self.date.year)
        full_audio_path = get_audio_path(AUDIO_PATH, year)
        full_filename = os.path.join(
            full_audio_path, os.path.basename(self.url_telechargement)
        )
        self.audio_rel_filename = os.path.relpath(
            full_filename, get_audio_path(AUDIO_PATH, year="")
        )
        # Vérification si le fichier existe déjà
        if not os.path.exists(full_filename):
            if verbose:
                print(
                    f"Téléchargement de {self.url_telechargement} vers {full_filename}"
                )
            response = requests.get(self.url_telechargement)
            with open(full_filename, "wb") as file:
                file.write(response.content)
        else:
            if verbose:
                print(f"Le fichier {full_filename} existe déjà. Ignoré.")

    def set_transcription(self, verbose=False, keep_cache=True):
        """
        based on audio file, use whisper model to get transcription
        if transcription already exists, do nothing
        if cache transcription (meaning a txt file aside audio file, same stem name), read it and store in DB
        if audio file does not exist, do nothing
        if keep_cache, save transcription in a txt file aside audio file, same stem name
        save transcription in DB
        """
        if self.transcription is not None:
            if verbose:
                print("Transcription existe deja")
            return
        mp3_fullfilename = get_audio_path(AUDIO_PATH, year="") + self.audio_rel_filename
        cache_transcription_filename = f"{os.path.splitext(mp3_fullfilename)[0]}.txt"
        # check if cache_transcription_file exists
        if os.path.exists(cache_transcription_filename):
            if verbose:
                print(f"Transcription cachee trouvee: {cache_transcription_filename}")
            with open(cache_transcription_filename, "r") as file:
                self.transcription = file.read()
            self.collection.update_one(
                {"_id": self.get_oid()},
                {"$set": {"transcription": self.transcription}},
            )
            return

        self.transcription = extract_whisper(mp3_fullfilename)
        if keep_cache:
            # Écrire la transcription dans un fichier texte
            with open(cache_transcription_filename, "w") as f:
                f.write(self.transcription)
        self.collection.update_one(
            {"_id": self.get_oid()}, {"$set": {"transcription": self.transcription}}
        )

    def to_dict(self) -> Dict[str, str]:
        """
        return episode as a dictionnary
        keys are ['date', 'titre', 'description', 'url_telechargement', 'audio_rel_filename', 'transcription', 'type', 'duree']
        """
        return {
            "date": self.date,
            "titre": self.titre,
            "description": self.description,
            "url_telechargement": self.url_telechargement,
            "audio_rel_filename": self.audio_rel_filename,
            "transcription": self.transcription,
            "type": self.type,
            "duree": self.duree,
        }

    def get_all_auteurs(self) -> List[str]:
        """
        Get all the authors of the episode from the transcription.
        :return: The list of authors.
        """
        if self.transcription is None:
            return []

        llm_structured_output = get_azure_llm("gpt-4o")
        response_schema = {
            "type": "json_schema",
            "json_schema": {
                "name": "AuthorList",
                "schema": {
                    "type": "object",
                    "properties": {
                        "Authors": {
                            "type": "array",
                            "items": {
                                "type": "string",
                                "description": "A list of authors from transcription",
                            },
                        }
                    },
                    "required": ["Authors"],
                    "additionalProperties": False,
                },
            },
        }
        response = llm_structured_output.chat(
            messages=[
                ChatMessage(
                    role="system",
                    content="Tu es un assistant utile qui retourne une liste JSON de noms d'auteurs.",
                ),
                ChatMessage(
                    role="user",
                    content=f"Est-ce que tu peux me lister tous les noms d'auteurs dont on parle des oeuvres \
                            dans cette transcription d'un episode du masque et la plume \
                            diffuse le {self.date.strftime('%d %b %Y')}. \
                            Je veux toujours avoir le prenom et le nom complet de chaque auteur. \
                            voici cette transcription : \
                            {self.transcription} ",
                ),
            ],
            response_format=response_schema,
        )
        try:
            json_dict = json.loads(response.message.content)
        except json.JSONDecodeError as e:
            print("Error parsing JSON:", e)
            print("Raw response:", json_dict)
        return json_dict["Authors"]


# %% py mongo helper episodes.ipynb 15
from feedparser.util import FeedParserDict
from transformers import pipeline
import locale

RSS_DUREE_MINI_MINUTES = 15
RSS_DATE_FORMAT = "%a, %d %b %Y %H:%M:%S %z"  # "Sun, 29 Dec 2024 10:59:39 +0100" 'Sun, 26 Jan 2025 10:59:39 +0100'


class RSS_episode(Episode):
    def __init__(self, date: str, titre: str):
        """
        RSS_episode is a class that represents an RSS episode in the database episodes.
        :param date: The date for this episode at the format "2024-12-22T09:59:39" parsed by "%Y-%m-%dT%H:%M:%S".
        :param titre: The title of this episode.
        """
        super().__init__(date, titre)

    @classmethod
    def from_feed_entry(cls, feed_entry: FeedParserDict) -> "RSS_episode":
        """
        Create an RSS episode from a feed entry.
        :param feed_entry: The feed entry.
        :return: The RSS episode.
        """
        locale.setlocale(locale.LC_TIME, "en_US.UTF-8")

        date_rss = datetime.strptime(feed_entry.published, RSS_DATE_FORMAT)
        date_rss_str = cls.get_string_from_date(date_rss, DATE_FORMAT)
        inst = cls(
            date=date_rss_str,
            titre=feed_entry.title,
        )
        inst.description = feed_entry.summary

        for link in feed_entry.links:
            if link.type == "audio/mpeg":
                inst.url_telechargement = link.href
                break

        # self.audio_rel_filename = None
        # self.transcription = None
        inst.type = cls.set_titre(inst.titre + " " + inst.description)
        inst.duree = cls.get_duree_in_seconds(feed_entry.itunes_duration)  # in seconds

        return inst

    @staticmethod
    def get_duree_in_seconds(duree: str) -> int:
        """
        Get the duration in seconds from a string.
        :param duree: The duration string at the format "HH:MM:SS" or "HH:MM".
        :return: The duration in seconds.
        """
        duree = duree.split(":")
        if len(duree) == 3:
            return int(duree[0]) * 3600 + int(duree[1]) * 60 + int(duree[2])
        elif len(duree) == 2:
            return int(duree[0]) * 60 + int(duree[1])
        else:
            return int(duree[0])

    def keep(self) -> int:
        """
        Keep the episode in the database.
        only if duration > RSS_DUREE_MINI_MINUTES * 60
        only if type == livres

        retourne 1 si 1 entree est creee en base
        0 sinon
        """
        if (self.duree > RSS_DUREE_MINI_MINUTES * 60) & (self.type == "livres"):
            return super().keep()
        else:
            print(
                f"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} ignored: Duree: {self.duree}, Type: {self.type}"
            )
            return 0

    @staticmethod
    def set_titre(description: str) -> str:
        """
        use bart meta model from huggingface to classify episodes from
        ["livres", "films", "pièces de théâtre"]
        """
        # Charger le pipeline de classification de texte
        classifier = pipeline(
            "zero-shot-classification", model="facebook/bart-large-mnli"
        )
        # Labels possibles
        labels = ["livres", "films", "pièces de théâtre"]

        result = classifier(description, labels)
        return result["labels"][0]


# %% py mongo helper episodes.ipynb 29
import requests
from bs4 import BeautifulSoup
import json
import locale


WEB_DATE_FORMAT = "%d %b %Y"  # '26 août 2024', '20 oct. 2024', '22 sept. 2024', '8 sept. 2024', '25 août 2024', '4 août 2024', '23 juin 2024', '19 mai 2024', '5 mai 2024',


class WEB_episode(Episode):
    def __init__(self, date: str, titre: str):
        """
        WEB_episode is a class that represents an historical episode (legacy, not available anymore as RSS) in the database episodes.
        :param date: The date for this episode at the format "2024-12-22T09:59:39" parsed by "%Y-%m-%dT%H:%M:%S".
        :param titre: The title of this episode.
        """
        super().__init__(date, titre)

    @staticmethod
    def parse_web_date(web_date: str, web_date_format=WEB_DATE_FORMAT) -> datetime:
        """Convertit une date en français dans la page de masque sous forme de chaîne de caractères en un objet datetime.
        la page du masque utilise des abreviations non standards pour fev et juil
        """

        locale.setlocale(locale.LC_TIME, "fr_FR.UTF-8")

        def corrige_date(date_str):
            # Dictionnaire de remplacement pour corriger les abréviations des mois
            month_replacements = {
                "fév.": "févr.",
                "juill.": "juil.",
            }
            for fr_month, fr_month_norm in month_replacements.items():
                date_str = date_str.replace(fr_month, fr_month_norm)
            return date_str

        # Convertir la date normalisée en objet datetime
        try:
            dt = datetime.strptime(corrige_date(web_date), web_date_format)
            return dt
        except ValueError as e:
            print(f"Erreur de conversion pour la date '{web_date}': {e}")
            return None

    @staticmethod
    def get_audio_url(url):
        """
        Prend l'url d'un épisode du masque en entrée et retourne l'URL vers le fichier audio .m4a ou .mp3.
        """

        try:
            # Faire une requête HTTP pour obtenir le contenu de la page
            response = requests.get(url)
            response.raise_for_status()  # Vérifier que la requête a réussi
        except requests.RequestException as e:
            print(f"Erreur lors de la requête HTTP: {e}")
            return None

        # Analyser le contenu HTML avec BeautifulSoup
        soup = BeautifulSoup(response.content, "html.parser")

        # Rechercher la balise <script> contenant l'objet JSON
        script_tag = soup.find("script", string=lambda t: t and "contentUrl" in t)

        if script_tag:
            try:
                # Extraire le contenu JSON de la balise <script>
                json_text = script_tag.string
                json_data = json.loads(json_text)

                # Extraire l'URL du fichier audio
                audio_url = None
                for item in json_data.get("@graph", []):
                    if item.get("@type") == "RadioEpisode":
                        main_entity = item.get("mainEntity", {})
                        audio_url = main_entity.get("contentUrl")
                        break

                return audio_url
            except (json.JSONDecodeError, KeyError, TypeError) as e:
                print(f"Erreur lors de l'analyse du JSON: {e}")
                return None

        print("Balise <script> contenant 'contentUrl' non trouvée")
        return None

    @classmethod
    def from_webpage_entry(cls, dict_web_episode: dict) -> "WEB_episode":
        """
        Create a WEB episode from a dict web episode entry.
        :param dict_web_episode: The web episode entry with these keys: ['title', 'url', 'description', 'date', 'duration']
        :return: The WEB episode.
        """

        date_web = cls.parse_web_date(dict_web_episode["date"])
        date_web_str = cls.get_string_from_date(date_web, DATE_FORMAT)
        inst = cls(
            date=date_web_str,
            titre=dict_web_episode["title"],
        )
        inst.description = dict_web_episode["description"]
        inst.type = "livres"
        inst.url_telechargement = cls.get_audio_url(dict_web_episode["url"])

        # self.audio_rel_filename = None
        # self.transcription = None
        inst.duree = cls.get_duree_in_seconds(
            dict_web_episode["duration"]
        )  # in seconds

        return inst

    @staticmethod
    def get_duree_in_seconds(duree: str) -> int:
        """
        Get the duration in seconds from a string.
        :param duree: The duration string at the format "MM min".
        :return: The duration in seconds.
        """
        duree = duree.split(" ")
        if len(duree) == 2:
            return int(duree[0]) * 60


# %% py mongo helper episodes.ipynb 36
from typing import List, Dict, Any
import pymongo


class Episodes:
    """
    This is a class that will allow search on episodes to manage quality of data

    For example get new transcriptions.
    """

    def __init__(self, collection_name: str = "episodes"):
        DB_HOST, DB_NAME, _ = get_DB_VARS()
        self.collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name
        )
        self.episodes = self._load_episodes()

    def _load_episodes(self) -> List[Dict[str, Any]]:
        """
        Load all episodes from the database and return them as a list of dictionaries.
        """
        return self.get_entries()

    def get_entries(self, request="") -> List[Episode]:
        """'
        retourne le resultat de la requete sous forme d'une liste d'instance de Episode
        tries par date decroissante (du plus recent au plus vieux)

        par exemple : request={"$or": [{"transcription": ""}, {"transcription": None}]}
        """
        result = self.collection.find(request).sort("date", pymongo.DESCENDING)
        episodes = [Episode.from_oid(entry.get("_id")) for entry in result]
        return episodes

    def get_missing_transcriptions(self) -> List[Episode]:
        """
        retourne les episodes pour lesquels la transcription est manquante
        """
        return self.get_entries(
            {"$or": [{"transcription": ""}, {"transcription": None}]}
        )

    def get_transcriptions(self) -> List[Episode]:
        """
        Retourne toutes les entrées pour lesquelles une transcription existe.
        """
        return self.get_entries(
            {"$and": [{"transcription": {"$ne": None}}, {"transcription": {"$ne": ""}}]}
        )

    def __getitem__(self, index: int) -> Dict[str, Any]:
        return self.episodes[index]

    def __len__(self) -> int:
        return len(self.episodes)

    def __iter__(self):
        return iter(self.episodes)

    def __repr__(self) -> str:
        return f"Episodes({self.episodes})"

    def __str__(self):
        return f"""
        {self.collection.count_documents({})} entries
        {len(self.get_missing_transcriptions())} missing transcriptions
        """

    def __repr__(self):
        return self.__str__()
