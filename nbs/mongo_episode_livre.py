# AUTOGENERATED! DO NOT EDIT! File to edit: mongo_episode_livre.ipynb.

# %% auto 0
__all__ = [
    "EpisodeLivre",
]

# %% mongo_episode_livre.ipynb 1
from mongo import BaseEntity, get_collection
from config import get_DB_VARS
from typing import List, Optional, Dict, Any, Type, TypeVar
from bson import ObjectId
from datetime import datetime
import logging

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

T = TypeVar("T", bound="EpisodeLivre")


# %% mongo_episode_livre.ipynb 2
class EpisodeLivre(BaseEntity):
    """
    Classe pour gérer la relation entre épisodes et livres dans la collection episode_livres.

    Cette classe lie les épisodes aux livres discutés avec leurs métadonnées spécifiques :
    - Notes moyennes et critiques
    - Date de l'épisode pour tri chronologique
    - Références vers les collections episodes, livres, auteurs
    """

    collection: str = "episode_livres"

    def __init__(
        self, episode_oid: ObjectId, livre_oid: ObjectId, auteur_oid: ObjectId = None
    ) -> None:
        """
        Initialise une relation épisode-livre.

        Args:
            episode_oid (ObjectId): ObjectId de l'épisode
            livre_oid (ObjectId): ObjectId du livre
            auteur_oid (ObjectId, optional): ObjectId de l'auteur
        """
        # Créer un nom unique basé sur les ObjectIds pour hériter de BaseEntity
        unique_name = f"{episode_oid}_{livre_oid}"
        super().__init__(unique_name, self.collection)

        # Données de base
        self.episode_oid = episode_oid
        self.livre_oid = livre_oid
        self.auteur_oid = auteur_oid

        # Métadonnées de l'épisode (pour performance)
        self.episode_date = None
        self.episode_title = None

        # Métadonnées du livre (pour performance)
        self.livre_titre = None
        self.auteur_nom = None
        self.editeur_nom = None

        # Données critiques
        self.note_moyenne = None
        self.nb_critiques = None
        self.coup_de_coeur = None
        self.chef_doeuvre = None
        self.avis_details = None

        # Timestamps
        self.created_at = datetime.now()
        self.updated_at = datetime.now()

    def add_episode_metadata(self, episode_title: str, episode_date: str) -> None:
        """
        Ajoute les métadonnées de l'épisode pour optimiser les recherches.

        Args:
            episode_title (str): Titre de l'épisode
            episode_date (str): Date de l'épisode (format string)
        """
        self.episode_title = episode_title
        self.episode_date = episode_date
        self.updated_at = datetime.now()

    def add_book_metadata(
        self, livre_titre: str, auteur_nom: str, editeur_nom: str = None
    ) -> None:
        """
        Ajoute les métadonnées du livre pour optimiser les recherches.

        Args:
            livre_titre (str): Titre du livre
            auteur_nom (str): Nom de l'auteur
            editeur_nom (str, optional): Nom de l'éditeur
        """
        self.livre_titre = livre_titre
        self.auteur_nom = auteur_nom
        self.editeur_nom = editeur_nom
        self.updated_at = datetime.now()

    def add_rating_info(
        self,
        note_moyenne: float = None,
        nb_critiques: int = None,
        coup_de_coeur: str = None,
        chef_doeuvre: str = None,
        avis_details: str = None,
    ) -> None:
        """
        Ajoute les informations de notation et critiques.

        Args:
            note_moyenne (float, optional): Note moyenne du livre dans cet épisode
            nb_critiques (int, optional): Nombre de critiques
            coup_de_coeur (str, optional): Nom du critique ayant donné un coup de cœur
            chef_doeuvre (str, optional): Nom du critique ayant donné un chef d'œuvre
            avis_details (str, optional): Détails des avis critiques
        """
        self.note_moyenne = note_moyenne
        self.nb_critiques = nb_critiques
        self.coup_de_coeur = coup_de_coeur
        self.chef_doeuvre = chef_doeuvre
        self.avis_details = avis_details
        self.updated_at = datetime.now()

    def to_dict(self) -> Dict[str, Any]:
        """
        Sérialise l'instance en dictionnaire pour MongoDB.
        Override de BaseEntity pour exclure la collection.
        """
        data = super().to_dict()
        # On ajoute les champs spécifiques qui ne sont pas dans BaseEntity
        data.update(
            {
                "episode_oid": self.episode_oid,
                "livre_oid": self.livre_oid,
                "auteur_oid": self.auteur_oid,
                "episode_date": self.episode_date,
                "episode_title": self.episode_title,
                "livre_titre": self.livre_titre,
                "auteur_nom": self.auteur_nom,
                "editeur_nom": self.editeur_nom,
                "note_moyenne": self.note_moyenne,
                "nb_critiques": self.nb_critiques,
                "coup_de_coeur": self.coup_de_coeur,
                "chef_doeuvre": self.chef_doeuvre,
                "avis_details": self.avis_details,
                "created_at": self.created_at,
                "updated_at": self.updated_at,
            }
        )
        return data

    def exists(self) -> bool:
        """
        Override pour vérifier l'existence par episode_oid + livre_oid plutôt que par nom.
        """
        return (
            self.collection.find_one(
                {"episode_oid": self.episode_oid, "livre_oid": self.livre_oid}
            )
            is not None
        )

    # %% mongo_episode_livre.ipynb 3
    @classmethod
    def from_oid(cls: Type[T], oid: ObjectId) -> T:
        """
        Crée une instance depuis un ObjectId MongoDB.

        Args:
            oid (ObjectId): ObjectId du document episode_livres

        Returns:
            T: Instance de EpisodeLivre ou None si non trouvé
        """
        if oid is None:
            return None

        DB_HOST, DB_NAME, _ = get_DB_VARS()
        collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection
        )
        document = collection.find_one({"_id": oid})

        if document is None:
            return None

        instance = cls(
            episode_oid=document.get("episode_oid"),
            livre_oid=document.get("livre_oid"),
            auteur_oid=document.get("auteur_oid"),
        )

        # Restaurer toutes les métadonnées
        if document.get("episode_title"):
            instance.add_episode_metadata(
                document.get("episode_title"), document.get("episode_date")
            )

        if document.get("livre_titre"):
            instance.add_book_metadata(
                document.get("livre_titre"),
                document.get("auteur_nom"),
                document.get("editeur_nom"),
            )

        if document.get("note_moyenne") is not None:
            instance.add_rating_info(
                note_moyenne=document.get("note_moyenne"),
                nb_critiques=document.get("nb_critiques"),
                coup_de_coeur=document.get("coup_de_coeur"),
                chef_doeuvre=document.get("chef_doeuvre"),
                avis_details=document.get("avis_details"),
            )

        # Restaurer les timestamps
        instance.created_at = document.get("created_at", datetime.now())
        instance.updated_at = document.get("updated_at", datetime.now())

        return instance

    @classmethod
    def find_by_livre(
        cls: Type[T], livre_oid: ObjectId, sort_by_date: bool = True
    ) -> List[T]:
        """
        Trouve tous les épisodes où un livre a été discuté.

        Args:
            livre_oid (ObjectId): ObjectId du livre
            sort_by_date (bool): Trier par date décroissante (plus récent en premier)

        Returns:
            List[T]: Liste des épisodes-livres pour ce livre
        """
        DB_HOST, DB_NAME, _ = get_DB_VARS()
        collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection
        )

        query = {"livre_oid": livre_oid}
        cursor = collection.find(query)

        if sort_by_date:
            # Trier par date de l'épisode (plus récent en premier)
            cursor = cursor.sort("episode_date", -1)

        results = []
        for doc in cursor:
            instance = cls.from_oid(doc["_id"])
            if instance:
                results.append(instance)

        logger.info(f"Trouvé {len(results)} épisodes pour le livre {livre_oid}")
        return results

    @classmethod
    def find_by_auteur(
        cls: Type[T], auteur_oid: ObjectId, sort_by_date: bool = True
    ) -> List[T]:
        """
        Trouve tous les épisodes où un auteur a été discuté.

        Args:
            auteur_oid (ObjectId): ObjectId de l'auteur
            sort_by_date (bool): Trier par date décroissante

        Returns:
            List[T]: Liste des épisodes-livres pour cet auteur
        """
        DB_HOST, DB_NAME, _ = get_DB_VARS()
        collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection
        )

        query = {"auteur_oid": auteur_oid}
        cursor = collection.find(query)

        if sort_by_date:
            cursor = cursor.sort("episode_date", -1)

        results = []
        for doc in cursor:
            instance = cls.from_oid(doc["_id"])
            if instance:
                results.append(instance)

        logger.info(f"Trouvé {len(results)} épisodes pour l'auteur {auteur_oid}")
        return results

    @classmethod
    def find_by_episode(cls: Type[T], episode_oid: ObjectId) -> List[T]:
        """
        Trouve tous les livres discutés dans un épisode.

        Args:
            episode_oid (ObjectId): ObjectId de l'épisode

        Returns:
            List[T]: Liste des livres pour cet épisode
        """
        DB_HOST, DB_NAME, _ = get_DB_VARS()
        collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection
        )

        query = {"episode_oid": episode_oid}
        cursor = collection.find(query)

        results = []
        for doc in cursor:
            instance = cls.from_oid(doc["_id"])
            if instance:
                results.append(instance)

        logger.info(f"Trouvé {len(results)} livres pour l'épisode {episode_oid}")
        return results

    # %% mongo_episode_livre.ipynb 4
    @classmethod
    def extract_from_avis_summary(
        cls: Type[T],
        episode_oid: ObjectId,
        episode_title: str,
        episode_date: str,
        book_data: Dict[str, Any],
    ) -> T:
        """
        Crée une instance EpisodeLivre depuis des données d'avis critique parsées.

        Args:
            episode_oid (ObjectId): ObjectId de l'épisode
            episode_title (str): Titre de l'épisode
            episode_date (str): Date de l'épisode
            book_data (Dict): Données du livre depuis AvisCritiquesParser

        Returns:
            T: Instance EpisodeLivre créée
        """
        # Note: livre_oid et auteur_oid devront être résolus séparément
        # via les collections livres et auteurs

        instance = cls(
            episode_oid=episode_oid,
            livre_oid=None,  # À résoudre après
            auteur_oid=None,  # À résoudre après
        )

        # Ajouter métadonnées épisode
        instance.add_episode_metadata(episode_title, episode_date)

        # Ajouter métadonnées livre
        instance.add_book_metadata(
            livre_titre=book_data.get("titre", ""),
            auteur_nom=book_data.get("auteur", ""),
            editeur_nom=book_data.get("editeur", ""),
        )

        # Ajouter informations de notation
        instance.add_rating_info(
            note_moyenne=book_data.get("note_moyenne"),
            nb_critiques=book_data.get("nb_critiques"),
            coup_de_coeur=book_data.get("coup_de_coeur"),
            chef_doeuvre=book_data.get("chef_doeuvre"),
            avis_details=book_data.get("avis_details"),
        )

        return instance

    @classmethod
    def search_books_by_text(cls, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Recherche de livres/auteurs par texte pour l'autocomplétion.

        Args:
            query (str): Terme de recherche
            limit (int): Nombre maximum de résultats

        Returns:
            List[Dict]: Liste des livres correspondants avec métadonnées
        """
        DB_HOST, DB_NAME, _ = get_DB_VARS()
        collection = get_collection(
            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection
        )

        # Recherche textuelle dans auteur_nom et livre_titre
        query_regex = {"$regex": query, "$options": "i"}
        search_query = {
            "$or": [{"auteur_nom": query_regex}, {"livre_titre": query_regex}]
        }

        # Grouper par livre pour éviter les doublons
        pipeline = [
            {"$match": search_query},
            {
                "$group": {
                    "_id": {"livre_titre": "$livre_titre", "auteur_nom": "$auteur_nom"},
                    "livre_oid": {"$first": "$livre_oid"},
                    "auteur_oid": {"$first": "$auteur_oid"},
                    "editeur_nom": {"$first": "$editeur_nom"},
                    "nb_episodes": {"$sum": 1},
                    "note_moyenne_globale": {"$avg": "$note_moyenne"},
                    "dernier_episode": {"$max": "$episode_date"},
                }
            },
            {"$limit": limit},
            {
                "$project": {
                    "auteur_nom": "$_id.auteur_nom",
                    "livre_titre": "$_id.livre_titre",
                    "livre_oid": 1,
                    "auteur_oid": 1,
                    "editeur_nom": 1,
                    "nb_episodes": 1,
                    "note_moyenne_globale": 1,
                    "dernier_episode": 1,
                    "_id": 0,
                }
            },
        ]

        results = list(collection.aggregate(pipeline))
        logger.info(f"Recherche '{query}': trouvé {len(results)} livres")
        return results

    def __str__(self) -> str:
        """Représentation string de l'entité"""
        return f"""
        Episode: {self.episode_title} ({self.episode_date})
        Livre: {self.livre_titre} - {self.auteur_nom}
        Note: {self.note_moyenne} ({self.nb_critiques} critiques)
        """


# %% mongo_episode_livre.ipynb 5
def validate_episode_livre_collection():
    """
    Fonction utilitaire pour valider la cohérence de la collection episode_livres.

    Returns:
        Dict[str, Any]: Statistiques de validation
    """
    DB_HOST, DB_NAME, _ = get_DB_VARS()
    collection = get_collection(
        target_db=DB_HOST, client_name=DB_NAME, collection_name="episode_livres"
    )

    stats = {
        "total_documents": collection.count_documents({}),
        "documents_with_livre_oid": collection.count_documents(
            {"livre_oid": {"$ne": None}}
        ),
        "documents_with_auteur_oid": collection.count_documents(
            {"auteur_oid": {"$ne": None}}
        ),
        "documents_with_notes": collection.count_documents(
            {"note_moyenne": {"$ne": None}}
        ),
        "unique_episodes": len(collection.distinct("episode_oid")),
        "unique_livres": len(collection.distinct("livre_oid")),
        "unique_auteurs": len(collection.distinct("auteur_oid")),
        "validation_errors": [],
    }

    # Vérifications de cohérence
    invalid_notes = collection.count_documents({"note_moyenne": {"$lt": 0, "$gt": 10}})
    if invalid_notes > 0:
        stats["validation_errors"].append(
            f"{invalid_notes} documents avec notes invalides"
        )

    missing_titles = collection.count_documents(
        {
            "$or": [
                {"livre_titre": {"$in": [None, ""]}},
                {"auteur_nom": {"$in": [None, ""]}},
            ]
        }
    )
    if missing_titles > 0:
        stats["validation_errors"].append(
            f"{missing_titles} documents avec titres/auteurs manquants"
        )

    logger.info(f"Validation collection episode_livres: {stats}")
    return stats
