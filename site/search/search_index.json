{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"llm/","title":"Module llm","text":""},{"location":"llm/#llm.get_azure_llm","title":"<code>get_azure_llm(engine='gpt-4o')</code>","text":"<p>Get the Azure OpenAI language model.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>str</code> <p>The engine to use for the Azure OpenAI model. Default is \"gpt-4o\".</p> <code>'gpt-4o'</code> <p>Returns:</p> Name Type Description <code>AzureOpenAI</code> <code>AzureOpenAI</code> <p>An instance of the AzureOpenAI language model.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_azure_llm(engine=\"gpt-4o\") -&gt; AzureOpenAI:\n    \"\"\"\n    Get the Azure OpenAI language model.\n\n    Args:\n        engine (str): The engine to use for the Azure OpenAI model. Default is \"gpt-4o\".\n\n    Returns:\n        AzureOpenAI: An instance of the AzureOpenAI language model.\n    \"\"\"\n    AZURE_API_KEY, AZURE_ENDPOINT, AZURE_API_VERSION = get_azure_openai_keys()\n    llm = AzureOpenAI(\n        engine=engine,\n        api_key=AZURE_API_KEY,\n        azure_endpoint=AZURE_ENDPOINT,\n        api_version=AZURE_API_VERSION,\n    )\n    Settings.llm = llm\n    return llm\n</code></pre>"},{"location":"llm/#llm.get_azure_openai_keys","title":"<code>get_azure_openai_keys()</code>","text":"<p>Get the Azure OpenAI keys from environment variables.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[str, str, str]</code> <p>A tuple containing the Azure API key, endpoint, and API version.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_azure_openai_keys() -&gt; tuple[str, str, str]:\n    \"\"\"\n    Get the Azure OpenAI keys from environment variables.\n\n    Returns:\n        tuple: A tuple containing the Azure API key, endpoint, and API version.\n    \"\"\"\n    load_env()\n    azure_api_key = os.getenv(\"AZURE_API_KEY\")\n    azure_endpoint = os.getenv(\"AZURE_ENDPOINT\")\n    azure_api_version = os.getenv(\"AZURE_API_VERSION\")\n    return azure_api_key, azure_endpoint, azure_api_version\n</code></pre>"},{"location":"llm/#llm.get_gemini_api_key","title":"<code>get_gemini_api_key()</code>","text":"<p>Get the Gemini API key from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Gemini API key.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_gemini_api_key() -&gt; str:\n    \"\"\"\n    Get the Gemini API key from environment variables.\n\n    Returns:\n        str: The Gemini API key.\n    \"\"\"\n    load_env()\n    gemini_api_key = os.getenv(\"GEMINI_API_KEY\")\n    return gemini_api_key\n</code></pre>"},{"location":"llm/#llm.get_gemini_llamaindex_llm","title":"<code>get_gemini_llamaindex_llm(model='models/gemini-1.5-flash')</code>","text":"<p>Get the Gemini language model for LlamaIndex.</p> <p>This function configures the Gemini API using the API key obtained from the environment variables and returns an instance of the Gemini model for LlamaIndex.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use for the Gemini language model. Default is \"models/gemini-1.5-flash\".</p> <code>'models/gemini-1.5-flash'</code> <p>Returns:</p> Name Type Description <code>Gemini</code> <code>Gemini</code> <p>An instance of the Gemini language model.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_gemini_llamaindex_llm(model=\"models/gemini-1.5-flash\") -&gt; Gemini:\n    \"\"\"\n    Get the Gemini language model for LlamaIndex.\n\n    This function configures the Gemini API using the API key obtained from the environment variables\n    and returns an instance of the Gemini model for LlamaIndex.\n\n    Args:\n        model (str): The model to use for the Gemini language model. Default is \"models/gemini-1.5-flash\".\n\n    Returns:\n        Gemini: An instance of the Gemini language model.\n    \"\"\"\n    genai.configure(api_key=get_gemini_api_key())\n    llm = Gemini(model=model, api_key=get_gemini_api_key())\n    Settings.llm = llm\n    return llm\n</code></pre>"},{"location":"llm/#llm.get_gemini_llm","title":"<code>get_gemini_llm(model='gemini-1.5-flash')</code>","text":"<p>Get the Gemini language model.</p> <p>This function configures the Gemini API using the API key obtained from the environment variables and returns an instance of the GenerativeModel.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use for the Gemini language model. Default is \"gemini-1.5-flash\".</p> <code>'gemini-1.5-flash'</code> <p>Returns:</p> Name Type Description <code>GenerativeModel</code> <code>GenerativeModel</code> <p>An instance of the GenerativeModel.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_gemini_llm(model=\"gemini-1.5-flash\") -&gt; genai.GenerativeModel:\n    \"\"\"\n    Get the Gemini language model.\n\n    This function configures the Gemini API using the API key obtained from the environment variables\n    and returns an instance of the GenerativeModel.\n\n    Args:\n        model (str): The model to use for the Gemini language model. Default is \"gemini-1.5-flash\".\n\n    Returns:\n        GenerativeModel: An instance of the GenerativeModel.\n    \"\"\"\n    genai.configure(api_key=get_gemini_api_key())\n    llm = genai.GenerativeModel(model)\n    return llm\n</code></pre>"},{"location":"llm/#llm.get_google_auth_file","title":"<code>get_google_auth_file()</code>","text":"<p>Get the Google authentication file path from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the Google authentication file.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_google_auth_file() -&gt; str:\n    \"\"\"\n    Get the Google authentication file path from environment variables.\n\n    Returns:\n        str: The path to the Google authentication file.\n    \"\"\"\n    load_env()\n    google_auth_file = os.getenv(\"GOOGLE_AUTH_FILE\")\n    return google_auth_file\n</code></pre>"},{"location":"llm/#llm.get_google_projectID","title":"<code>get_google_projectID()</code>","text":"<p>Get the Google Project ID from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Google Project ID.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_google_projectID() -&gt; str:\n    \"\"\"\n    Get the Google Project ID from environment variables.\n\n    Returns:\n        str: The Google Project ID.\n    \"\"\"\n    load_env()\n    google_projectID = os.getenv(\"GOOGLE_PROJECT_ID\")\n    return google_projectID\n</code></pre>"},{"location":"llm/#llm.get_openai_api_key","title":"<code>get_openai_api_key()</code>","text":"<p>Get the OpenAI API key from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The OpenAI API key.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_openai_api_key() -&gt; str:\n    \"\"\"\n    Get the OpenAI API key from environment variables.\n\n    Returns:\n        str: The OpenAI API key.\n    \"\"\"\n    load_env()\n    openai_api_key = os.getenv(\"OPENAI_API_KEY\")\n    return openai_api_key\n</code></pre>"},{"location":"llm/#llm.get_vertex_llm","title":"<code>get_vertex_llm(model='gemini-1.5-flash-001')</code>","text":"<p>Get the Vertex language model.</p> <p>This function configures the Vertex API using the project ID and API key obtained from the environment variables and returns an instance of the Vertex model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use for the Vertex language model. Default is \"gemini-1.5-flash-001\".</p> <code>'gemini-1.5-flash-001'</code> <p>Returns:</p> Name Type Description <code>Vertex</code> <code>Vertex</code> <p>An instance of the Vertex language model.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_vertex_llm(model=\"gemini-1.5-flash-001\") -&gt; Vertex:\n    \"\"\"\n    Get the Vertex language model.\n\n    This function configures the Vertex API using the project ID and API key obtained from the environment variables\n    and returns an instance of the Vertex model.\n\n    Args:\n        model (str): The model to use for the Vertex language model. Default is \"gemini-1.5-flash-001\".\n\n    Returns:\n        Vertex: An instance of the Vertex language model.\n    \"\"\"\n    # Set up necessary variables\n    credentials = {\n        \"project_id\": get_google_projectID(),\n        \"api_key\": get_gemini_api_key(),\n    }\n\n    # filename = get_google_auth_file()\n    # credentials_service: service_account.Credentials = (\n    #     service_account.Credentials.from_service_account_file(filename)\n    # )\n\n    # Create an instance of the Vertex class\n    llm = Vertex(\n        model=model,\n        project=credentials[\"project_id\"],\n        credentials=credentials,\n        context_window=100000,\n    )\n    # llm = Vertex(\n    #     model=model,\n    #     project=credentials_service.project_id,\n    #     credentials=credentials_service,\n    #     context_window=100000,    )\n    Settings.llm = llm\n    return llm\n</code></pre>"},{"location":"llm/#llm.load_env","title":"<code>load_env()</code>","text":"<p>Load environment variables from a .env file.</p> <p>This function uses <code>dotenv</code> to find and load environment variables from a .env file into the environment.</p> Source code in <code>nbs/llm.py</code> <pre><code>def load_env():\n    \"\"\"\n    Load environment variables from a .env file.\n\n    This function uses `dotenv` to find and load environment variables\n    from a .env file into the environment.\n    \"\"\"\n    _ = load_dotenv(find_dotenv())\n</code></pre>"},{"location":"mongo/","title":"Module mongo","text":""},{"location":"mongo/#mongo.BaseEntity","title":"<code>BaseEntity</code>","text":"Source code in <code>nbs/mongo.py</code> <pre><code>class BaseEntity:\n    def __init__(self, nom: str, collection_name: str) -&gt; None:\n        \"\"\"Initializes a new BaseEntity instance.\n\n        Args:\n            nom (str): The name of the entity.\n            collection_name (str): The name of the collection.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        self.nom = nom\n\n    def exists(self) -&gt; bool:\n        \"\"\"Checks if the entity exists in the database.\n\n        Returns:\n            bool: True if the entity exists, False otherwise.\n        \"\"\"\n        return self.collection.find_one({\"nom\": self.nom}) is not None\n\n    def keep(self) -&gt; None:\n        \"\"\"Inserts or updates the entity in the database.\n\n        If the entity does not exist, it is inserted; otherwise, it is updated.\n        \"\"\"\n        if not self.exists():\n            mongolog(\"insert\", self.collection.name, self.nom)\n            self.collection.insert_one({\"nom\": self.nom})\n        else:\n            mongolog(\"update\", self.collection.name, self.nom)\n\n    def remove(self) -&gt; None:\n        \"\"\"Removes the entity from the database.\"\"\"\n        self.collection.delete_one({\"nom\": self.nom})\n        mongolog(\"delete\", self.collection.name, self.nom)\n\n    def get_oid(self) -&gt; Optional[ObjectId]:\n        \"\"\"Retrieves the ObjectId of the entity from the database.\n\n        Returns:\n            Optional[ObjectId]: The ObjectId of the entity if found, otherwise None.\n        \"\"\"\n        document = self.collection.find_one({\"nom\": self.nom})\n        if document:\n            return document[\"_id\"]\n        else:\n            return None\n\n    @classmethod\n    def from_oid(cls: Type[T], oid: ObjectId) -&gt; T:\n        \"\"\"Creates an instance of the derived class from a MongoDB ObjectId.\n\n        Args:\n            oid (ObjectId): The MongoDB ObjectId.\n\n        Returns:\n            T: An instance of the derived class.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n        )\n        document = collection.find_one({\"_id\": oid})\n        inst = cls(nom=document.get(\"nom\"))\n        return inst\n\n    @classmethod\n    def get_entries(cls: Type[T], request: str = \"\") -&gt; List[T]:\n        \"\"\"Retrieves a list of entries matching the query.\n\n        Args:\n            request (str, optional): A substring of the name to filter results\n                (case-insensitive). Defaults to an empty string.\n\n        Returns:\n            List[T]: A list of instances of the derived class.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n        )\n        query = {\n            \"nom\": {\n                \"$regex\": request,\n                \"$options\": \"i\",\n            }\n        }\n        result = collection.find(query)\n        list_baseentity = [cls.from_oid(entry.get(\"_id\")) for entry in result]\n        return list_baseentity\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Official string representation of the entity.\n\n        Returns:\n            str: The name of the entity.\n        \"\"\"\n        return self.nom\n\n    def __str__(self) -&gt; str:\n        \"\"\"Informal string representation of the entity.\n\n        Returns:\n            str: The name of the entity.\n        \"\"\"\n        return self.nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.__init__","title":"<code>__init__(nom, collection_name)</code>","text":"<p>Initializes a new BaseEntity instance.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>The name of the entity.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def __init__(self, nom: str, collection_name: str) -&gt; None:\n    \"\"\"Initializes a new BaseEntity instance.\n\n    Args:\n        nom (str): The name of the entity.\n        collection_name (str): The name of the collection.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    self.nom = nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.__repr__","title":"<code>__repr__()</code>","text":"<p>Official string representation of the entity.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the entity.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Official string representation of the entity.\n\n    Returns:\n        str: The name of the entity.\n    \"\"\"\n    return self.nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.__str__","title":"<code>__str__()</code>","text":"<p>Informal string representation of the entity.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the entity.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Informal string representation of the entity.\n\n    Returns:\n        str: The name of the entity.\n    \"\"\"\n    return self.nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.exists","title":"<code>exists()</code>","text":"<p>Checks if the entity exists in the database.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the entity exists, False otherwise.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Checks if the entity exists in the database.\n\n    Returns:\n        bool: True if the entity exists, False otherwise.\n    \"\"\"\n    return self.collection.find_one({\"nom\": self.nom}) is not None\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.from_oid","title":"<code>from_oid(oid)</code>  <code>classmethod</code>","text":"<p>Creates an instance of the derived class from a MongoDB ObjectId.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>ObjectId</code> <p>The MongoDB ObjectId.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the derived class.</p> Source code in <code>nbs/mongo.py</code> <pre><code>@classmethod\ndef from_oid(cls: Type[T], oid: ObjectId) -&gt; T:\n    \"\"\"Creates an instance of the derived class from a MongoDB ObjectId.\n\n    Args:\n        oid (ObjectId): The MongoDB ObjectId.\n\n    Returns:\n        T: An instance of the derived class.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n    )\n    document = collection.find_one({\"_id\": oid})\n    inst = cls(nom=document.get(\"nom\"))\n    return inst\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.get_entries","title":"<code>get_entries(request='')</code>  <code>classmethod</code>","text":"<p>Retrieves a list of entries matching the query.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>str</code> <p>A substring of the name to filter results (case-insensitive). Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>List[T]: A list of instances of the derived class.</p> Source code in <code>nbs/mongo.py</code> <pre><code>@classmethod\ndef get_entries(cls: Type[T], request: str = \"\") -&gt; List[T]:\n    \"\"\"Retrieves a list of entries matching the query.\n\n    Args:\n        request (str, optional): A substring of the name to filter results\n            (case-insensitive). Defaults to an empty string.\n\n    Returns:\n        List[T]: A list of instances of the derived class.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n    )\n    query = {\n        \"nom\": {\n            \"$regex\": request,\n            \"$options\": \"i\",\n        }\n    }\n    result = collection.find(query)\n    list_baseentity = [cls.from_oid(entry.get(\"_id\")) for entry in result]\n    return list_baseentity\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.get_oid","title":"<code>get_oid()</code>","text":"<p>Retrieves the ObjectId of the entity from the database.</p> <p>Returns:</p> Type Description <code>Optional[ObjectId]</code> <p>Optional[ObjectId]: The ObjectId of the entity if found, otherwise None.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def get_oid(self) -&gt; Optional[ObjectId]:\n    \"\"\"Retrieves the ObjectId of the entity from the database.\n\n    Returns:\n        Optional[ObjectId]: The ObjectId of the entity if found, otherwise None.\n    \"\"\"\n    document = self.collection.find_one({\"nom\": self.nom})\n    if document:\n        return document[\"_id\"]\n    else:\n        return None\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.keep","title":"<code>keep()</code>","text":"<p>Inserts or updates the entity in the database.</p> <p>If the entity does not exist, it is inserted; otherwise, it is updated.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def keep(self) -&gt; None:\n    \"\"\"Inserts or updates the entity in the database.\n\n    If the entity does not exist, it is inserted; otherwise, it is updated.\n    \"\"\"\n    if not self.exists():\n        mongolog(\"insert\", self.collection.name, self.nom)\n        self.collection.insert_one({\"nom\": self.nom})\n    else:\n        mongolog(\"update\", self.collection.name, self.nom)\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.remove","title":"<code>remove()</code>","text":"<p>Removes the entity from the database.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Removes the entity from the database.\"\"\"\n    self.collection.delete_one({\"nom\": self.nom})\n    mongolog(\"delete\", self.collection.name, self.nom)\n</code></pre>"},{"location":"mongo/#mongo.Critique","title":"<code>Critique</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Class representing a review (Critique) entity stored in the 'critiques' MongoDB collection.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>str</code> <p>MongoDB collection name used to store critiques.</p> Source code in <code>nbs/mongo.py</code> <pre><code>class Critique(BaseEntity):\n    \"\"\"\n    Class representing a review (Critique) entity stored in the 'critiques' MongoDB collection.\n\n    Attributes:\n        collection (str): MongoDB collection name used to store critiques.\n    \"\"\"\n\n    collection: str = \"critiques\"\n\n    def __init__(self, nom: str) -&gt; None:\n        \"\"\"\n        Initializes a Critique instance.\n\n        Args:\n            nom (str): Name of the critique.\n        \"\"\"\n        super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.Critique.__init__","title":"<code>__init__(nom)</code>","text":"<p>Initializes a Critique instance.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>Name of the critique.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def __init__(self, nom: str) -&gt; None:\n    \"\"\"\n    Initializes a Critique instance.\n\n    Args:\n        nom (str): Name of the critique.\n    \"\"\"\n    super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.Editeur","title":"<code>Editeur</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Represents a publisher stored in the 'editeurs' MongoDB collection.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>str</code> <p>The name of the MongoDB collection.</p> Source code in <code>nbs/mongo.py</code> <pre><code>class Editeur(BaseEntity):\n    \"\"\"\n    Represents a publisher stored in the 'editeurs' MongoDB collection.\n\n    Attributes:\n        collection (str): The name of the MongoDB collection.\n    \"\"\"\n\n    collection: str = \"editeurs\"\n\n    def __init__(self, nom: str) -&gt; None:\n        \"\"\"\n        Initialize an Editeur instance.\n\n        Args:\n            nom (str): The name of the publisher.\n        \"\"\"\n        super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.Editeur.__init__","title":"<code>__init__(nom)</code>","text":"<p>Initialize an Editeur instance.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>The name of the publisher.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def __init__(self, nom: str) -&gt; None:\n    \"\"\"\n    Initialize an Editeur instance.\n\n    Args:\n        nom (str): The name of the publisher.\n    \"\"\"\n    super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.get_DB_VARS","title":"<code>get_DB_VARS()</code>","text":"<p>Retrieve the database configuration variables from the environment.</p> <p>This function loads the environment variables and retrieves the following database configuration variables:     - DB_HOST: The hostname for the database.     - DB_NAME: The name of the database.     - DB_LOGS: A flag indicating if logging is enabled.</p> <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str], Optional[str]]</code> <p>Tuple[Optional[str], Optional[str], Optional[str]]: A tuple containing (DB_HOST, DB_NAME, DB_LOGS).</p> Source code in <code>nbs/mongo.py</code> <pre><code>def get_DB_VARS() -&gt; Tuple[Optional[str], Optional[str], Optional[str]]:\n    \"\"\"Retrieve the database configuration variables from the environment.\n\n    This function loads the environment variables and retrieves the following\n    database configuration variables:\n        - DB_HOST: The hostname for the database.\n        - DB_NAME: The name of the database.\n        - DB_LOGS: A flag indicating if logging is enabled.\n\n    Returns:\n        Tuple[Optional[str], Optional[str], Optional[str]]:\n            A tuple containing (DB_HOST, DB_NAME, DB_LOGS).\n    \"\"\"\n    load_env()\n    DB_HOST: Optional[str] = os.getenv(\"DB_HOST\")\n    DB_NAME: Optional[str] = os.getenv(\"DB_NAME\")\n    DB_LOGS: Optional[str] = os.getenv(\"DB_LOGS\")\n    return DB_HOST, DB_NAME, DB_LOGS\n</code></pre>"},{"location":"mongo/#mongo.get_collection","title":"<code>get_collection(target_db='localhost', client_name='masque_et_la_plume', collection_name='episodes')</code>","text":"<p>Retrieve a MongoDB collection.</p> <p>This function connects to a MongoDB database using the provided database host, client name (database name), and collection name, and returns the collection object.</p> <p>Parameters:</p> Name Type Description Default <code>target_db</code> <code>str</code> <p>The database host address (e.g., \"localhost\" or \"nas923\").</p> <code>'localhost'</code> <code>client_name</code> <code>str</code> <p>The name of the MongoDB client/database.</p> <code>'masque_et_la_plume'</code> <code>collection_name</code> <code>str</code> <p>The name of the collection to retrieve.</p> <code>'episodes'</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The MongoDB collection object.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def get_collection(\n    target_db: str = \"localhost\",\n    client_name: str = \"masque_et_la_plume\",\n    collection_name: str = \"episodes\",\n) -&gt; Collection:\n    \"\"\"Retrieve a MongoDB collection.\n\n    This function connects to a MongoDB database using the provided database host,\n    client name (database name), and collection name, and returns the collection object.\n\n    Args:\n        target_db (str): The database host address (e.g., \"localhost\" or \"nas923\").\n        client_name (str): The name of the MongoDB client/database.\n        collection_name (str): The name of the collection to retrieve.\n\n    Returns:\n        Collection: The MongoDB collection object.\n    \"\"\"\n    client = pymongo.MongoClient(f\"mongodb://{target_db}:27017/\")\n    db = client[client_name]\n    collection = db[collection_name]\n    return collection\n</code></pre>"},{"location":"mongo/#mongo.load_env","title":"<code>load_env()</code>","text":"<p>Load environment variables from a .env file.</p> <p>This function searches for a .env file in the project directory and loads its variables into the environment.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def load_env() -&gt; None:\n    \"\"\"Load environment variables from a .env file.\n\n    This function searches for a .env file in the project directory and loads its\n    variables into the environment.\n    \"\"\"\n    _ = load_dotenv(find_dotenv())\n</code></pre>"},{"location":"mongo/#mongo.mongolog","title":"<code>mongolog(operation, entite, desc)</code>","text":"<p>Enregistre une op\u00e9ration de log dans la collection 'logs' si la configuration autorise les logs.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>L'op\u00e9ration effectu\u00e9e (par exemple, \"insert\", \"update\", \"delete\").</p> required <code>entite</code> <code>str</code> <p>Le nom de l'entit\u00e9 concern\u00e9e.</p> required <code>desc</code> <code>str</code> <p>Une description d\u00e9taill\u00e9e de l'op\u00e9ration.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def mongolog(operation: str, entite: str, desc: str) -&gt; None:\n    \"\"\"Enregistre une op\u00e9ration de log dans la collection 'logs' si la configuration autorise les logs.\n\n    Args:\n        operation (str): L'op\u00e9ration effectu\u00e9e (par exemple, \"insert\", \"update\", \"delete\").\n        entite (str): Le nom de l'entit\u00e9 concern\u00e9e.\n        desc (str): Une description d\u00e9taill\u00e9e de l'op\u00e9ration.\n    \"\"\"\n    DB_HOST, DB_NAME, DB_LOGS = get_DB_VARS()\n    if DB_LOGS in [\"true\", \"True\"]:\n        coll_logs = get_collection(DB_HOST, DB_NAME, \"logs\")\n        coll_logs.insert_one(\n            {\n                \"operation\": operation,\n                \"entite\": entite,\n                \"desc\": desc,\n                \"date\": datetime.now(),\n            }\n        )\n</code></pre>"},{"location":"mongo/#mongo.print_logs","title":"<code>print_logs(n=10)</code>","text":"<p>Affiche les n derniers logs de la collection 'logs', tri\u00e9s par date d\u00e9croissante.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Le nombre maximum de logs \u00e0 afficher. Par d\u00e9faut \u00e0 10.</p> <code>10</code> Source code in <code>nbs/mongo.py</code> <pre><code>def print_logs(n: int = 10) -&gt; None:\n    \"\"\"Affiche les n derniers logs de la collection 'logs', tri\u00e9s par date d\u00e9croissante.\n\n    Args:\n        n (int, optional): Le nombre maximum de logs \u00e0 afficher. Par d\u00e9faut \u00e0 10.\n    \"\"\"\n    DB_HOST, DB_NAME, DB_LOGS = get_DB_VARS()\n    coll_logs = get_collection(DB_HOST, DB_NAME, \"logs\")\n    for i, log in enumerate(coll_logs.find().sort(\"date\", pymongo.DESCENDING)):\n        if i == n:\n            break\n        print(log)\n</code></pre>"},{"location":"mongo_auteur/","title":"Module mongo_auteur","text":""},{"location":"mongo_auteur/#mongo_auteur.Auteur","title":"<code>Auteur</code>","text":"<p>               Bases: <code>BaseEntity</code></p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>class Auteur(BaseEntity):\n    collection: str = \"auteurs\"\n\n    def __init__(self, nom: str) -&gt; None:\n        \"\"\"Initialise une instance d'Auteur.\n\n        Args:\n            nom (str): Le nom de l'auteur.\n        \"\"\"\n        super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.Auteur.__init__","title":"<code>__init__(nom)</code>","text":"<p>Initialise une instance d'Auteur.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>Le nom de l'auteur.</p> required Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def __init__(self, nom: str) -&gt; None:\n    \"\"\"Initialise une instance d'Auteur.\n\n    Args:\n        nom (str): Le nom de l'auteur.\n    \"\"\"\n    super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker","title":"<code>AuthorChecker</code>","text":"<p>Class to verify and correct an author's name using multiple data sources.</p> This class verifies an author in an episode through sources including <ul> <li>RSS metadata (title, description)</li> <li>MongoDB database of known authors</li> <li>LLM suggestions</li> <li>Web search analysis</li> </ul> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>class AuthorChecker:\n    \"\"\"Class to verify and correct an author's name using multiple data sources.\n\n    This class verifies an author in an episode through sources including:\n      - RSS metadata (title, description)\n      - MongoDB database of known authors\n      - LLM suggestions\n      - Web search analysis\n    \"\"\"\n\n    def __init__(self, episode: Episode) -&gt; None:\n        \"\"\"Initializes the AuthorChecker with an episode.\n\n        Args:\n            episode (Episode): An episode instance containing title and description.\n        \"\"\"\n        self.episode = episode\n        self.llm_structured_output = get_azure_llm(\"gpt-4o\")\n        self.authors_titre_description = self._get_authors_from_titre_description()\n\n    def _get_authors_from_titre_description(self) -&gt; List[str]:\n        \"\"\"Retrieves a list of author names extracted from the episode title and description using LLM.\n\n        Returns:\n            List[str]: A list of author names extracted from the title and description.\n        \"\"\"\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorTitreDescriptionList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors_TitreDescription\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"A list of names from title and description\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors_TitreDescription\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n        response = self.llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un assistant utile qui retourne une liste JSON de noms.\",\n                ),\n                ChatMessage(\n                    role=\"user\",\n                    content=f\"Est-ce que tu peux me lister tous les noms qui sont cit\u00e9s dans le titre et la description de l'\u00e9pisode suivant : {self.episode.titre} {self.episode.description}. \",\n                ),\n            ],\n            response_format=response_schema,\n        )\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []  # Return an empty list if parsing fails\n        return json_dict[\"Authors_TitreDescription\"]\n\n    def _get_authors_from_llm(self, autor: str) -&gt; List[str]:\n        \"\"\"Queries the LLM to retrieve a list of potential author names based on a provided name.\n\n        Args:\n            autor (str): The author name to query.\n\n        Returns:\n            List[str]: A list of author names suggested by the LLM.\n        \"\"\"\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors_LLM\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"A list of authors' names\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors_LLM\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n\n        prompt = (\n            \"\"\"\n        Tu es un agent expert en litt\u00e9rature.\n        Donne moi quelques auteurs dont le nom s'approche de celui-ci : \"\"\"\n            + autor\n            + \"\"\"\n\n        S'il s'agit deja d'un auteur connu, retourne moi juste son nom. S'il y a une erreur dans le nom que je t'ai donne, corrige moi en me donnant le nom de l'auteur que tu penses que j'ai voulu dire.\n\n        Je veux que tu me donnes le prenom puis le nom dans cet ordre. Par exemple \"Marcel Pagnol\" ou \"Victor Hugo\".\n        Ces auteurs sont susceptibles d'etre discutes dans \"Le Masque et la Plume\".\n\n        Si tu me retournes plusieurs auteurs, fais le sous forme de liste par exemple si tu as identifie \"auteur 1\" et \"auteur 2\" alors retourne [\"auteur 1\", \"auteur 2\"]\n        \"\"\"\n        )\n\n        response = self.llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un agent litteraire qui connait parfaitement les auteurs.\",\n                ),\n                ChatMessage(role=\"user\", content=f\"{prompt}. \"),\n            ],\n            response_format=response_schema,\n        )\n\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []\n        return json_dict[\"Authors_LLM\"]\n\n    def _get_author_from_web(self, author: str) -&gt; Dict[str, Union[str, int]]:\n        \"\"\"Analyzes a Google search result to verify if a given name corresponds to an author.\n\n        Args:\n            author (str): The author name to verify.\n\n        Returns:\n            Dict[str, Union[str, int]]: A dictionary containing:\n                - \"auteur\": The corrected author name if applicable.\n                - \"certitude\": An integer between 0 and 100 indicating the confidence.\n                - \"analyse\": A textual analysis of the Google search query.\n        \"\"\"\n        result_google = google_search(author)\n\n        prompt_incertitude_auteur = f\"\"\"\n        Voici le resultat d'une requete google concernant un probable auteur inconnu de mon llm : {author}\n        La requete est au format dict avec du json a l'interieur.\n        Est-ce que tu peux analyser le contenu de cette requete et me dire si oui ou non {author} est un auteur de livres, \n        et accompagner ta reponse d'un pourcentage de certitude :\n        * 100% de certitude signifie que tu es certain que {author} est un auteur de livres\n        *  50% tu es ni sure ni pas sure que {author} est un auteur de livres\n        *   0% tu es certain que {author} n'est pas un auteur de livres\n\n        Voici le contenu de la requete google : {result_google}\n\n        Tu repondras uniquement avec un dictionnaire qui va contenir 3 entrees :\n\n        - \"auteur\" : le nom de l'auteur, eventuellement corrige si j'ai oublie des accents ou une faute de frappe\n        - \"certitude\" : le pourcentage de certitude de 0 \u00e0 100, un entier\n        - \"analyse\" : une analyse de la requete Google concernant l'auteur.\n        \"\"\"\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuteurSchema\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"auteur\": {\n                            \"type\": \"string\",\n                            \"description\": \"Le nom de l'auteur \u00e9ventuellement corrig\u00e9 (accents, fautes de frappe).\",\n                        },\n                        \"certitude\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pourcentage de certitude (0 \u00e0 100).\",\n                            \"minimum\": 0,\n                            \"maximum\": 100,\n                        },\n                        \"analyse\": {\n                            \"type\": \"string\",\n                            \"description\": \"Analyse de la requ\u00eate Google concernant l'auteur.\",\n                        },\n                    },\n                    \"required\": [\"auteur\", \"certitude\", \"analyse\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n\n        response = self.llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un assistant utile qui analyse des requetes Google pour y deceler si un auteur de livre s'y cache.\",\n                ),\n                ChatMessage(\n                    role=\"user\",\n                    content=prompt_incertitude_auteur,\n                ),\n            ],\n            response_format=response_schema,\n        )\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return {}\n        return json_dict\n\n    def _check_author_source(\n        self, author: str, authors_list: List[str]\n    ) -&gt; Optional[str]:\n        \"\"\"Determines the best matching author from a provided list using fuzzy matching.\n\n        Args:\n            author (str): The author name to match.\n            authors_list (List[str]): A list of author names to check against.\n\n        Returns:\n            Optional[str]: The best matching author name if the match score is above the threshold, otherwise None.\n        \"\"\"\n        matcher = AuthorFuzzMatcher(authors_list)\n        best_match, score = matcher.find_best_match(author)\n        if score &gt;= score_fuzz_threshold:\n            return best_match\n        else:\n            return None\n\n    def check_author(\n        self, author: str, return_details: bool = False, verbose: bool = False\n    ) -&gt; Union[str, Dict[str, Union[str, int]], None]:\n        \"\"\"Verifies an author's name through various sources and returns the corrected name.\n\n        It checks in the following order:\n          1. RSS metadata (title, description)\n          2. MongoDB list of known authors\n          3. LLM suggested names\n          4. Web search analysis\n\n        Args:\n            author (str): The author name to verify.\n            return_details (bool, optional): If True, returns a detailed dictionary with source and analysis. Defaults to False.\n            verbose (bool, optional): If True, prints debug messages. Defaults to False.\n\n        Returns:\n            Union[str, Dict[str, Union[str, int]], None]: The corrected author name as a string if return_details is False;\n                a detailed dict if return_details is True; or None if no match is found.\n        \"\"\"\n        details = {\"author_original\": author, \"author_corrected\": None, \"source\": None}\n\n        # 1. V\u00e9rification dans rss:metadata (titre, description)\n        match = self._check_author_source(author, self.authors_titre_description)\n        if match:\n            details[\"author_corrected\"] = match\n            details[\"source\"] = \"rss:metadata\"\n            if verbose:\n                print(f\"Trouv\u00e9 avec rss:metadata: {match}\")\n            return details if return_details else match\n\n        # 2. V\u00e9rification dans la base de donn\u00e9es (mongodb:auteurs)\n        list_db_auteurs = [auteur.nom for auteur in Auteur.get_entries()]\n        match = self._check_author_source(author, list_db_auteurs)\n        if match:\n            details[\"author_corrected\"] = match\n            details[\"source\"] = \"mongodb:auteurs\"\n            if verbose:\n                print(f\"Trouv\u00e9 avec mongodb:auteurs: {match}\")\n            return details if return_details else match\n\n        # 3. V\u00e9rification via llm\n        list_llm_auteurs = self._get_authors_from_llm(author)\n        match = self._check_author_source(author, list_llm_auteurs)\n        if match:\n            details[\"author_corrected\"] = match\n            details[\"source\"] = \"llm\"\n            if verbose:\n                print(f\"Trouv\u00e9 avec llm: {match}\")\n            return details if return_details else match\n\n        # 4. V\u00e9rification via web search\n        web_result_dict = self._get_author_from_web(author)\n        match = web_result_dict.get(\"auteur\")\n        score = web_result_dict.get(\"certitude\", 0)\n        details.update(\n            {\n                \"author_corrected\": match,\n                \"score\": score,\n                \"analyse\": web_result_dict.get(\"analyse\", \"\"),\n                \"source\": \"web search\",\n            }\n        )\n        if score &gt;= score_fuzz_threshold:\n            if verbose:\n                print(f\"Trouv\u00e9 avec web search: {match}\")\n            return details if return_details else match\n        else:\n            if verbose:\n                print(\n                    f\"Score insuffisant {score} avec web search: {web_result_dict.get('analyse', '')}\"\n                )\n            details[\"author_corrected\"] = None\n            return details if return_details else None\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker.__init__","title":"<code>__init__(episode)</code>","text":"<p>Initializes the AuthorChecker with an episode.</p> <p>Parameters:</p> Name Type Description Default <code>episode</code> <code>Episode</code> <p>An episode instance containing title and description.</p> required Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def __init__(self, episode: Episode) -&gt; None:\n    \"\"\"Initializes the AuthorChecker with an episode.\n\n    Args:\n        episode (Episode): An episode instance containing title and description.\n    \"\"\"\n    self.episode = episode\n    self.llm_structured_output = get_azure_llm(\"gpt-4o\")\n    self.authors_titre_description = self._get_authors_from_titre_description()\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker._check_author_source","title":"<code>_check_author_source(author, authors_list)</code>","text":"<p>Determines the best matching author from a provided list using fuzzy matching.</p> <p>Parameters:</p> Name Type Description Default <code>author</code> <code>str</code> <p>The author name to match.</p> required <code>authors_list</code> <code>List[str]</code> <p>A list of author names to check against.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The best matching author name if the match score is above the threshold, otherwise None.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def _check_author_source(\n    self, author: str, authors_list: List[str]\n) -&gt; Optional[str]:\n    \"\"\"Determines the best matching author from a provided list using fuzzy matching.\n\n    Args:\n        author (str): The author name to match.\n        authors_list (List[str]): A list of author names to check against.\n\n    Returns:\n        Optional[str]: The best matching author name if the match score is above the threshold, otherwise None.\n    \"\"\"\n    matcher = AuthorFuzzMatcher(authors_list)\n    best_match, score = matcher.find_best_match(author)\n    if score &gt;= score_fuzz_threshold:\n        return best_match\n    else:\n        return None\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker._get_author_from_web","title":"<code>_get_author_from_web(author)</code>","text":"<p>Analyzes a Google search result to verify if a given name corresponds to an author.</p> <p>Parameters:</p> Name Type Description Default <code>author</code> <code>str</code> <p>The author name to verify.</p> required <p>Returns:</p> Type Description <code>Dict[str, Union[str, int]]</code> <p>Dict[str, Union[str, int]]: A dictionary containing: - \"auteur\": The corrected author name if applicable. - \"certitude\": An integer between 0 and 100 indicating the confidence. - \"analyse\": A textual analysis of the Google search query.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def _get_author_from_web(self, author: str) -&gt; Dict[str, Union[str, int]]:\n    \"\"\"Analyzes a Google search result to verify if a given name corresponds to an author.\n\n    Args:\n        author (str): The author name to verify.\n\n    Returns:\n        Dict[str, Union[str, int]]: A dictionary containing:\n            - \"auteur\": The corrected author name if applicable.\n            - \"certitude\": An integer between 0 and 100 indicating the confidence.\n            - \"analyse\": A textual analysis of the Google search query.\n    \"\"\"\n    result_google = google_search(author)\n\n    prompt_incertitude_auteur = f\"\"\"\n    Voici le resultat d'une requete google concernant un probable auteur inconnu de mon llm : {author}\n    La requete est au format dict avec du json a l'interieur.\n    Est-ce que tu peux analyser le contenu de cette requete et me dire si oui ou non {author} est un auteur de livres, \n    et accompagner ta reponse d'un pourcentage de certitude :\n    * 100% de certitude signifie que tu es certain que {author} est un auteur de livres\n    *  50% tu es ni sure ni pas sure que {author} est un auteur de livres\n    *   0% tu es certain que {author} n'est pas un auteur de livres\n\n    Voici le contenu de la requete google : {result_google}\n\n    Tu repondras uniquement avec un dictionnaire qui va contenir 3 entrees :\n\n    - \"auteur\" : le nom de l'auteur, eventuellement corrige si j'ai oublie des accents ou une faute de frappe\n    - \"certitude\" : le pourcentage de certitude de 0 \u00e0 100, un entier\n    - \"analyse\" : une analyse de la requete Google concernant l'auteur.\n    \"\"\"\n    response_schema = {\n        \"type\": \"json_schema\",\n        \"json_schema\": {\n            \"name\": \"AuteurSchema\",\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"auteur\": {\n                        \"type\": \"string\",\n                        \"description\": \"Le nom de l'auteur \u00e9ventuellement corrig\u00e9 (accents, fautes de frappe).\",\n                    },\n                    \"certitude\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Pourcentage de certitude (0 \u00e0 100).\",\n                        \"minimum\": 0,\n                        \"maximum\": 100,\n                    },\n                    \"analyse\": {\n                        \"type\": \"string\",\n                        \"description\": \"Analyse de la requ\u00eate Google concernant l'auteur.\",\n                    },\n                },\n                \"required\": [\"auteur\", \"certitude\", \"analyse\"],\n                \"additionalProperties\": False,\n            },\n        },\n    }\n\n    response = self.llm_structured_output.chat(\n        messages=[\n            ChatMessage(\n                role=\"system\",\n                content=\"Tu es un assistant utile qui analyse des requetes Google pour y deceler si un auteur de livre s'y cache.\",\n            ),\n            ChatMessage(\n                role=\"user\",\n                content=prompt_incertitude_auteur,\n            ),\n        ],\n        response_format=response_schema,\n    )\n    try:\n        json_dict = json.loads(response.message.content)\n    except json.JSONDecodeError as e:\n        print(\"Error parsing JSON:\", e)\n        print(\"Raw response:\", response.message.content)\n        return {}\n    return json_dict\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker._get_authors_from_llm","title":"<code>_get_authors_from_llm(autor)</code>","text":"<p>Queries the LLM to retrieve a list of potential author names based on a provided name.</p> <p>Parameters:</p> Name Type Description Default <code>autor</code> <code>str</code> <p>The author name to query.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of author names suggested by the LLM.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def _get_authors_from_llm(self, autor: str) -&gt; List[str]:\n    \"\"\"Queries the LLM to retrieve a list of potential author names based on a provided name.\n\n    Args:\n        autor (str): The author name to query.\n\n    Returns:\n        List[str]: A list of author names suggested by the LLM.\n    \"\"\"\n    response_schema = {\n        \"type\": \"json_schema\",\n        \"json_schema\": {\n            \"name\": \"AuthorList\",\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"Authors_LLM\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"description\": \"A list of authors' names\",\n                        },\n                    }\n                },\n                \"required\": [\"Authors_LLM\"],\n                \"additionalProperties\": False,\n            },\n        },\n    }\n\n    prompt = (\n        \"\"\"\n    Tu es un agent expert en litt\u00e9rature.\n    Donne moi quelques auteurs dont le nom s'approche de celui-ci : \"\"\"\n        + autor\n        + \"\"\"\n\n    S'il s'agit deja d'un auteur connu, retourne moi juste son nom. S'il y a une erreur dans le nom que je t'ai donne, corrige moi en me donnant le nom de l'auteur que tu penses que j'ai voulu dire.\n\n    Je veux que tu me donnes le prenom puis le nom dans cet ordre. Par exemple \"Marcel Pagnol\" ou \"Victor Hugo\".\n    Ces auteurs sont susceptibles d'etre discutes dans \"Le Masque et la Plume\".\n\n    Si tu me retournes plusieurs auteurs, fais le sous forme de liste par exemple si tu as identifie \"auteur 1\" et \"auteur 2\" alors retourne [\"auteur 1\", \"auteur 2\"]\n    \"\"\"\n    )\n\n    response = self.llm_structured_output.chat(\n        messages=[\n            ChatMessage(\n                role=\"system\",\n                content=\"Tu es un agent litteraire qui connait parfaitement les auteurs.\",\n            ),\n            ChatMessage(role=\"user\", content=f\"{prompt}. \"),\n        ],\n        response_format=response_schema,\n    )\n\n    try:\n        json_dict = json.loads(response.message.content)\n    except json.JSONDecodeError as e:\n        print(\"Error parsing JSON:\", e)\n        print(\"Raw response:\", response.message.content)\n        return []\n    return json_dict[\"Authors_LLM\"]\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker._get_authors_from_titre_description","title":"<code>_get_authors_from_titre_description()</code>","text":"<p>Retrieves a list of author names extracted from the episode title and description using LLM.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of author names extracted from the title and description.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def _get_authors_from_titre_description(self) -&gt; List[str]:\n    \"\"\"Retrieves a list of author names extracted from the episode title and description using LLM.\n\n    Returns:\n        List[str]: A list of author names extracted from the title and description.\n    \"\"\"\n    response_schema = {\n        \"type\": \"json_schema\",\n        \"json_schema\": {\n            \"name\": \"AuthorTitreDescriptionList\",\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"Authors_TitreDescription\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"description\": \"A list of names from title and description\",\n                        },\n                    }\n                },\n                \"required\": [\"Authors_TitreDescription\"],\n                \"additionalProperties\": False,\n            },\n        },\n    }\n    response = self.llm_structured_output.chat(\n        messages=[\n            ChatMessage(\n                role=\"system\",\n                content=\"Tu es un assistant utile qui retourne une liste JSON de noms.\",\n            ),\n            ChatMessage(\n                role=\"user\",\n                content=f\"Est-ce que tu peux me lister tous les noms qui sont cit\u00e9s dans le titre et la description de l'\u00e9pisode suivant : {self.episode.titre} {self.episode.description}. \",\n            ),\n        ],\n        response_format=response_schema,\n    )\n    try:\n        json_dict = json.loads(response.message.content)\n    except json.JSONDecodeError as e:\n        print(\"Error parsing JSON:\", e)\n        print(\"Raw response:\", response.message.content)\n        return []  # Return an empty list if parsing fails\n    return json_dict[\"Authors_TitreDescription\"]\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker.check_author","title":"<code>check_author(author, return_details=False, verbose=False)</code>","text":"<p>Verifies an author's name through various sources and returns the corrected name.</p> It checks in the following order <ol> <li>RSS metadata (title, description)</li> <li>MongoDB list of known authors</li> <li>LLM suggested names</li> <li>Web search analysis</li> </ol> <p>Parameters:</p> Name Type Description Default <code>author</code> <code>str</code> <p>The author name to verify.</p> required <code>return_details</code> <code>bool</code> <p>If True, returns a detailed dictionary with source and analysis. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints debug messages. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Union[str, int]], None]</code> <p>Union[str, Dict[str, Union[str, int]], None]: The corrected author name as a string if return_details is False; a detailed dict if return_details is True; or None if no match is found.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def check_author(\n    self, author: str, return_details: bool = False, verbose: bool = False\n) -&gt; Union[str, Dict[str, Union[str, int]], None]:\n    \"\"\"Verifies an author's name through various sources and returns the corrected name.\n\n    It checks in the following order:\n      1. RSS metadata (title, description)\n      2. MongoDB list of known authors\n      3. LLM suggested names\n      4. Web search analysis\n\n    Args:\n        author (str): The author name to verify.\n        return_details (bool, optional): If True, returns a detailed dictionary with source and analysis. Defaults to False.\n        verbose (bool, optional): If True, prints debug messages. Defaults to False.\n\n    Returns:\n        Union[str, Dict[str, Union[str, int]], None]: The corrected author name as a string if return_details is False;\n            a detailed dict if return_details is True; or None if no match is found.\n    \"\"\"\n    details = {\"author_original\": author, \"author_corrected\": None, \"source\": None}\n\n    # 1. V\u00e9rification dans rss:metadata (titre, description)\n    match = self._check_author_source(author, self.authors_titre_description)\n    if match:\n        details[\"author_corrected\"] = match\n        details[\"source\"] = \"rss:metadata\"\n        if verbose:\n            print(f\"Trouv\u00e9 avec rss:metadata: {match}\")\n        return details if return_details else match\n\n    # 2. V\u00e9rification dans la base de donn\u00e9es (mongodb:auteurs)\n    list_db_auteurs = [auteur.nom for auteur in Auteur.get_entries()]\n    match = self._check_author_source(author, list_db_auteurs)\n    if match:\n        details[\"author_corrected\"] = match\n        details[\"source\"] = \"mongodb:auteurs\"\n        if verbose:\n            print(f\"Trouv\u00e9 avec mongodb:auteurs: {match}\")\n        return details if return_details else match\n\n    # 3. V\u00e9rification via llm\n    list_llm_auteurs = self._get_authors_from_llm(author)\n    match = self._check_author_source(author, list_llm_auteurs)\n    if match:\n        details[\"author_corrected\"] = match\n        details[\"source\"] = \"llm\"\n        if verbose:\n            print(f\"Trouv\u00e9 avec llm: {match}\")\n        return details if return_details else match\n\n    # 4. V\u00e9rification via web search\n    web_result_dict = self._get_author_from_web(author)\n    match = web_result_dict.get(\"auteur\")\n    score = web_result_dict.get(\"certitude\", 0)\n    details.update(\n        {\n            \"author_corrected\": match,\n            \"score\": score,\n            \"analyse\": web_result_dict.get(\"analyse\", \"\"),\n            \"source\": \"web search\",\n        }\n    )\n    if score &gt;= score_fuzz_threshold:\n        if verbose:\n            print(f\"Trouv\u00e9 avec web search: {match}\")\n        return details if return_details else match\n    else:\n        if verbose:\n            print(\n                f\"Score insuffisant {score} avec web search: {web_result_dict.get('analyse', '')}\"\n            )\n        details[\"author_corrected\"] = None\n        return details if return_details else None\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher","title":"<code>AuthorFuzzMatcher</code>","text":"Source code in <code>nbs/mongo_auteur.py</code> <pre><code>class AuthorFuzzMatcher:\n    def __init__(self, reference_authors: Optional[List[str]] = None) -&gt; None:\n        \"\"\"Initializes an AuthorFuzzMatcher with a list of known author names.\n\n        Args:\n            reference_authors (Optional[List[str]]): A list of known author names. Defaults to None.\n        \"\"\"\n        self.reference_authors = set(reference_authors) if reference_authors else set()\n\n    def add_reference_author(self, author: str) -&gt; None:\n        \"\"\"Adds a new reference author to the set.\n\n        Args:\n            author (str): The author name to be added.\n        \"\"\"\n        self.reference_authors.add(author.strip())\n\n    def find_best_match(\n        self, name: str, min_score: int = 80\n    ) -&gt; Tuple[Optional[str], int]:\n        \"\"\"Finds the best matching reference author for a given name using token set ratio.\n\n        Args:\n            name (str): The name to match against the reference authors.\n            min_score (int, optional): The minimal score required for a match. Defaults to 80.\n\n        Returns:\n            Tuple[Optional[str], int]: A tuple with the best matching author's name (or None if no match satisfies the minimum score) and the matching score.\n        \"\"\"\n        if not name or not self.reference_authors:\n            return None, 0\n        best_match, score = process.extractOne(\n            name, self.reference_authors, scorer=fuzz.token_set_ratio\n        )\n        if score &gt;= min_score:\n            return best_match, score\n        return None, score\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher.__init__","title":"<code>__init__(reference_authors=None)</code>","text":"<p>Initializes an AuthorFuzzMatcher with a list of known author names.</p> <p>Parameters:</p> Name Type Description Default <code>reference_authors</code> <code>Optional[List[str]]</code> <p>A list of known author names. Defaults to None.</p> <code>None</code> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def __init__(self, reference_authors: Optional[List[str]] = None) -&gt; None:\n    \"\"\"Initializes an AuthorFuzzMatcher with a list of known author names.\n\n    Args:\n        reference_authors (Optional[List[str]]): A list of known author names. Defaults to None.\n    \"\"\"\n    self.reference_authors = set(reference_authors) if reference_authors else set()\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher.add_reference_author","title":"<code>add_reference_author(author)</code>","text":"<p>Adds a new reference author to the set.</p> <p>Parameters:</p> Name Type Description Default <code>author</code> <code>str</code> <p>The author name to be added.</p> required Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def add_reference_author(self, author: str) -&gt; None:\n    \"\"\"Adds a new reference author to the set.\n\n    Args:\n        author (str): The author name to be added.\n    \"\"\"\n    self.reference_authors.add(author.strip())\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher.find_best_match","title":"<code>find_best_match(name, min_score=80)</code>","text":"<p>Finds the best matching reference author for a given name using token set ratio.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to match against the reference authors.</p> required <code>min_score</code> <code>int</code> <p>The minimal score required for a match. Defaults to 80.</p> <code>80</code> <p>Returns:</p> Type Description <code>Tuple[Optional[str], int]</code> <p>Tuple[Optional[str], int]: A tuple with the best matching author's name (or None if no match satisfies the minimum score) and the matching score.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def find_best_match(\n    self, name: str, min_score: int = 80\n) -&gt; Tuple[Optional[str], int]:\n    \"\"\"Finds the best matching reference author for a given name using token set ratio.\n\n    Args:\n        name (str): The name to match against the reference authors.\n        min_score (int, optional): The minimal score required for a match. Defaults to 80.\n\n    Returns:\n        Tuple[Optional[str], int]: A tuple with the best matching author's name (or None if no match satisfies the minimum score) and the matching score.\n    \"\"\"\n    if not name or not self.reference_authors:\n        return None, 0\n    best_match, score = process.extractOne(\n        name, self.reference_authors, scorer=fuzz.token_set_ratio\n    )\n    if score &gt;= min_score:\n        return best_match, score\n    return None, score\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.google_search","title":"<code>google_search(query)</code>","text":"<p>Effectue une recherche Google en utilisant l'API Custom Search et retourne les r\u00e9sultats.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>La requ\u00eate de recherche.</p> required <p>Returns:</p> Type Description <code>Optional[List[Dict[str, Optional[str]]]]</code> <p>Optional[List[Dict[str, Optional[str]]]]: Une liste de dictionnaires repr\u00e9sentant les r\u00e9sultats de la recherche, chaque dictionnaire contenant les cl\u00e9s 'title', 'snippet' et 'link'. Retourne None en cas d'erreur.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def google_search(query: str) -&gt; Optional[List[Dict[str, Optional[str]]]]:\n    \"\"\"Effectue une recherche Google en utilisant l'API Custom Search et retourne les r\u00e9sultats.\n\n    Args:\n        query (str): La requ\u00eate de recherche.\n\n    Returns:\n        Optional[List[Dict[str, Optional[str]]]]:\n            Une liste de dictionnaires repr\u00e9sentant les r\u00e9sultats de la recherche, chaque dictionnaire contenant\n            les cl\u00e9s 'title', 'snippet' et 'link'. Retourne None en cas d'erreur.\n    \"\"\"\n    try:\n        service = build(\"customsearch\", \"v1\", developerKey=api_key)\n        res = service.cse().list(q=query, cx=cse_id).execute()\n\n        results: List[Dict[str, Optional[str]]] = []\n        for item in res.get(\"items\", []):\n            title: Optional[str] = item.get(\"title\")\n            snippet: Optional[str] = item.get(\"snippet\")\n            link: Optional[str] = item.get(\"link\")\n            results.append({\"title\": title, \"snippet\": snippet, \"link\": link})\n        return results\n    except Exception as e:\n        print(f\"Erreur lors de la recherche Google: {e}\")\n        return None\n</code></pre>"},{"location":"mongo_episode/","title":"Module mongo_episode","text":""},{"location":"mongo_episode/#mongo_episode.Episode","title":"<code>Episode</code>","text":"Source code in <code>nbs/mongo_episode.py</code> <pre><code>class Episode:\n    def __init__(\n        self, date: str, titre: str, collection_name: str = \"episodes\"\n    ) -&gt; None:\n        \"\"\"Initialise une instance d'Episode.\n\n        Args:\n            date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\" conforme \u00e0 DATE_FORMAT.\n            titre (str): Le titre de l'\u00e9pisode.\n            collection_name (str, optional): Le nom de la collection dans la base de donn\u00e9es. D\u00e9faut: \"episodes\".\n\n        Notes:\n            Si l'\u00e9pisode existe d\u00e9j\u00e0 en base, ses attributs seront charg\u00e9s.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        self.date: datetime = Episode.get_date_from_string(date)\n        self.titre: str = titre\n\n        if self.exists():\n            episode = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n            self.description: Optional[str] = episode.get(\"description\")\n            self.url_telechargement: Optional[str] = episode.get(\"url\")\n            self.audio_rel_filename: Optional[str] = episode.get(\"audio_rel_filename\")\n            self.transcription: Optional[str] = episode.get(\"transcription\")\n            self.type: Optional[str] = episode.get(\"type\")\n            self.duree: int = episode.get(\"duree\", -1)\n        else:\n            self.description = None\n            self.url_telechargement = None\n            self.audio_rel_filename = None\n            self.transcription = None\n            self.type = None\n            self.duree = -1  # en secondes\n\n    @classmethod\n    def from_oid(cls, oid: ObjectId, collection_name: str = \"episodes\") -&gt; \"Episode\":\n        \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'un ObjectId dans la base de donn\u00e9es.\n\n        Args:\n            oid (ObjectId): L'identifiant de l'\u00e9pisode dans Mongo.\n            collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n        Returns:\n            Episode: L'instance d'Episode correspondante.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        document = collection.find_one({\"_id\": oid})\n        date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n        instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n        return instance\n\n    @classmethod\n    def from_date(\n        cls, date: datetime, collection_name: str = \"episodes\"\n    ) -&gt; Optional[\"Episode\"]:\n        \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'une date dans la base de donn\u00e9es.\n\n        Args:\n            date (datetime): La date recherch\u00e9e.\n            collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n        Returns:\n            Optional[Episode]: L'instance d'Episode si trouv\u00e9e, sinon None.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        start_date = datetime(date.year, date.month, date.day)\n        end_date = datetime(date.year, date.month, date.day, 23, 59, 59)\n        document = collection.find_one({\"date\": {\"$gte\": start_date, \"$lte\": end_date}})\n        if document:\n            date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n            instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n            return instance\n        else:\n            return None\n\n    def exists(self) -&gt; bool:\n        \"\"\"V\u00e9rifie si l'\u00e9pisode existe dans la base de donn\u00e9es.\n\n        Returns:\n            bool: True si l'\u00e9pisode existe, False sinon.\n        \"\"\"\n        return (\n            self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n            is not None\n        )\n\n    def keep(self) -&gt; int:\n        \"\"\"T\u00e9l\u00e9charge le fichier audio si n\u00e9cessaire et conserve l'\u00e9pisode dans la base de donn\u00e9es.\n\n        Returns:\n            int: 1 si une nouvelle entr\u00e9e est cr\u00e9\u00e9e en base, 0 sinon.\n        \"\"\"\n        message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n        if not self.exists():\n            print(\n                f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} nouveau: Duree: {self.duree}, Type: {self.type}\"\n            )\n            mongolog(\"insert\", self.collection.name, message_log)\n            self.download_audio(verbose=True)\n            self.collection.insert_one(\n                {\n                    \"titre\": self.titre,\n                    \"date\": self.date,\n                    \"description\": self.description,\n                    \"url\": self.url_telechargement,\n                    \"audio_rel_filename\": self.audio_rel_filename,\n                    \"transcription\": self.transcription,\n                    \"type\": self.type,\n                    \"duree\": self.duree,\n                }\n            )\n            return 1\n        else:\n            print(\n                f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} deja existant\"\n            )\n            mongolog(\"update\", self.collection.name, message_log)\n            return 0\n\n    def update_date(self, new_date: datetime) -&gt; None:\n        \"\"\"Met \u00e0 jour la date de l'\u00e9pisode dans la base de donn\u00e9es.\n\n        Args:\n            new_date (datetime): La nouvelle date de l'\u00e9pisode.\n        \"\"\"\n        self.collection.update_one(\n            {\"_id\": self.get_oid()}, {\"$set\": {\"date\": new_date}}\n        )\n        message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre} -&gt; {Episode.get_string_from_date(new_date, format=LOG_DATE_FORMAT)}\"\n        self.date = new_date\n        mongolog(\"force_update\", self.collection.name, message_log)\n\n    def remove(self) -&gt; None:\n        \"\"\"Supprime l'\u00e9pisode de la base de donn\u00e9es.\"\"\"\n        message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n        self.collection.delete_one({\"titre\": self.titre, \"date\": self.date})\n        mongolog(\"delete\", self.collection.name, message_log)\n\n    def get_oid(self) -&gt; Optional[ObjectId]:\n        \"\"\"R\u00e9cup\u00e8re l'identifiant Mongo (_id) de l'\u00e9pisode.\n\n        Returns:\n            Optional[ObjectId]: L'ObjectId de l'\u00e9pisode s'il existe, sinon None.\n        \"\"\"\n        document = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n        if document:\n            return document[\"_id\"]\n        else:\n            return None\n\n    @staticmethod\n    def get_date_from_string(date: str, DATE_FORMAT: str = DATE_FORMAT) -&gt; datetime:\n        \"\"\"Convertit une cha\u00eene de caract\u00e8res en objet datetime.\n\n        Args:\n            date (str): La cha\u00eene repr\u00e9sentant la date.\n            DATE_FORMAT (str, optional): Le format de la date. D\u00e9faut est DATE_FORMAT.\n\n        Returns:\n            datetime: L'objet datetime correspondant.\n        \"\"\"\n        return datetime.strptime(date, DATE_FORMAT)\n\n    @staticmethod\n    def get_string_from_date(date: datetime, format: Optional[str] = None) -&gt; str:\n        \"\"\"Convertit un objet datetime en cha\u00eene de caract\u00e8res.\n\n        Args:\n            date (datetime): L'objet datetime.\n            format (Optional[str], optional): Le format de sortie. Si None, DATE_FORMAT est utilis\u00e9.\n\n        Returns:\n            str: La cha\u00eene repr\u00e9sentant la date.\n        \"\"\"\n        if format is not None:\n            return date.strftime(format)\n        else:\n            return date.strftime(DATE_FORMAT)\n\n    @staticmethod\n    def format_duration(seconds: int) -&gt; str:\n        \"\"\"Convertit une dur\u00e9e en secondes au format HH:MM:SS.\n\n        Args:\n            seconds (int): La dur\u00e9e en secondes.\n\n        Returns:\n            str: La dur\u00e9e format\u00e9e en cha\u00eene de caract\u00e8res.\n        \"\"\"\n        if seconds &lt; 0:\n            return f\"-{Episode.format_duration(-seconds)}\"\n        hours = seconds // 3600\n        minutes = (seconds % 3600) // 60\n        seconds = seconds % 60\n        return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Renvoie une repr\u00e9sentation textuelle de l'\u00e9pisode.\n\n        Returns:\n            str: Les informations de l'\u00e9pisode sous forme de cha\u00eene de caract\u00e8res.\n        \"\"\"\n        return (\n            f\"_oid: {self.get_oid()}\\n\"\n            f\"Date: {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)}\\n\"\n            f\"Titre: {self.titre}\\n\"\n            f\"Description: {self.description}\\n\"\n            f\"URL de t\u00e9l\u00e9chargement: {self.url_telechargement}\\n\"\n            f\"Fichier audio: {self.audio_rel_filename}\\n\"\n            f\"Duree: {self.duree} en secondes ({Episode.format_duration(self.duree)})\\n\"\n            f\"Transcription: {self.transcription[:100] if self.transcription else 'No transcription yet available'}...\"\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Renvoie une repr\u00e9sentation officielle de l'objet.\n\n        Returns:\n            str: La repr\u00e9sentation de l'objet (\u00e9quivalente \u00e0 __str__).\n        \"\"\"\n        return self.__str__()\n\n    def download_audio(self, verbose: bool = False) -&gt; None:\n        \"\"\"T\u00e9l\u00e9charge le fichier audio \u00e0 partir de l'URL de t\u00e9l\u00e9chargement et le sauvegarde localement.\n\n        Args:\n            verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n        \"\"\"\n        if self.url_telechargement is None:\n            return\n        year = str(self.date.year)\n        full_audio_path = get_audio_path(AUDIO_PATH, year)\n        full_filename = os.path.join(\n            full_audio_path, os.path.basename(self.url_telechargement)\n        )\n        self.audio_rel_filename = os.path.relpath(\n            full_filename, get_audio_path(AUDIO_PATH, year=\"\")\n        )\n        if not os.path.exists(full_filename):\n            if verbose:\n                print(\n                    f\"T\u00e9l\u00e9chargement de {self.url_telechargement} vers {full_filename}\"\n                )\n            response = requests.get(self.url_telechargement)\n            with open(full_filename, \"wb\") as file:\n                file.write(response.content)\n        else:\n            if verbose:\n                print(f\"Le fichier {full_filename} existe d\u00e9j\u00e0. Ignor\u00e9.\")\n\n    def set_transcription(self, verbose: bool = False, keep_cache: bool = True) -&gt; None:\n        \"\"\"Extrait et sauvegarde la transcription de l'audio en utilisant un mod\u00e8le Whisper.\n\n        Utilise le cache si disponible ou extrait la transcription de l'audio.\n\n        Args:\n            verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n            keep_cache (bool, optional): Si True, sauvegarde la transcription dans un fichier cache. D\u00e9faut True.\n        \"\"\"\n        if self.transcription is not None:\n            if verbose:\n                print(\"Transcription existe deja\")\n            return\n        mp3_fullfilename = get_audio_path(AUDIO_PATH, year=\"\") + self.audio_rel_filename\n        cache_transcription_filename = f\"{os.path.splitext(mp3_fullfilename)[0]}.txt\"\n        if os.path.exists(cache_transcription_filename):\n            if verbose:\n                print(f\"Transcription cachee trouvee: {cache_transcription_filename}\")\n            with open(cache_transcription_filename, \"r\") as file:\n                self.transcription = file.read()\n            self.collection.update_one(\n                {\"_id\": self.get_oid()},\n                {\"$set\": {\"transcription\": self.transcription}},\n            )\n            return\n\n        self.transcription = extract_whisper(mp3_fullfilename)\n        if keep_cache:\n            with open(cache_transcription_filename, \"w\") as f:\n                f.write(self.transcription)\n        self.collection.update_one(\n            {\"_id\": self.get_oid()}, {\"$set\": {\"transcription\": self.transcription}}\n        )\n\n    def to_dict(self) -&gt; Dict[str, Union[str, datetime, int, None]]:\n        \"\"\"Convertit l'\u00e9pisode en dictionnaire.\n\n        Returns:\n            Dict[str, Union[str, datetime, int, None]]: Dictionnaire contenant les informations de l'\u00e9pisode.\n                Les cl\u00e9s sont ['date', 'titre', 'description', 'url_telechargement', 'audio_rel_filename', 'transcription', 'type', 'duree'].\n        \"\"\"\n        return {\n            \"date\": self.date,\n            \"titre\": self.titre,\n            \"description\": self.description,\n            \"url_telechargement\": self.url_telechargement,\n            \"audio_rel_filename\": self.audio_rel_filename,\n            \"transcription\": self.transcription,\n            \"type\": self.type,\n            \"duree\": self.duree,\n        }\n\n    def get_all_auteurs(self) -&gt; List[str]:\n        \"\"\"Extrait la liste de tous les auteurs mentionn\u00e9s dans la transcription.\n\n        Notes:\n            Utilise le mod\u00e8le GPT-4 via Azure LLM pour extraire une liste JSON de noms d'auteurs.\n\n        Returns:\n            List[str]: La liste des auteurs d\u00e9tect\u00e9s.\n        \"\"\"\n        if self.transcription is None:\n            return []\n\n        llm_structured_output = get_azure_llm(\"gpt-4o\")\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"Une liste des auteurs extraits de la transcription\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n        response = llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un assistant utile qui retourne une liste JSON de noms d'auteurs.\",\n                ),\n                ChatMessage(\n                    role=\"user\",\n                    content=f\"Est-ce que tu peux me lister tous les noms d'auteurs dont on parle des oeuvres \\\ndans cette transcription d'un \u00e9pisode du masque et la plume \\\ndiffuse le {self.date.strftime('%d %b %Y')}. \\\nJe veux toujours avoir le pr\u00e9nom et le nom complet de chaque auteur. \\\nVoici cette transcription : {self.transcription} \",\n                ),\n            ],\n            response_format=response_schema,\n        )\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []\n        return json_dict[\"Authors\"]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.__init__","title":"<code>__init__(date, titre, collection_name='episodes')</code>","text":"<p>Initialise une instance d'Episode.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\" conforme \u00e0 DATE_FORMAT.</p> required <code>titre</code> <code>str</code> <p>Le titre de l'\u00e9pisode.</p> required <code>collection_name</code> <code>str</code> <p>Le nom de la collection dans la base de donn\u00e9es. D\u00e9faut: \"episodes\".</p> <code>'episodes'</code> Notes <p>Si l'\u00e9pisode existe d\u00e9j\u00e0 en base, ses attributs seront charg\u00e9s.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(\n    self, date: str, titre: str, collection_name: str = \"episodes\"\n) -&gt; None:\n    \"\"\"Initialise une instance d'Episode.\n\n    Args:\n        date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\" conforme \u00e0 DATE_FORMAT.\n        titre (str): Le titre de l'\u00e9pisode.\n        collection_name (str, optional): Le nom de la collection dans la base de donn\u00e9es. D\u00e9faut: \"episodes\".\n\n    Notes:\n        Si l'\u00e9pisode existe d\u00e9j\u00e0 en base, ses attributs seront charg\u00e9s.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    self.date: datetime = Episode.get_date_from_string(date)\n    self.titre: str = titre\n\n    if self.exists():\n        episode = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n        self.description: Optional[str] = episode.get(\"description\")\n        self.url_telechargement: Optional[str] = episode.get(\"url\")\n        self.audio_rel_filename: Optional[str] = episode.get(\"audio_rel_filename\")\n        self.transcription: Optional[str] = episode.get(\"transcription\")\n        self.type: Optional[str] = episode.get(\"type\")\n        self.duree: int = episode.get(\"duree\", -1)\n    else:\n        self.description = None\n        self.url_telechargement = None\n        self.audio_rel_filename = None\n        self.transcription = None\n        self.type = None\n        self.duree = -1  # en secondes\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.__repr__","title":"<code>__repr__()</code>","text":"<p>Renvoie une repr\u00e9sentation officielle de l'objet.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La repr\u00e9sentation de l'objet (\u00e9quivalente \u00e0 str).</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Renvoie une repr\u00e9sentation officielle de l'objet.\n\n    Returns:\n        str: La repr\u00e9sentation de l'objet (\u00e9quivalente \u00e0 __str__).\n    \"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.__str__","title":"<code>__str__()</code>","text":"<p>Renvoie une repr\u00e9sentation textuelle de l'\u00e9pisode.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Les informations de l'\u00e9pisode sous forme de cha\u00eene de caract\u00e8res.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Renvoie une repr\u00e9sentation textuelle de l'\u00e9pisode.\n\n    Returns:\n        str: Les informations de l'\u00e9pisode sous forme de cha\u00eene de caract\u00e8res.\n    \"\"\"\n    return (\n        f\"_oid: {self.get_oid()}\\n\"\n        f\"Date: {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)}\\n\"\n        f\"Titre: {self.titre}\\n\"\n        f\"Description: {self.description}\\n\"\n        f\"URL de t\u00e9l\u00e9chargement: {self.url_telechargement}\\n\"\n        f\"Fichier audio: {self.audio_rel_filename}\\n\"\n        f\"Duree: {self.duree} en secondes ({Episode.format_duration(self.duree)})\\n\"\n        f\"Transcription: {self.transcription[:100] if self.transcription else 'No transcription yet available'}...\"\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.download_audio","title":"<code>download_audio(verbose=False)</code>","text":"<p>T\u00e9l\u00e9charge le fichier audio \u00e0 partir de l'URL de t\u00e9l\u00e9chargement et le sauvegarde localement.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Si True, affiche des messages d'information. D\u00e9faut False.</p> <code>False</code> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def download_audio(self, verbose: bool = False) -&gt; None:\n    \"\"\"T\u00e9l\u00e9charge le fichier audio \u00e0 partir de l'URL de t\u00e9l\u00e9chargement et le sauvegarde localement.\n\n    Args:\n        verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n    \"\"\"\n    if self.url_telechargement is None:\n        return\n    year = str(self.date.year)\n    full_audio_path = get_audio_path(AUDIO_PATH, year)\n    full_filename = os.path.join(\n        full_audio_path, os.path.basename(self.url_telechargement)\n    )\n    self.audio_rel_filename = os.path.relpath(\n        full_filename, get_audio_path(AUDIO_PATH, year=\"\")\n    )\n    if not os.path.exists(full_filename):\n        if verbose:\n            print(\n                f\"T\u00e9l\u00e9chargement de {self.url_telechargement} vers {full_filename}\"\n            )\n        response = requests.get(self.url_telechargement)\n        with open(full_filename, \"wb\") as file:\n            file.write(response.content)\n    else:\n        if verbose:\n            print(f\"Le fichier {full_filename} existe d\u00e9j\u00e0. Ignor\u00e9.\")\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.exists","title":"<code>exists()</code>","text":"<p>V\u00e9rifie si l'\u00e9pisode existe dans la base de donn\u00e9es.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si l'\u00e9pisode existe, False sinon.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"V\u00e9rifie si l'\u00e9pisode existe dans la base de donn\u00e9es.\n\n    Returns:\n        bool: True si l'\u00e9pisode existe, False sinon.\n    \"\"\"\n    return (\n        self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n        is not None\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.format_duration","title":"<code>format_duration(seconds)</code>  <code>staticmethod</code>","text":"<p>Convertit une dur\u00e9e en secondes au format HH:MM:SS.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>La dur\u00e9e en secondes.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La dur\u00e9e format\u00e9e en cha\u00eene de caract\u00e8res.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef format_duration(seconds: int) -&gt; str:\n    \"\"\"Convertit une dur\u00e9e en secondes au format HH:MM:SS.\n\n    Args:\n        seconds (int): La dur\u00e9e en secondes.\n\n    Returns:\n        str: La dur\u00e9e format\u00e9e en cha\u00eene de caract\u00e8res.\n    \"\"\"\n    if seconds &lt; 0:\n        return f\"-{Episode.format_duration(-seconds)}\"\n    hours = seconds // 3600\n    minutes = (seconds % 3600) // 60\n    seconds = seconds % 60\n    return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.from_date","title":"<code>from_date(date, collection_name='episodes')</code>  <code>classmethod</code>","text":"<p>Cr\u00e9e un \u00e9pisode \u00e0 partir d'une date dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>datetime</code> <p>La date recherch\u00e9e.</p> required <code>collection_name</code> <code>str</code> <p>Le nom de la collection. D\u00e9faut: \"episodes\".</p> <code>'episodes'</code> <p>Returns:</p> Type Description <code>Optional[Episode]</code> <p>Optional[Episode]: L'instance d'Episode si trouv\u00e9e, sinon None.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_date(\n    cls, date: datetime, collection_name: str = \"episodes\"\n) -&gt; Optional[\"Episode\"]:\n    \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'une date dans la base de donn\u00e9es.\n\n    Args:\n        date (datetime): La date recherch\u00e9e.\n        collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n    Returns:\n        Optional[Episode]: L'instance d'Episode si trouv\u00e9e, sinon None.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    start_date = datetime(date.year, date.month, date.day)\n    end_date = datetime(date.year, date.month, date.day, 23, 59, 59)\n    document = collection.find_one({\"date\": {\"$gte\": start_date, \"$lte\": end_date}})\n    if document:\n        date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n        instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n        return instance\n    else:\n        return None\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.from_oid","title":"<code>from_oid(oid, collection_name='episodes')</code>  <code>classmethod</code>","text":"<p>Cr\u00e9e un \u00e9pisode \u00e0 partir d'un ObjectId dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>ObjectId</code> <p>L'identifiant de l'\u00e9pisode dans Mongo.</p> required <code>collection_name</code> <code>str</code> <p>Le nom de la collection. D\u00e9faut: \"episodes\".</p> <code>'episodes'</code> <p>Returns:</p> Name Type Description <code>Episode</code> <code>Episode</code> <p>L'instance d'Episode correspondante.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_oid(cls, oid: ObjectId, collection_name: str = \"episodes\") -&gt; \"Episode\":\n    \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'un ObjectId dans la base de donn\u00e9es.\n\n    Args:\n        oid (ObjectId): L'identifiant de l'\u00e9pisode dans Mongo.\n        collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n    Returns:\n        Episode: L'instance d'Episode correspondante.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    document = collection.find_one({\"_id\": oid})\n    date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n    instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n    return instance\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_all_auteurs","title":"<code>get_all_auteurs()</code>","text":"<p>Extrait la liste de tous les auteurs mentionn\u00e9s dans la transcription.</p> Notes <p>Utilise le mod\u00e8le GPT-4 via Azure LLM pour extraire une liste JSON de noms d'auteurs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: La liste des auteurs d\u00e9tect\u00e9s.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>    def get_all_auteurs(self) -&gt; List[str]:\n        \"\"\"Extrait la liste de tous les auteurs mentionn\u00e9s dans la transcription.\n\n        Notes:\n            Utilise le mod\u00e8le GPT-4 via Azure LLM pour extraire une liste JSON de noms d'auteurs.\n\n        Returns:\n            List[str]: La liste des auteurs d\u00e9tect\u00e9s.\n        \"\"\"\n        if self.transcription is None:\n            return []\n\n        llm_structured_output = get_azure_llm(\"gpt-4o\")\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"Une liste des auteurs extraits de la transcription\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n        response = llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un assistant utile qui retourne une liste JSON de noms d'auteurs.\",\n                ),\n                ChatMessage(\n                    role=\"user\",\n                    content=f\"Est-ce que tu peux me lister tous les noms d'auteurs dont on parle des oeuvres \\\ndans cette transcription d'un \u00e9pisode du masque et la plume \\\ndiffuse le {self.date.strftime('%d %b %Y')}. \\\nJe veux toujours avoir le pr\u00e9nom et le nom complet de chaque auteur. \\\nVoici cette transcription : {self.transcription} \",\n                ),\n            ],\n            response_format=response_schema,\n        )\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []\n        return json_dict[\"Authors\"]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_date_from_string","title":"<code>get_date_from_string(date, DATE_FORMAT=DATE_FORMAT)</code>  <code>staticmethod</code>","text":"<p>Convertit une cha\u00eene de caract\u00e8res en objet datetime.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>La cha\u00eene repr\u00e9sentant la date.</p> required <code>DATE_FORMAT</code> <code>str</code> <p>Le format de la date. D\u00e9faut est DATE_FORMAT.</p> <code>DATE_FORMAT</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>L'objet datetime correspondant.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef get_date_from_string(date: str, DATE_FORMAT: str = DATE_FORMAT) -&gt; datetime:\n    \"\"\"Convertit une cha\u00eene de caract\u00e8res en objet datetime.\n\n    Args:\n        date (str): La cha\u00eene repr\u00e9sentant la date.\n        DATE_FORMAT (str, optional): Le format de la date. D\u00e9faut est DATE_FORMAT.\n\n    Returns:\n        datetime: L'objet datetime correspondant.\n    \"\"\"\n    return datetime.strptime(date, DATE_FORMAT)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_oid","title":"<code>get_oid()</code>","text":"<p>R\u00e9cup\u00e8re l'identifiant Mongo (_id) de l'\u00e9pisode.</p> <p>Returns:</p> Type Description <code>Optional[ObjectId]</code> <p>Optional[ObjectId]: L'ObjectId de l'\u00e9pisode s'il existe, sinon None.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_oid(self) -&gt; Optional[ObjectId]:\n    \"\"\"R\u00e9cup\u00e8re l'identifiant Mongo (_id) de l'\u00e9pisode.\n\n    Returns:\n        Optional[ObjectId]: L'ObjectId de l'\u00e9pisode s'il existe, sinon None.\n    \"\"\"\n    document = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n    if document:\n        return document[\"_id\"]\n    else:\n        return None\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_string_from_date","title":"<code>get_string_from_date(date, format=None)</code>  <code>staticmethod</code>","text":"<p>Convertit un objet datetime en cha\u00eene de caract\u00e8res.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>datetime</code> <p>L'objet datetime.</p> required <code>format</code> <code>Optional[str]</code> <p>Le format de sortie. Si None, DATE_FORMAT est utilis\u00e9.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La cha\u00eene repr\u00e9sentant la date.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef get_string_from_date(date: datetime, format: Optional[str] = None) -&gt; str:\n    \"\"\"Convertit un objet datetime en cha\u00eene de caract\u00e8res.\n\n    Args:\n        date (datetime): L'objet datetime.\n        format (Optional[str], optional): Le format de sortie. Si None, DATE_FORMAT est utilis\u00e9.\n\n    Returns:\n        str: La cha\u00eene repr\u00e9sentant la date.\n    \"\"\"\n    if format is not None:\n        return date.strftime(format)\n    else:\n        return date.strftime(DATE_FORMAT)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.keep","title":"<code>keep()</code>","text":"<p>T\u00e9l\u00e9charge le fichier audio si n\u00e9cessaire et conserve l'\u00e9pisode dans la base de donn\u00e9es.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>1 si une nouvelle entr\u00e9e est cr\u00e9\u00e9e en base, 0 sinon.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def keep(self) -&gt; int:\n    \"\"\"T\u00e9l\u00e9charge le fichier audio si n\u00e9cessaire et conserve l'\u00e9pisode dans la base de donn\u00e9es.\n\n    Returns:\n        int: 1 si une nouvelle entr\u00e9e est cr\u00e9\u00e9e en base, 0 sinon.\n    \"\"\"\n    message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n    if not self.exists():\n        print(\n            f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} nouveau: Duree: {self.duree}, Type: {self.type}\"\n        )\n        mongolog(\"insert\", self.collection.name, message_log)\n        self.download_audio(verbose=True)\n        self.collection.insert_one(\n            {\n                \"titre\": self.titre,\n                \"date\": self.date,\n                \"description\": self.description,\n                \"url\": self.url_telechargement,\n                \"audio_rel_filename\": self.audio_rel_filename,\n                \"transcription\": self.transcription,\n                \"type\": self.type,\n                \"duree\": self.duree,\n            }\n        )\n        return 1\n    else:\n        print(\n            f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} deja existant\"\n        )\n        mongolog(\"update\", self.collection.name, message_log)\n        return 0\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.remove","title":"<code>remove()</code>","text":"<p>Supprime l'\u00e9pisode de la base de donn\u00e9es.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Supprime l'\u00e9pisode de la base de donn\u00e9es.\"\"\"\n    message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n    self.collection.delete_one({\"titre\": self.titre, \"date\": self.date})\n    mongolog(\"delete\", self.collection.name, message_log)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.set_transcription","title":"<code>set_transcription(verbose=False, keep_cache=True)</code>","text":"<p>Extrait et sauvegarde la transcription de l'audio en utilisant un mod\u00e8le Whisper.</p> <p>Utilise le cache si disponible ou extrait la transcription de l'audio.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Si True, affiche des messages d'information. D\u00e9faut False.</p> <code>False</code> <code>keep_cache</code> <code>bool</code> <p>Si True, sauvegarde la transcription dans un fichier cache. D\u00e9faut True.</p> <code>True</code> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def set_transcription(self, verbose: bool = False, keep_cache: bool = True) -&gt; None:\n    \"\"\"Extrait et sauvegarde la transcription de l'audio en utilisant un mod\u00e8le Whisper.\n\n    Utilise le cache si disponible ou extrait la transcription de l'audio.\n\n    Args:\n        verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n        keep_cache (bool, optional): Si True, sauvegarde la transcription dans un fichier cache. D\u00e9faut True.\n    \"\"\"\n    if self.transcription is not None:\n        if verbose:\n            print(\"Transcription existe deja\")\n        return\n    mp3_fullfilename = get_audio_path(AUDIO_PATH, year=\"\") + self.audio_rel_filename\n    cache_transcription_filename = f\"{os.path.splitext(mp3_fullfilename)[0]}.txt\"\n    if os.path.exists(cache_transcription_filename):\n        if verbose:\n            print(f\"Transcription cachee trouvee: {cache_transcription_filename}\")\n        with open(cache_transcription_filename, \"r\") as file:\n            self.transcription = file.read()\n        self.collection.update_one(\n            {\"_id\": self.get_oid()},\n            {\"$set\": {\"transcription\": self.transcription}},\n        )\n        return\n\n    self.transcription = extract_whisper(mp3_fullfilename)\n    if keep_cache:\n        with open(cache_transcription_filename, \"w\") as f:\n            f.write(self.transcription)\n    self.collection.update_one(\n        {\"_id\": self.get_oid()}, {\"$set\": {\"transcription\": self.transcription}}\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.to_dict","title":"<code>to_dict()</code>","text":"<p>Convertit l'\u00e9pisode en dictionnaire.</p> <p>Returns:</p> Type Description <code>Dict[str, Union[str, datetime, int, None]]</code> <p>Dict[str, Union[str, datetime, int, None]]: Dictionnaire contenant les informations de l'\u00e9pisode. Les cl\u00e9s sont ['date', 'titre', 'description', 'url_telechargement', 'audio_rel_filename', 'transcription', 'type', 'duree'].</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Union[str, datetime, int, None]]:\n    \"\"\"Convertit l'\u00e9pisode en dictionnaire.\n\n    Returns:\n        Dict[str, Union[str, datetime, int, None]]: Dictionnaire contenant les informations de l'\u00e9pisode.\n            Les cl\u00e9s sont ['date', 'titre', 'description', 'url_telechargement', 'audio_rel_filename', 'transcription', 'type', 'duree'].\n    \"\"\"\n    return {\n        \"date\": self.date,\n        \"titre\": self.titre,\n        \"description\": self.description,\n        \"url_telechargement\": self.url_telechargement,\n        \"audio_rel_filename\": self.audio_rel_filename,\n        \"transcription\": self.transcription,\n        \"type\": self.type,\n        \"duree\": self.duree,\n    }\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.update_date","title":"<code>update_date(new_date)</code>","text":"<p>Met \u00e0 jour la date de l'\u00e9pisode dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>new_date</code> <code>datetime</code> <p>La nouvelle date de l'\u00e9pisode.</p> required Source code in <code>nbs/mongo_episode.py</code> <pre><code>def update_date(self, new_date: datetime) -&gt; None:\n    \"\"\"Met \u00e0 jour la date de l'\u00e9pisode dans la base de donn\u00e9es.\n\n    Args:\n        new_date (datetime): La nouvelle date de l'\u00e9pisode.\n    \"\"\"\n    self.collection.update_one(\n        {\"_id\": self.get_oid()}, {\"$set\": {\"date\": new_date}}\n    )\n    message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre} -&gt; {Episode.get_string_from_date(new_date, format=LOG_DATE_FORMAT)}\"\n    self.date = new_date\n    mongolog(\"force_update\", self.collection.name, message_log)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes","title":"<code>Episodes</code>","text":"<p>Classe pour rechercher et g\u00e9rer la qualit\u00e9 des donn\u00e9es des \u00e9pisodes.</p> <p>Cette classe permet par exemple de r\u00e9cup\u00e9rer de nouvelles transcriptions en se connectant \u00e0 la base de donn\u00e9es MongoDB.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>class Episodes:\n    \"\"\"Classe pour rechercher et g\u00e9rer la qualit\u00e9 des donn\u00e9es des \u00e9pisodes.\n\n    Cette classe permet par exemple de r\u00e9cup\u00e9rer de nouvelles transcriptions\n    en se connectant \u00e0 la base de donn\u00e9es MongoDB.\n    \"\"\"\n\n    def __init__(self, collection_name: str = \"episodes\") -&gt; None:\n        \"\"\"Initialise une instance du gestionnaire d'\u00e9pisodes.\n\n        Se connecte \u00e0 la base de donn\u00e9es et charge les \u00e9pisodes.\n\n        Args:\n            collection_name (str): Nom de la collection \u00e0 utiliser. Par d\u00e9faut \"episodes\".\n\n        Returns:\n            None\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        self.episodes = self._load_episodes()\n\n    def _load_episodes(self) -&gt; List[\"Episode\"]:\n        \"\"\"Charge tous les \u00e9pisodes depuis la base de donn\u00e9es.\n\n        Returns:\n            List[Episode]: Liste des \u00e9pisodes charg\u00e9s.\n        \"\"\"\n        return self.get_entries()\n\n    def get_entries(self, request: Any = \"\") -&gt; List[\"Episode\"]:\n        \"\"\"Retourne les \u00e9pisodes correspondant \u00e0 une requ\u00eate sp\u00e9cifique, tri\u00e9s par date d\u00e9croissante.\n\n        Args:\n            request (Any): Requ\u00eate MongoDB \u00e0 ex\u00e9cuter. Exemples:\n                {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}.\n                Par d\u00e9faut, une requ\u00eate vide qui retourne tous les \u00e9pisodes.\n\n        Returns:\n            List[Episode]: Liste des \u00e9pisodes correspondant \u00e0 la requ\u00eate.\n        \"\"\"\n        result = self.collection.find(request).sort(\"date\", pymongo.DESCENDING)\n        episodes = [Episode.from_oid(entry.get(\"_id\")) for entry in result]\n        return episodes\n\n    def get_missing_transcriptions(self) -&gt; List[\"Episode\"]:\n        \"\"\"Retourne les \u00e9pisodes sans transcription.\n\n        Returns:\n            List[Episode]: Liste des \u00e9pisodes dont la transcription est manquante.\n        \"\"\"\n        return self.get_entries(\n            {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}\n        )\n\n    def get_transcriptions(self) -&gt; List[\"Episode\"]:\n        \"\"\"Retourne les \u00e9pisodes qui poss\u00e8dent une transcription.\n\n        Returns:\n            List[Episode]: Liste des \u00e9pisodes ayant une transcription.\n        \"\"\"\n        return self.get_entries(\n            {\"$and\": [{\"transcription\": {\"$ne\": None}}, {\"transcription\": {\"$ne\": \"\"}}]}\n        )\n\n    def __getitem__(self, index: int) -&gt; \"Episode\":\n        \"\"\"Permet l'acc\u00e8s aux \u00e9pisodes par indexation.\n\n        Args:\n            index (int): Position de l'\u00e9pisode dans la liste.\n\n        Returns:\n            Episode: L'\u00e9pisode \u00e0 la position donn\u00e9e.\n        \"\"\"\n        return self.episodes[index]\n\n    def __len__(self) -&gt; int:\n        \"\"\"Retourne le nombre total d'\u00e9pisodes charg\u00e9s.\n\n        Returns:\n            int: Nombre d'\u00e9pisodes.\n        \"\"\"\n        return len(self.episodes)\n\n    def __iter__(self) -&gt; Iterator[\"Episode\"]:\n        \"\"\"Permet d'it\u00e9rer sur les \u00e9pisodes.\n\n        Returns:\n            Iterator[Episode]: It\u00e9rateur sur la liste des \u00e9pisodes.\n        \"\"\"\n        return iter(self.episodes)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Retourne une repr\u00e9sentation textuelle de l'objet Episodes.\n\n        La repr\u00e9sentation inclut le nombre total d'entr\u00e9es et le nombre d'\u00e9pisodes sans transcription.\n\n        Returns:\n            str: Cha\u00eene de caract\u00e8res d\u00e9crivant l'objet Episodes.\n        \"\"\"\n        return (\n            f\"{self.collection.count_documents({})} entries\\n\"\n            f\"{len(self.get_missing_transcriptions())} missing transcriptions\"\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Retourne la repr\u00e9sentation officielle de l'objet Episodes.\n\n        Returns:\n            str: Repr\u00e9sentation de l'objet Episodes identique \u00e0 celle retourn\u00e9e par __str__.\n        \"\"\"\n        return self.__str__()\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Permet l'acc\u00e8s aux \u00e9pisodes par indexation.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Position de l'\u00e9pisode dans la liste.</p> required <p>Returns:</p> Name Type Description <code>Episode</code> <code>Episode</code> <p>L'\u00e9pisode \u00e0 la position donn\u00e9e.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __getitem__(self, index: int) -&gt; \"Episode\":\n    \"\"\"Permet l'acc\u00e8s aux \u00e9pisodes par indexation.\n\n    Args:\n        index (int): Position de l'\u00e9pisode dans la liste.\n\n    Returns:\n        Episode: L'\u00e9pisode \u00e0 la position donn\u00e9e.\n    \"\"\"\n    return self.episodes[index]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__init__","title":"<code>__init__(collection_name='episodes')</code>","text":"<p>Initialise une instance du gestionnaire d'\u00e9pisodes.</p> <p>Se connecte \u00e0 la base de donn\u00e9es et charge les \u00e9pisodes.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Nom de la collection \u00e0 utiliser. Par d\u00e9faut \"episodes\".</p> <code>'episodes'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(self, collection_name: str = \"episodes\") -&gt; None:\n    \"\"\"Initialise une instance du gestionnaire d'\u00e9pisodes.\n\n    Se connecte \u00e0 la base de donn\u00e9es et charge les \u00e9pisodes.\n\n    Args:\n        collection_name (str): Nom de la collection \u00e0 utiliser. Par d\u00e9faut \"episodes\".\n\n    Returns:\n        None\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    self.episodes = self._load_episodes()\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__iter__","title":"<code>__iter__()</code>","text":"<p>Permet d'it\u00e9rer sur les \u00e9pisodes.</p> <p>Returns:</p> Type Description <code>Iterator[Episode]</code> <p>Iterator[Episode]: It\u00e9rateur sur la liste des \u00e9pisodes.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __iter__(self) -&gt; Iterator[\"Episode\"]:\n    \"\"\"Permet d'it\u00e9rer sur les \u00e9pisodes.\n\n    Returns:\n        Iterator[Episode]: It\u00e9rateur sur la liste des \u00e9pisodes.\n    \"\"\"\n    return iter(self.episodes)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__len__","title":"<code>__len__()</code>","text":"<p>Retourne le nombre total d'\u00e9pisodes charg\u00e9s.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Nombre d'\u00e9pisodes.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Retourne le nombre total d'\u00e9pisodes charg\u00e9s.\n\n    Returns:\n        int: Nombre d'\u00e9pisodes.\n    \"\"\"\n    return len(self.episodes)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__repr__","title":"<code>__repr__()</code>","text":"<p>Retourne la repr\u00e9sentation officielle de l'objet Episodes.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Repr\u00e9sentation de l'objet Episodes identique \u00e0 celle retourn\u00e9e par str.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Retourne la repr\u00e9sentation officielle de l'objet Episodes.\n\n    Returns:\n        str: Repr\u00e9sentation de l'objet Episodes identique \u00e0 celle retourn\u00e9e par __str__.\n    \"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__str__","title":"<code>__str__()</code>","text":"<p>Retourne une repr\u00e9sentation textuelle de l'objet Episodes.</p> <p>La repr\u00e9sentation inclut le nombre total d'entr\u00e9es et le nombre d'\u00e9pisodes sans transcription.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cha\u00eene de caract\u00e8res d\u00e9crivant l'objet Episodes.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Retourne une repr\u00e9sentation textuelle de l'objet Episodes.\n\n    La repr\u00e9sentation inclut le nombre total d'entr\u00e9es et le nombre d'\u00e9pisodes sans transcription.\n\n    Returns:\n        str: Cha\u00eene de caract\u00e8res d\u00e9crivant l'objet Episodes.\n    \"\"\"\n    return (\n        f\"{self.collection.count_documents({})} entries\\n\"\n        f\"{len(self.get_missing_transcriptions())} missing transcriptions\"\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes._load_episodes","title":"<code>_load_episodes()</code>","text":"<p>Charge tous les \u00e9pisodes depuis la base de donn\u00e9es.</p> <p>Returns:</p> Type Description <code>List[Episode]</code> <p>List[Episode]: Liste des \u00e9pisodes charg\u00e9s.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def _load_episodes(self) -&gt; List[\"Episode\"]:\n    \"\"\"Charge tous les \u00e9pisodes depuis la base de donn\u00e9es.\n\n    Returns:\n        List[Episode]: Liste des \u00e9pisodes charg\u00e9s.\n    \"\"\"\n    return self.get_entries()\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.get_entries","title":"<code>get_entries(request='')</code>","text":"<p>Retourne les \u00e9pisodes correspondant \u00e0 une requ\u00eate sp\u00e9cifique, tri\u00e9s par date d\u00e9croissante.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Any</code> <p>Requ\u00eate MongoDB \u00e0 ex\u00e9cuter. Exemples: {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}. Par d\u00e9faut, une requ\u00eate vide qui retourne tous les \u00e9pisodes.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Episode]</code> <p>List[Episode]: Liste des \u00e9pisodes correspondant \u00e0 la requ\u00eate.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_entries(self, request: Any = \"\") -&gt; List[\"Episode\"]:\n    \"\"\"Retourne les \u00e9pisodes correspondant \u00e0 une requ\u00eate sp\u00e9cifique, tri\u00e9s par date d\u00e9croissante.\n\n    Args:\n        request (Any): Requ\u00eate MongoDB \u00e0 ex\u00e9cuter. Exemples:\n            {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}.\n            Par d\u00e9faut, une requ\u00eate vide qui retourne tous les \u00e9pisodes.\n\n    Returns:\n        List[Episode]: Liste des \u00e9pisodes correspondant \u00e0 la requ\u00eate.\n    \"\"\"\n    result = self.collection.find(request).sort(\"date\", pymongo.DESCENDING)\n    episodes = [Episode.from_oid(entry.get(\"_id\")) for entry in result]\n    return episodes\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.get_missing_transcriptions","title":"<code>get_missing_transcriptions()</code>","text":"<p>Retourne les \u00e9pisodes sans transcription.</p> <p>Returns:</p> Type Description <code>List[Episode]</code> <p>List[Episode]: Liste des \u00e9pisodes dont la transcription est manquante.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_missing_transcriptions(self) -&gt; List[\"Episode\"]:\n    \"\"\"Retourne les \u00e9pisodes sans transcription.\n\n    Returns:\n        List[Episode]: Liste des \u00e9pisodes dont la transcription est manquante.\n    \"\"\"\n    return self.get_entries(\n        {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.get_transcriptions","title":"<code>get_transcriptions()</code>","text":"<p>Retourne les \u00e9pisodes qui poss\u00e8dent une transcription.</p> <p>Returns:</p> Type Description <code>List[Episode]</code> <p>List[Episode]: Liste des \u00e9pisodes ayant une transcription.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_transcriptions(self) -&gt; List[\"Episode\"]:\n    \"\"\"Retourne les \u00e9pisodes qui poss\u00e8dent une transcription.\n\n    Returns:\n        List[Episode]: Liste des \u00e9pisodes ayant une transcription.\n    \"\"\"\n    return self.get_entries(\n        {\"$and\": [{\"transcription\": {\"$ne\": None}}, {\"transcription\": {\"$ne\": \"\"}}]}\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode","title":"<code>RSS_episode</code>","text":"<p>               Bases: <code>Episode</code></p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>class RSS_episode(Episode):\n    def __init__(self, date: str, titre: str) -&gt; None:\n        \"\"\"\n        Initialize an RSS_episode instance.\n\n        Args:\n            date (str): The episode date in the format \"2024-12-22T09:59:39\".\n            titre (str): The title of the episode.\n        \"\"\"\n        super().__init__(date, titre)\n\n    @classmethod\n    def from_feed_entry(cls, feed_entry: FeedParserDict) -&gt; \"RSS_episode\":\n        \"\"\"\n        Create an RSS_episode instance from an RSS feed entry.\n\n        Args:\n            feed_entry (FeedParserDict): The entry from the RSS feed.\n\n        Returns:\n            RSS_episode: The created RSS_episode instance.\n        \"\"\"\n        locale.setlocale(locale.LC_TIME, \"en_US.UTF-8\")\n        date_rss: datetime = datetime.strptime(feed_entry.published, RSS_DATE_FORMAT)\n        date_rss_str: str = cls.get_string_from_date(date_rss, DATE_FORMAT)\n        inst = cls(\n            date=date_rss_str,\n            titre=feed_entry.title,\n        )\n        inst.description = feed_entry.summary\n\n        for link in feed_entry.links:\n            if link.type == \"audio/mpeg\":\n                inst.url_telechargement = link.href\n                break\n\n        inst.type = cls.set_titre(inst.titre + \" \" + inst.description)\n        inst.duree = cls.get_duree_in_seconds(feed_entry.itunes_duration)  # in seconds\n\n        return inst\n\n    @staticmethod\n    def get_duree_in_seconds(duree: str) -&gt; int:\n        \"\"\"\n        Convert a duration string into total seconds.\n\n        The duration can be in formats \"HH:MM:SS\", \"HH:MM\", or simply seconds.\n\n        Args:\n            duree (str): The duration as a string.\n\n        Returns:\n            int: The duration expressed in total seconds.\n        \"\"\"\n        duree_parts = duree.split(\":\")\n        if len(duree_parts) == 3:\n            return (\n                int(duree_parts[0]) * 3600\n                + int(duree_parts[1]) * 60\n                + int(duree_parts[2])\n            )\n        elif len(duree_parts) == 2:\n            return int(duree_parts[0]) * 60 + int(duree_parts[1])\n        else:\n            return int(duree_parts[0])\n\n    def keep(self) -&gt; int:\n        \"\"\"\n        Save the episode to the database if conditions are met.\n\n        The episode is saved if:\n            - The duration is greater than RSS_DUREE_MINI_MINUTES * 60 seconds.\n            - The type is equal to \"livres\".\n\n        Returns:\n            int: 1 if an entry is created in the database, 0 otherwise.\n        \"\"\"\n        if (self.duree &gt; RSS_DUREE_MINI_MINUTES * 60) and (self.type == \"livres\"):\n            return super().keep()\n        else:\n            print(\n                f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} ignored: Duree: {self.duree}, Type: {self.type}\"\n            )\n            return 0\n\n    @staticmethod\n    def set_titre(description: str) -&gt; str:\n        \"\"\"\n        Classify the episode by using a zero-shot classification model from HuggingFace based on the provided description.\n\n        Args:\n            description (str): The description combining the title and summary.\n\n        Returns:\n            str: The label with the highest score among [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"].\n        \"\"\"\n        classifier = pipeline(\n            \"zero-shot-classification\", model=\"facebook/bart-large-mnli\"\n        )\n        labels = [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"]\n\n        result = classifier(description, labels)\n        return result[\"labels\"][0]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.__init__","title":"<code>__init__(date, titre)</code>","text":"<p>Initialize an RSS_episode instance.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>The episode date in the format \"2024-12-22T09:59:39\".</p> required <code>titre</code> <code>str</code> <p>The title of the episode.</p> required Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(self, date: str, titre: str) -&gt; None:\n    \"\"\"\n    Initialize an RSS_episode instance.\n\n    Args:\n        date (str): The episode date in the format \"2024-12-22T09:59:39\".\n        titre (str): The title of the episode.\n    \"\"\"\n    super().__init__(date, titre)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.from_feed_entry","title":"<code>from_feed_entry(feed_entry)</code>  <code>classmethod</code>","text":"<p>Create an RSS_episode instance from an RSS feed entry.</p> <p>Parameters:</p> Name Type Description Default <code>feed_entry</code> <code>FeedParserDict</code> <p>The entry from the RSS feed.</p> required <p>Returns:</p> Name Type Description <code>RSS_episode</code> <code>RSS_episode</code> <p>The created RSS_episode instance.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_feed_entry(cls, feed_entry: FeedParserDict) -&gt; \"RSS_episode\":\n    \"\"\"\n    Create an RSS_episode instance from an RSS feed entry.\n\n    Args:\n        feed_entry (FeedParserDict): The entry from the RSS feed.\n\n    Returns:\n        RSS_episode: The created RSS_episode instance.\n    \"\"\"\n    locale.setlocale(locale.LC_TIME, \"en_US.UTF-8\")\n    date_rss: datetime = datetime.strptime(feed_entry.published, RSS_DATE_FORMAT)\n    date_rss_str: str = cls.get_string_from_date(date_rss, DATE_FORMAT)\n    inst = cls(\n        date=date_rss_str,\n        titre=feed_entry.title,\n    )\n    inst.description = feed_entry.summary\n\n    for link in feed_entry.links:\n        if link.type == \"audio/mpeg\":\n            inst.url_telechargement = link.href\n            break\n\n    inst.type = cls.set_titre(inst.titre + \" \" + inst.description)\n    inst.duree = cls.get_duree_in_seconds(feed_entry.itunes_duration)  # in seconds\n\n    return inst\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.get_duree_in_seconds","title":"<code>get_duree_in_seconds(duree)</code>  <code>staticmethod</code>","text":"<p>Convert a duration string into total seconds.</p> <p>The duration can be in formats \"HH:MM:SS\", \"HH:MM\", or simply seconds.</p> <p>Parameters:</p> Name Type Description Default <code>duree</code> <code>str</code> <p>The duration as a string.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The duration expressed in total seconds.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef get_duree_in_seconds(duree: str) -&gt; int:\n    \"\"\"\n    Convert a duration string into total seconds.\n\n    The duration can be in formats \"HH:MM:SS\", \"HH:MM\", or simply seconds.\n\n    Args:\n        duree (str): The duration as a string.\n\n    Returns:\n        int: The duration expressed in total seconds.\n    \"\"\"\n    duree_parts = duree.split(\":\")\n    if len(duree_parts) == 3:\n        return (\n            int(duree_parts[0]) * 3600\n            + int(duree_parts[1]) * 60\n            + int(duree_parts[2])\n        )\n    elif len(duree_parts) == 2:\n        return int(duree_parts[0]) * 60 + int(duree_parts[1])\n    else:\n        return int(duree_parts[0])\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.keep","title":"<code>keep()</code>","text":"<p>Save the episode to the database if conditions are met.</p> The episode is saved if <ul> <li>The duration is greater than RSS_DUREE_MINI_MINUTES * 60 seconds.</li> <li>The type is equal to \"livres\".</li> </ul> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>1 if an entry is created in the database, 0 otherwise.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def keep(self) -&gt; int:\n    \"\"\"\n    Save the episode to the database if conditions are met.\n\n    The episode is saved if:\n        - The duration is greater than RSS_DUREE_MINI_MINUTES * 60 seconds.\n        - The type is equal to \"livres\".\n\n    Returns:\n        int: 1 if an entry is created in the database, 0 otherwise.\n    \"\"\"\n    if (self.duree &gt; RSS_DUREE_MINI_MINUTES * 60) and (self.type == \"livres\"):\n        return super().keep()\n    else:\n        print(\n            f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} ignored: Duree: {self.duree}, Type: {self.type}\"\n        )\n        return 0\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.set_titre","title":"<code>set_titre(description)</code>  <code>staticmethod</code>","text":"<p>Classify the episode by using a zero-shot classification model from HuggingFace based on the provided description.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description combining the title and summary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The label with the highest score among [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"].</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef set_titre(description: str) -&gt; str:\n    \"\"\"\n    Classify the episode by using a zero-shot classification model from HuggingFace based on the provided description.\n\n    Args:\n        description (str): The description combining the title and summary.\n\n    Returns:\n        str: The label with the highest score among [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"].\n    \"\"\"\n    classifier = pipeline(\n        \"zero-shot-classification\", model=\"facebook/bart-large-mnli\"\n    )\n    labels = [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"]\n\n    result = classifier(description, labels)\n    return result[\"labels\"][0]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode","title":"<code>WEB_episode</code>","text":"<p>               Bases: <code>Episode</code></p> <p>Repr\u00e9sente un \u00e9pisode web avec ses attributs et m\u00e9thodes de conversion et r\u00e9cup\u00e9ration des donn\u00e9es.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>class WEB_episode(Episode):\n    \"\"\"Repr\u00e9sente un \u00e9pisode web avec ses attributs et m\u00e9thodes de conversion et r\u00e9cup\u00e9ration des donn\u00e9es.\"\"\"\n\n    def __init__(self, date: str, titre: str) -&gt; None:\n        \"\"\"Initialise une instance de WEB_episode.\n\n        Args:\n            date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\".\n            titre (str): Le titre de l'\u00e9pisode.\n        \"\"\"\n        super().__init__(date, titre)\n\n    @staticmethod\n    def parse_web_date(\n        web_date: str, web_date_format: str = WEB_DATE_FORMAT\n    ) -&gt; Optional[datetime]:\n        \"\"\"Convertit une date en fran\u00e7ais extraite d'une page web en un objet datetime.\n\n        Corrige les abr\u00e9viations non standard pour certains mois (exemple : \"f\u00e9v.\" devient \"f\u00e9vr.\", \"juill.\" devient \"juil.\").\n\n        Args:\n            web_date (str): La cha\u00eene repr\u00e9sentant la date en fran\u00e7ais.\n            web_date_format (str, optional): Le format de la date utilis\u00e9 par la page web. Defaults to WEB_DATE_FORMAT.\n\n        Returns:\n            Optional[datetime]: L'objet datetime si la conversion r\u00e9ussit, sinon None.\n        \"\"\"\n        locale.setlocale(locale.LC_TIME, \"fr_FR.UTF-8\")\n\n        def corrige_date(date_str: str) -&gt; str:\n            \"\"\"Corrige les abr\u00e9viations non standard dans la cha\u00eene de date.\n\n            Args:\n                date_str (str): La cha\u00eene de date originale.\n\n            Returns:\n                str: La cha\u00eene de date corrig\u00e9e.\n            \"\"\"\n            month_replacements = {\n                \"f\u00e9v.\": \"f\u00e9vr.\",\n                \"juill.\": \"juil.\",\n            }\n            for fr_month, fr_month_norm in month_replacements.items():\n                date_str = date_str.replace(fr_month, fr_month_norm)\n            return date_str\n\n        try:\n            dt: datetime = datetime.strptime(corrige_date(web_date), web_date_format)\n            return dt\n        except ValueError as e:\n            print(f\"Erreur de conversion pour la date '{web_date}': {e}\")\n            return None\n\n    @staticmethod\n    def get_audio_url(url: str) -&gt; Optional[str]:\n        \"\"\"R\u00e9cup\u00e8re l'URL du fichier audio (.m4a ou .mp3) \u00e0 partir de la page d'un \u00e9pisode.\n\n        Recherche dans une balise &lt;script&gt; contenant la cl\u00e9 \"contentUrl\".\n\n        Args:\n            url (str): L'URL de la page de l'\u00e9pisode.\n\n        Returns:\n            Optional[str]: L'URL du fichier audio si trouv\u00e9e, sinon None.\n        \"\"\"\n        try:\n            response: requests.Response = requests.get(url)\n            response.raise_for_status()\n        except requests.RequestException as e:\n            print(f\"Erreur lors de la requ\u00eate HTTP: {e}\")\n            return None\n\n        soup: BeautifulSoup = BeautifulSoup(response.content, \"html.parser\")\n        script_tag = soup.find(\"script\", string=lambda t: t and \"contentUrl\" in t)\n\n        if script_tag:\n            try:\n                json_text: str = script_tag.string  # type: ignore\n                json_data: Dict[str, Any] = json.loads(json_text)\n                audio_url: Optional[str] = None\n                for item in json_data.get(\"@graph\", []):\n                    if item.get(\"@type\") == \"RadioEpisode\":\n                        main_entity: Dict[str, Any] = item.get(\"mainEntity\", {})\n                        audio_url = main_entity.get(\"contentUrl\")\n                        break\n                return audio_url\n            except (json.JSONDecodeError, KeyError, TypeError) as e:\n                print(f\"Erreur lors de l'analyse du JSON: {e}\")\n                return None\n\n        print(\"Balise &lt;script&gt; contenant 'contentUrl' non trouv\u00e9e\")\n        return None\n\n    @classmethod\n    def from_webpage_entry(cls, dict_web_episode: Dict[str, Any]) -&gt; \"WEB_episode\":\n        \"\"\"Cr\u00e9e une instance de WEB_episode \u00e0 partir d'un dictionnaire repr\u00e9sentant une entr\u00e9e de page web.\n\n        Le dictionnaire doit contenir les cl\u00e9s : 'title', 'url', 'description', 'date', 'duration'.\n        La variable DATE_FORMAT et la m\u00e9thode get_string_from_date doivent \u00eatre d\u00e9finies ailleurs dans le code.\n\n        Args:\n            dict_web_episode (Dict[str, Any]): Dictionnaire contenant les informations de l'\u00e9pisode.\n\n        Returns:\n            WEB_episode: Une instance de WEB_episode initialis\u00e9e avec les donn\u00e9es fournies.\n        \"\"\"\n        date_web: Optional[datetime] = cls.parse_web_date(dict_web_episode[\"date\"])\n        date_web_str: str = cls.get_string_from_date(\n            date_web, DATE_FORMAT\n        )  # DATE_FORMAT doit \u00eatre d\u00e9fini en amont\n        inst: WEB_episode = cls(\n            date=date_web_str,\n            titre=dict_web_episode[\"title\"],\n        )\n        inst.description = dict_web_episode[\"description\"]\n        inst.type = \"livres\"\n        inst.url_telechargement = cls.get_audio_url(dict_web_episode[\"url\"])\n        inst.duree = cls.get_duree_in_seconds(dict_web_episode[\"duration\"])\n        return inst\n\n    @staticmethod\n    def get_duree_in_seconds(duree: str) -&gt; int:\n        \"\"\"Convertit une dur\u00e9e exprim\u00e9e en minutes (\"MM min\") en secondes.\n\n        Args:\n            duree (str): La dur\u00e9e sous forme de cha\u00eene.\n\n        Returns:\n            int: La dur\u00e9e convertie en secondes. Retourne 0 si le format n'est pas correct.\n        \"\"\"\n        parts = duree.split(\" \")\n        if len(parts) == 2:\n            return int(parts[0]) * 60\n        return 0\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode.__init__","title":"<code>__init__(date, titre)</code>","text":"<p>Initialise une instance de WEB_episode.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\".</p> required <code>titre</code> <code>str</code> <p>Le titre de l'\u00e9pisode.</p> required Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(self, date: str, titre: str) -&gt; None:\n    \"\"\"Initialise une instance de WEB_episode.\n\n    Args:\n        date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\".\n        titre (str): Le titre de l'\u00e9pisode.\n    \"\"\"\n    super().__init__(date, titre)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode.from_webpage_entry","title":"<code>from_webpage_entry(dict_web_episode)</code>  <code>classmethod</code>","text":"<p>Cr\u00e9e une instance de WEB_episode \u00e0 partir d'un dictionnaire repr\u00e9sentant une entr\u00e9e de page web.</p> <p>Le dictionnaire doit contenir les cl\u00e9s : 'title', 'url', 'description', 'date', 'duration'. La variable DATE_FORMAT et la m\u00e9thode get_string_from_date doivent \u00eatre d\u00e9finies ailleurs dans le code.</p> <p>Parameters:</p> Name Type Description Default <code>dict_web_episode</code> <code>Dict[str, Any]</code> <p>Dictionnaire contenant les informations de l'\u00e9pisode.</p> required <p>Returns:</p> Name Type Description <code>WEB_episode</code> <code>WEB_episode</code> <p>Une instance de WEB_episode initialis\u00e9e avec les donn\u00e9es fournies.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_webpage_entry(cls, dict_web_episode: Dict[str, Any]) -&gt; \"WEB_episode\":\n    \"\"\"Cr\u00e9e une instance de WEB_episode \u00e0 partir d'un dictionnaire repr\u00e9sentant une entr\u00e9e de page web.\n\n    Le dictionnaire doit contenir les cl\u00e9s : 'title', 'url', 'description', 'date', 'duration'.\n    La variable DATE_FORMAT et la m\u00e9thode get_string_from_date doivent \u00eatre d\u00e9finies ailleurs dans le code.\n\n    Args:\n        dict_web_episode (Dict[str, Any]): Dictionnaire contenant les informations de l'\u00e9pisode.\n\n    Returns:\n        WEB_episode: Une instance de WEB_episode initialis\u00e9e avec les donn\u00e9es fournies.\n    \"\"\"\n    date_web: Optional[datetime] = cls.parse_web_date(dict_web_episode[\"date\"])\n    date_web_str: str = cls.get_string_from_date(\n        date_web, DATE_FORMAT\n    )  # DATE_FORMAT doit \u00eatre d\u00e9fini en amont\n    inst: WEB_episode = cls(\n        date=date_web_str,\n        titre=dict_web_episode[\"title\"],\n    )\n    inst.description = dict_web_episode[\"description\"]\n    inst.type = \"livres\"\n    inst.url_telechargement = cls.get_audio_url(dict_web_episode[\"url\"])\n    inst.duree = cls.get_duree_in_seconds(dict_web_episode[\"duration\"])\n    return inst\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode.get_audio_url","title":"<code>get_audio_url(url)</code>  <code>staticmethod</code>","text":"<p>R\u00e9cup\u00e8re l'URL du fichier audio (.m4a ou .mp3) \u00e0 partir de la page d'un \u00e9pisode.</p> <p>Recherche dans une balise"},{"location":"rss/","title":"Module rss","text":""},{"location":"rss/#rss.Podcast","title":"<code>Podcast</code>","text":"Source code in <code>nbs/rss.py</code> <pre><code>class Podcast:\n    def __init__(self):\n        \"\"\"\n        Initialise la classe Podcast en analysant le flux RSS et en obtenant la collection MongoDB.\n        \"\"\"\n        self.parsed_flow = feedparser.parse(get_RSS_URL())\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=\"episodes\"\n        )\n\n    def get_most_recent_episode_from_DB(self) -&gt; Optional[datetime]:\n        \"\"\"\n        R\u00e9cup\u00e8re la date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s dans la base de donn\u00e9es.\n\n        Returns:\n            Optional[datetime]: La date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s, ou None si aucun \u00e9pisode n'est trouv\u00e9.\n        \"\"\"\n        most_recent_document = self.collection.find().sort({\"date\": -1}).limit(1)\n        most_recent_date = None\n        for doc in most_recent_document:\n            most_recent_date = doc[\"date\"].replace(tzinfo=pytz.timezone(\"Europe/Paris\"))\n        return most_recent_date\n\n    def list_last_large_episodes(\n        self, duree_mini_minutes: int = 15\n    ) -&gt; List[FeedParserDict]:\n        \"\"\"\n        Liste les \u00e9pisodes RSS qui sont plus r\u00e9cents que le plus r\u00e9cent \u00e9pisode stock\u00e9 dans la base de donn\u00e9es\n        et qui durent plus de `duree_mini_minutes` minutes.\n\n        Args:\n            duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 lister. Par d\u00e9faut \u00e0 15 minutes.\n\n        Returns:\n            List[FeedParserDict]: Une liste d'entr\u00e9es RSS correspondant aux crit\u00e8res.\n        \"\"\"\n        last_large_episodes = []\n        for entry in self.parsed_flow.entries:\n            date_rss = datetime.strptime(entry.published, RSS_DATE_FORMAT)\n            date_db = self.get_most_recent_episode_from_DB()\n            if date_db and date_rss &gt; date_db:\n                if (\n                    RSS_episode.get_duree_in_seconds(entry.itunes_duration)\n                    &gt; duree_mini_minutes * 60\n                ):\n                    last_large_episodes.append(entry)\n        return last_large_episodes\n\n    def store_last_large_episodes(self, duree_mini_minutes: int = 15) -&gt; None:\n        \"\"\"\n        Parcourt la liste des \u00e9pisodes longs r\u00e9cents, instancie RSS_episode et les conserve dans la base de donn\u00e9es.\n        Affiche le nombre de mises \u00e0 jour r\u00e9ussies dans la base de donn\u00e9es.\n\n        Args:\n            duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 stocker. Par d\u00e9faut \u00e0 15 minutes.\n        \"\"\"\n        updates = 0\n        last_large_episodes = self.list_last_large_episodes(duree_mini_minutes)\n        for entry in last_large_episodes:\n            rss_entry = RSS_episode.from_feed_entry(entry)\n            updates += rss_entry.keep()\n        print(f\"Updated episodes: {updates}\")\n</code></pre>"},{"location":"rss/#rss.Podcast.__init__","title":"<code>__init__()</code>","text":"<p>Initialise la classe Podcast en analysant le flux RSS et en obtenant la collection MongoDB.</p> Source code in <code>nbs/rss.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialise la classe Podcast en analysant le flux RSS et en obtenant la collection MongoDB.\n    \"\"\"\n    self.parsed_flow = feedparser.parse(get_RSS_URL())\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=\"episodes\"\n    )\n</code></pre>"},{"location":"rss/#rss.Podcast.get_most_recent_episode_from_DB","title":"<code>get_most_recent_episode_from_DB()</code>","text":"<p>R\u00e9cup\u00e8re la date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s dans la base de donn\u00e9es.</p> <p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Optional[datetime]: La date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s, ou None si aucun \u00e9pisode n'est trouv\u00e9.</p> Source code in <code>nbs/rss.py</code> <pre><code>def get_most_recent_episode_from_DB(self) -&gt; Optional[datetime]:\n    \"\"\"\n    R\u00e9cup\u00e8re la date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s dans la base de donn\u00e9es.\n\n    Returns:\n        Optional[datetime]: La date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s, ou None si aucun \u00e9pisode n'est trouv\u00e9.\n    \"\"\"\n    most_recent_document = self.collection.find().sort({\"date\": -1}).limit(1)\n    most_recent_date = None\n    for doc in most_recent_document:\n        most_recent_date = doc[\"date\"].replace(tzinfo=pytz.timezone(\"Europe/Paris\"))\n    return most_recent_date\n</code></pre>"},{"location":"rss/#rss.Podcast.list_last_large_episodes","title":"<code>list_last_large_episodes(duree_mini_minutes=15)</code>","text":"<p>Liste les \u00e9pisodes RSS qui sont plus r\u00e9cents que le plus r\u00e9cent \u00e9pisode stock\u00e9 dans la base de donn\u00e9es et qui durent plus de <code>duree_mini_minutes</code> minutes.</p> <p>Parameters:</p> Name Type Description Default <code>duree_mini_minutes</code> <code>int</code> <p>La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 lister. Par d\u00e9faut \u00e0 15 minutes.</p> <code>15</code> <p>Returns:</p> Type Description <code>List[FeedParserDict]</code> <p>List[FeedParserDict]: Une liste d'entr\u00e9es RSS correspondant aux crit\u00e8res.</p> Source code in <code>nbs/rss.py</code> <pre><code>def list_last_large_episodes(\n    self, duree_mini_minutes: int = 15\n) -&gt; List[FeedParserDict]:\n    \"\"\"\n    Liste les \u00e9pisodes RSS qui sont plus r\u00e9cents que le plus r\u00e9cent \u00e9pisode stock\u00e9 dans la base de donn\u00e9es\n    et qui durent plus de `duree_mini_minutes` minutes.\n\n    Args:\n        duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 lister. Par d\u00e9faut \u00e0 15 minutes.\n\n    Returns:\n        List[FeedParserDict]: Une liste d'entr\u00e9es RSS correspondant aux crit\u00e8res.\n    \"\"\"\n    last_large_episodes = []\n    for entry in self.parsed_flow.entries:\n        date_rss = datetime.strptime(entry.published, RSS_DATE_FORMAT)\n        date_db = self.get_most_recent_episode_from_DB()\n        if date_db and date_rss &gt; date_db:\n            if (\n                RSS_episode.get_duree_in_seconds(entry.itunes_duration)\n                &gt; duree_mini_minutes * 60\n            ):\n                last_large_episodes.append(entry)\n    return last_large_episodes\n</code></pre>"},{"location":"rss/#rss.Podcast.store_last_large_episodes","title":"<code>store_last_large_episodes(duree_mini_minutes=15)</code>","text":"<p>Parcourt la liste des \u00e9pisodes longs r\u00e9cents, instancie RSS_episode et les conserve dans la base de donn\u00e9es. Affiche le nombre de mises \u00e0 jour r\u00e9ussies dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>duree_mini_minutes</code> <code>int</code> <p>La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 stocker. Par d\u00e9faut \u00e0 15 minutes.</p> <code>15</code> Source code in <code>nbs/rss.py</code> <pre><code>def store_last_large_episodes(self, duree_mini_minutes: int = 15) -&gt; None:\n    \"\"\"\n    Parcourt la liste des \u00e9pisodes longs r\u00e9cents, instancie RSS_episode et les conserve dans la base de donn\u00e9es.\n    Affiche le nombre de mises \u00e0 jour r\u00e9ussies dans la base de donn\u00e9es.\n\n    Args:\n        duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 stocker. Par d\u00e9faut \u00e0 15 minutes.\n    \"\"\"\n    updates = 0\n    last_large_episodes = self.list_last_large_episodes(duree_mini_minutes)\n    for entry in last_large_episodes:\n        rss_entry = RSS_episode.from_feed_entry(entry)\n        updates += rss_entry.keep()\n    print(f\"Updated episodes: {updates}\")\n</code></pre>"},{"location":"rss/#rss.extraire_dureesummary","title":"<code>extraire_dureesummary(summary)</code>","text":"<p>Extrait la dur\u00e9e d'un \u00e9pisode du masque.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str</code> <p>Le r\u00e9sum\u00e9 de l'\u00e9pisode contenant la dur\u00e9e.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Le nombre de secondes correspondant \u00e0 la dur\u00e9e d'un \u00e9pisode.</p> <code>int</code> <p>Retourne -1 si la dur\u00e9e n'est pas trouv\u00e9e.</p> Source code in <code>nbs/rss.py</code> <pre><code>def extraire_dureesummary(summary: str) -&gt; int:\n    \"\"\"\n    Extrait la dur\u00e9e d'un \u00e9pisode du masque.\n\n    Args:\n        summary (str): Le r\u00e9sum\u00e9 de l'\u00e9pisode contenant la dur\u00e9e.\n\n    Returns:\n        int: Le nombre de secondes correspondant \u00e0 la dur\u00e9e d'un \u00e9pisode.\n        Retourne -1 si la dur\u00e9e n'est pas trouv\u00e9e.\n    \"\"\"\n    # Expression r\u00e9guli\u00e8re pour extraire la dur\u00e9e\n    pattern_duree = r\"dur\u00e9e\\s*:\\s*(\\d{2}:\\d{2}:\\d{2})\"\n\n    # Recherche de la dur\u00e9e dans le texte\n    match = re.search(pattern_duree, summary)\n\n    if match:\n        duree_str = match.group(1)\n        heures, minutes, secondes = map(int, duree_str.split(\":\"))\n        return heures * 3600 + minutes * 60 + secondes\n    else:\n        return -1\n</code></pre>"},{"location":"rss/#rss.extraire_urls_rss","title":"<code>extraire_urls_rss(duree_mini_minutes=15)</code>","text":"<p>Extrait les URLs des balises <code>enclosure</code> d'un flux RSS des \u00e9pisodes durant plus de <code>duree_mini_minutes</code> minutes.</p> <p>Parameters:</p> Name Type Description Default <code>duree_mini_minutes</code> <code>int</code> <p>La dur\u00e9e minimale en minutes des \u00e9pisodes du flux.</p> <code>15</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Une liste d'URLs.</p> Source code in <code>nbs/rss.py</code> <pre><code>def extraire_urls_rss(duree_mini_minutes: int = 15) -&gt; List[str]:\n    \"\"\"\n    Extrait les URLs des balises `enclosure` d'un flux RSS des \u00e9pisodes durant plus de `duree_mini_minutes` minutes.\n\n    Args:\n        duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes du flux.\n\n    Returns:\n        List[str]: Une liste d'URLs.\n    \"\"\"\n    url_flux = get_RSS_URL()\n\n    flux = feedparser.parse(url_flux)\n    urls = []\n    for entree in flux.entries:\n        for link in entree.links:\n            if link.type == \"audio/mpeg\":\n                if extraire_dureesummary(entree.summary) &gt; duree_mini_minutes * 60:\n                    urls.append(link.href)\n    return urls\n</code></pre>"},{"location":"rss/#rss.get_RSS_URL","title":"<code>get_RSS_URL()</code>","text":"<p>R\u00e9cup\u00e8re l'URL du flux RSS \u00e0 partir des variables d'environnement.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>L'URL du flux RSS. Si la variable d'environnement <code>RSS_LMELP_URL</code> n'est pas d\u00e9finie,</p> <code>str</code> <p>retourne une URL par d\u00e9faut.</p> Source code in <code>nbs/rss.py</code> <pre><code>def get_RSS_URL() -&gt; str:\n    \"\"\"\n    R\u00e9cup\u00e8re l'URL du flux RSS \u00e0 partir des variables d'environnement.\n\n    Returns:\n        str: L'URL du flux RSS. Si la variable d'environnement `RSS_LMELP_URL` n'est pas d\u00e9finie,\n        retourne une URL par d\u00e9faut.\n    \"\"\"\n    load_env()\n    RSS_LMELP_URL = os.getenv(\"RSS_LMELP_URL\")\n    if RSS_LMELP_URL is None:\n        RSS_LMELP_URL = \"https://radiofrance-podcast.net/podcast09/rss_14007.xml\"\n    return RSS_LMELP_URL\n</code></pre>"},{"location":"rss/#rss.load_env","title":"<code>load_env()</code>","text":"<p>Charge les variables d'environnement \u00e0 partir d'un fichier .env.</p> Source code in <code>nbs/rss.py</code> <pre><code>def load_env() -&gt; None:\n    \"\"\"\n    Charge les variables d'environnement \u00e0 partir d'un fichier .env.\n    \"\"\"\n    _ = load_dotenv(find_dotenv())\n</code></pre>"},{"location":"web/","title":"Module web","text":""},{"location":"web/#web.WebPage","title":"<code>WebPage</code>","text":"Source code in <code>nbs/web.py</code> <pre><code>class WebPage:\n    def __init__(self):\n        \"\"\"\n        Initialize the WebPage object.\n\n        This method reads the HTML content from the file specified by the\n        `WEB_LMELP_FILENAME` environment variable, parses it using BeautifulSoup,\n        and extracts information about the episodes.\n        \"\"\"\n        file_path = get_WEB_filename()\n\n        # Lire le contenu du fichier HTML\n        with open(file_path, \"r\", encoding=\"utf-8\") as file:\n            html_content = file.read()\n\n        # Analyser le contenu HTML avec BeautifulSoup\n        soup = BeautifulSoup(html_content, \"html.parser\")\n\n        # Extraire les informations des \u00e9pisodes\n        self.episodes: List[Dict[str, Any]] = []\n\n        # Rechercher les \u00e9l\u00e9ments contenant les informations des \u00e9pisodes\n        for item in soup.find_all(\"li\", class_=\"Collection-section-items-item\"):\n            title_element = item.find(\"span\", class_=\"CardTitle\")\n            link_element = item.find(\"a\", class_=\"underline-hover\")\n            description_element = item.find(\"div\", class_=\"CardDescription\")\n            date_elements = item.find(\n                \"div\", class_=\"DefaultDetails-secondLine\"\n            ).find_all(\"p\")\n\n            if (\n                title_element\n                and link_element\n                and description_element\n                and len(date_elements) &gt;= 3\n            ):\n                title = title_element.get_text(strip=True)\n                url = link_element[\"href\"]\n                description = description_element.get_text(strip=True)\n                date = date_elements[0].get_text(strip=True)\n                duration = date_elements[2].get_text(strip=True)\n\n                self.episodes.append(\n                    {\n                        \"title\": title,\n                        \"url\": url,\n                        \"description\": description,\n                        \"date\": date,\n                        \"duration\": duration,\n                    }\n                )\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the WebPage object.\n\n        Returns:\n            str: A string containing the details of all episodes.\n        \"\"\"\n        output = \"\"\n        for episode in self.episodes:\n            output += f\"\"\"\nTitle: {episode['title']}\nURL: {episode['url']}\nDescription: {episode['description']}\nDate: {episode['date']}\nDuration: {episode['duration']}\n\n            \"\"\"\n        return output\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the WebPage object for debugging.\n\n        Returns:\n            str: A string containing the details of all episodes.\n        \"\"\"\n        return self.__str__()\n\n    def __getitem__(self, index: int) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get an episode by its index.\n\n        Args:\n            index (int): The index of the episode to retrieve.\n\n        Returns:\n            dict: A dictionary containing the details of the episode.\n        \"\"\"\n        return self.episodes[index]\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Get the number of episodes.\n\n        Returns:\n            int: The number of episodes.\n        \"\"\"\n        return len(self.episodes)\n</code></pre>"},{"location":"web/#web.WebPage.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get an episode by its index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the episode to retrieve.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing the details of the episode.</p> Source code in <code>nbs/web.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get an episode by its index.\n\n    Args:\n        index (int): The index of the episode to retrieve.\n\n    Returns:\n        dict: A dictionary containing the details of the episode.\n    \"\"\"\n    return self.episodes[index]\n</code></pre>"},{"location":"web/#web.WebPage.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the WebPage object.</p> <p>This method reads the HTML content from the file specified by the <code>WEB_LMELP_FILENAME</code> environment variable, parses it using BeautifulSoup, and extracts information about the episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize the WebPage object.\n\n    This method reads the HTML content from the file specified by the\n    `WEB_LMELP_FILENAME` environment variable, parses it using BeautifulSoup,\n    and extracts information about the episodes.\n    \"\"\"\n    file_path = get_WEB_filename()\n\n    # Lire le contenu du fichier HTML\n    with open(file_path, \"r\", encoding=\"utf-8\") as file:\n        html_content = file.read()\n\n    # Analyser le contenu HTML avec BeautifulSoup\n    soup = BeautifulSoup(html_content, \"html.parser\")\n\n    # Extraire les informations des \u00e9pisodes\n    self.episodes: List[Dict[str, Any]] = []\n\n    # Rechercher les \u00e9l\u00e9ments contenant les informations des \u00e9pisodes\n    for item in soup.find_all(\"li\", class_=\"Collection-section-items-item\"):\n        title_element = item.find(\"span\", class_=\"CardTitle\")\n        link_element = item.find(\"a\", class_=\"underline-hover\")\n        description_element = item.find(\"div\", class_=\"CardDescription\")\n        date_elements = item.find(\n            \"div\", class_=\"DefaultDetails-secondLine\"\n        ).find_all(\"p\")\n\n        if (\n            title_element\n            and link_element\n            and description_element\n            and len(date_elements) &gt;= 3\n        ):\n            title = title_element.get_text(strip=True)\n            url = link_element[\"href\"]\n            description = description_element.get_text(strip=True)\n            date = date_elements[0].get_text(strip=True)\n            duration = date_elements[2].get_text(strip=True)\n\n            self.episodes.append(\n                {\n                    \"title\": title,\n                    \"url\": url,\n                    \"description\": description,\n                    \"date\": date,\n                    \"duration\": duration,\n                }\n            )\n</code></pre>"},{"location":"web/#web.WebPage.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of episodes.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of episodes.\n\n    Returns:\n        int: The number of episodes.\n    \"\"\"\n    return len(self.episodes)\n</code></pre>"},{"location":"web/#web.WebPage.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the WebPage object for debugging.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing the details of all episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the WebPage object for debugging.\n\n    Returns:\n        str: A string containing the details of all episodes.\n    \"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"web/#web.WebPage.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the WebPage object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing the details of all episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the WebPage object.\n\n        Returns:\n            str: A string containing the details of all episodes.\n        \"\"\"\n        output = \"\"\n        for episode in self.episodes:\n            output += f\"\"\"\nTitle: {episode['title']}\nURL: {episode['url']}\nDescription: {episode['description']}\nDate: {episode['date']}\nDuration: {episode['duration']}\n\n            \"\"\"\n        return output\n</code></pre>"},{"location":"web/#web.get_WEB_filename","title":"<code>get_WEB_filename()</code>","text":"<p>Get the filename of the WEB_LMELP file.</p> <p>This function loads environment variables and retrieves the value of the <code>WEB_LMELP_FILENAME</code> environment variable. If the variable is not set, it returns a default file path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The filename of the WEB_LMELP file.</p> Source code in <code>nbs/web.py</code> <pre><code>def get_WEB_filename() -&gt; str:\n    \"\"\"\n    Get the filename of the WEB_LMELP file.\n\n    This function loads environment variables and retrieves the value of the\n    `WEB_LMELP_FILENAME` environment variable. If the variable is not set,\n    it returns a default file path.\n\n    Returns:\n        str: The filename of the WEB_LMELP file.\n    \"\"\"\n    load_env()\n\n    WEB_LMELP_FILENAME = os.getenv(\"WEB_LMELP_FILENAME\")\n    if WEB_LMELP_FILENAME is None:\n        WEB_LMELP_FILENAME = \"/home/guillaume/git/lmelp/db/\u00c0 \u00e9couter plus tard I Radio France/\u00c0 \u00e9couter plus tard I Radio France.html\"\n    return WEB_LMELP_FILENAME\n</code></pre>"},{"location":"web/#web.load_env","title":"<code>load_env()</code>","text":"<p>Load environment variables from a .env file.</p> <p>This function uses the <code>dotenv</code> library to load environment variables from a .env file located in the current working directory or any parent directory.</p> Source code in <code>nbs/web.py</code> <pre><code>def load_env() -&gt; None:\n    \"\"\"\n    Load environment variables from a .env file.\n\n    This function uses the `dotenv` library to load environment variables\n    from a .env file located in the current working directory or any parent directory.\n    \"\"\"\n    _ = load_dotenv(find_dotenv())\n</code></pre>"},{"location":"whisper/","title":"Module whisper","text":""},{"location":"whisper/#whisper.extract_whisper","title":"<code>extract_whisper(audio_filename)</code>","text":"<p>Extrait la transcription d'un fichier audio en utilisant le mod\u00e8le Whisper.</p> <p>Parameters:</p> Name Type Description Default <code>audio_filename</code> <code>str</code> <p>Le chemin du fichier audio \u00e0 transcrire.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La transcription du fichier audio.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def extract_whisper(audio_filename: str) -&gt; str:\n    \"\"\"\n    Extrait la transcription d'un fichier audio en utilisant le mod\u00e8le Whisper.\n\n    Args:\n        audio_filename (str): Le chemin du fichier audio \u00e0 transcrire.\n\n    Returns:\n        str: La transcription du fichier audio.\n    \"\"\"\n    device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n    torch_dtype = torch.float16 if torch.cuda.is_available() else torch.float32\n\n    model_id = \"openai/whisper-large-v3-turbo\"\n\n    model = AutoModelForSpeechSeq2Seq.from_pretrained(\n        model_id, torch_dtype=torch_dtype, low_cpu_mem_usage=True, use_safetensors=True\n    )\n    model.to(device)\n\n    processor = AutoProcessor.from_pretrained(model_id)\n\n    generate_kwargs = {\n        \"language\": \"french\",\n    }\n\n    pipe = pipeline(\n        \"automatic-speech-recognition\",\n        model=model,\n        tokenizer=processor.tokenizer,\n        feature_extractor=processor.feature_extractor,\n        torch_dtype=torch_dtype,\n        device=device,\n        chunk_length_s=30,\n        batch_size=16,  # batch size for inference - set based on your device\n        generate_kwargs=generate_kwargs,\n    )\n\n    dataset = load_dataset(\n        \"distil-whisper/librispeech_long\", \"clean\", split=\"validation\"\n    )\n    sample = dataset[0][\"audio\"]\n\n    result = pipe(\n        audio_filename,\n        return_timestamps=True,\n    )\n\n    return result[\"text\"]\n</code></pre>"},{"location":"whisper/#whisper.list_audio_files","title":"<code>list_audio_files(audio_path=AUDIO_PATH)</code>","text":"<p>Liste tous les fichiers audio (MP3 et M4A) dans le r\u00e9pertoire sp\u00e9cifi\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>audio_path</code> <code>str</code> <p>Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.</p> <code>AUDIO_PATH</code> <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>Une liste des chemins de fichiers audio (MP3 et M4A) trouv\u00e9s.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def list_audio_files(audio_path=AUDIO_PATH) -&gt; List[str]:\n    \"\"\"\n    Liste tous les fichiers audio (MP3 et M4A) dans le r\u00e9pertoire sp\u00e9cifi\u00e9.\n\n    Args:\n        audio_path (str): Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.\n\n    Returns:\n        list: Une liste des chemins de fichiers audio (MP3 et M4A) trouv\u00e9s.\n    \"\"\"\n    fullpath = get_audio_path(audio_path, year=\"\")\n\n    mp3_files = glob.glob(os.path.join(fullpath, \"**/*.mp3\"), recursive=True)\n    m4a_files = glob.glob(os.path.join(fullpath, \"**/*.m4a\"), recursive=True)\n\n    return mp3_files + m4a_files\n</code></pre>"},{"location":"whisper/#whisper.list_mp3_files","title":"<code>list_mp3_files(audio_path=AUDIO_PATH)</code>","text":"<p>Liste tous les fichiers MP3 dans le r\u00e9pertoire sp\u00e9cifi\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>audio_path</code> <code>str</code> <p>Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.</p> <code>AUDIO_PATH</code> <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>Une liste des chemins de fichiers MP3 trouv\u00e9s.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def list_mp3_files(audio_path=AUDIO_PATH) -&gt; List[str]:\n    \"\"\"\n    Liste tous les fichiers MP3 dans le r\u00e9pertoire sp\u00e9cifi\u00e9.\n\n    Args:\n        audio_path (str): Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.\n\n    Returns:\n        list: Une liste des chemins de fichiers MP3 trouv\u00e9s.\n    \"\"\"\n    fullpath = get_audio_path(audio_path, year=\"\")\n    return glob.glob(os.path.join(fullpath, \"**/*.mp3\"), recursive=True)\n</code></pre>"},{"location":"whisper/#whisper.store_whisper_in_db","title":"<code>store_whisper_in_db(whisper, collection, oid, force=False, verbose=False)</code>","text":"<p>Stocke la transcription Whisper dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>whisper</code> <code>str</code> <p>La transcription du fichier audio.</p> required <code>collection</code> <code>Collection</code> <p>La collection pymongo.</p> required <code>oid</code> <code>str</code> <p>L'identifiant de l'\u00e9pisode.</p> required <code>force</code> <code>bool</code> <p>Si True, \u00e9crase le Whisper existant. Par d\u00e9faut, False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Si True, affiche des messages d\u00e9taill\u00e9s. Par d\u00e9faut, False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si le Whisper a \u00e9t\u00e9 stock\u00e9, False sinon.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def store_whisper_in_db(\n    whisper: str,\n    collection: pymongo.collection.Collection,\n    oid: str,\n    force: bool = False,\n    verbose: bool = False,\n) -&gt; bool:\n    \"\"\"\n    Stocke la transcription Whisper dans la base de donn\u00e9es.\n\n    Args:\n        whisper (str): La transcription du fichier audio.\n        collection: La collection pymongo.\n        oid (str): L'identifiant de l'\u00e9pisode.\n        force (bool, optional): Si True, \u00e9crase le Whisper existant. Par d\u00e9faut, False.\n        verbose (bool, optional): Si True, affiche des messages d\u00e9taill\u00e9s. Par d\u00e9faut, False.\n\n    Returns:\n        bool: True si le Whisper a \u00e9t\u00e9 stock\u00e9, False sinon.\n    \"\"\"\n    # R\u00e9cup\u00e9ration du document\n    document_entry = collection.find_one({\"_id\": ObjectId(oid)})\n\n    if document_entry is None:\n        if verbose:\n            print(f\"Document avec l'oid {oid} non trouv\u00e9\")\n        return False\n\n    if \"whisper\" in document_entry and not force:\n        if verbose:\n            print(\n                f\"Whisper d\u00e9j\u00e0 stock\u00e9 pour l'oid {oid}, et on ne force pas le stockage\"\n            )\n        return False\n    else:\n        document_entry[\"whisper\"] = whisper\n        collection.update_one({\"_id\": ObjectId(oid)}, {\"$set\": document_entry})\n        if verbose:\n            print(f\"Whisper stock\u00e9 pour l'oid {oid}\")\n        return True\n</code></pre>"}]}