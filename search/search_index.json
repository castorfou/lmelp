{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>Here is the <code>README.md</code> of this project</p> <ul> <li>pour developper \ud83d\udcbb</li> <li>environnements de dev python \ud83d\udc0d</li> <li>pre-commit \u23f1\ufe0f</li> <li>config vscode \ud83d\udda5\ufe0f</li> <li>tests unitaires \ud83e\uddea</li> <li>\ud83d\ude00 \u00e0 propos de la doc</li> <li>pour utiliser \ud83d\ude80</li> <li>\ud83d\udcbe base de donn\u00e9es mongodb</li> <li>ffmpeg \ud83c\udf9e\ufe0f</li> <li>locale FR \ud83c\uddeb\ud83c\uddf7</li> <li>ulimit \u2699\ufe0f</li> <li><code>.env</code> \ud83c\udf10<ul> <li>rss info \ud83c\udf99\ufe0f</li> <li>web info \ud83c\udf0d</li> <li>db info \ud83d\uddc4\ufe0f</li> <li>llm, llamaindex, litellm \ud83e\udd16</li> <li>websearch</li> </ul> </li> <li>streamlit \ud83d\uddb1\ufe0f</li> </ul>"},{"location":"#pour-developper","title":"pour developper \ud83d\udcbb","text":""},{"location":"#environnements-de-dev-python","title":"environnements de dev python \ud83d\udc0d","text":"<p>vscode utilisera automatiquement le devcontainer definit dans le repo sous <code>.devcontainer</code></p> <p>je garde quand meme le script de creation d'environnement whisper depuis <code>envs/whisper.txt</code> \u2728  qui contient ce qu il faut pour whisper, feedparser, transformers (huggingface), dotenv, mongo, streamlit \ud83d\udee0\ufe0f</p>"},{"location":"#pre-commit","title":"pre-commit \u23f1\ufe0f","text":"<p>dans devcontainer, pre-commit est deja configure sinon</p> <p><code>pre-commit install</code> \u2705</p>"},{"location":"#config-vscode","title":"config vscode \ud83d\udda5\ufe0f","text":"<p>en cas de message <code>\"Visual Studio Code is unable to watch for file changes in this large workspace\" (error ENOSPC)</code> see vscode linux page \u26a0\ufe0f</p> <pre><code># add fs.inotify.max_user_watches=524288 to /etc/sysctl.d/99-custom-inotify.conf\nsudo sysctl -p # to apply directly\ncat /proc/sys/fs/inotify/max_user_watches # to control it is applied\n</code></pre> <p>or add <code>files.watcherExclude</code> directive in <code>.vscode/settings.json</code> \ud83d\udcc1</p> <p>pour quelques astuces li\u00e9es \u00e0 vscode : Vscode hints (sur github pages)</p>"},{"location":"#tests-unitaires","title":"tests unitaires \ud83e\uddea","text":"<p>Le projet utilise pytest pour les tests unitaires avec une couverture de code \u00e9lev\u00e9e.</p> <p>Infrastructure CI/CD : - \u2705 GitHub Actions : Tests automatiques sur chaque push/PR - \u2705 D\u00e9pendances optimis\u00e9es : <code>tests/requirements.txt</code> (sans PyTorch/ML) - \u2705 Mocking avanc\u00e9 : torch, transformers, dbus mock\u00e9s pour CI/CD - \u2705 Coverage 72%+ : Couverture actuelle avec 214 tests - \u2705 Linting automatique : flake8, black, isort</p> <pre><code># Lancer tous les tests\npytest\n\n# Tests avec couverture \npytest --cov=nbs --cov-report=term-missing\n\n# Tests sp\u00e9cifiques\npytest tests/unit/test_config.py -v\n</code></pre> <p>Structure des tests : - <code>tests/unit/</code> : Tests unitaires par module - <code>tests/fixtures/</code> : Donn\u00e9es de test et utilitaires - <code>tests/requirements.txt</code> : D\u00e9pendances minimales pour tests - <code>tests/conftest.py</code> : Configuration et fixtures globales - <code>.env.test</code> : Variables d'environnement de test - <code>.github/workflows/tests.yml</code> : CI/CD GitHub Actions</p> <p>Documentation compl\u00e8te : Guide des tests unitaires \ud83d\udccb</p>"},{"location":"#a-propos-de-la-doc","title":"\ud83d\ude00 \u00e0 propos de la doc","text":"<p>on change la doc depuis <code>docs</code> (g\u00e9nie) \ud83d\ude0a</p> <ul> <li>APIs \ud83d\ude80</li> <li>Quelques astuces ou choix de conception \ud83d\udd0d</li> </ul> <p>Mkdocs+github actions ramasse tout cela (branche main uniquement) et publie sur le github pages du projet \ud83d\udce6</p> <p>Expliqu\u00e9 \u00e0 https://castorfou.github.io/lmelp/readme_doc/ \ud83d\udc4d</p>"},{"location":"#pour-utiliser","title":"pour utiliser \ud83d\ude80","text":""},{"location":"#base-de-donnees-mongodb","title":"\ud83d\udcbe base de donn\u00e9es mongodb","text":"<p>mongodb est utilis\u00e9e pour conserver toutes les donn\u00e9es de l'application (voir sch\u00e9ma). \ud83d\udcca pour conserver une sauvegarde de la base, lancer depuis devcontainer <code>scripts/backup_mongodb.sh</code> \ud83d\ude80</p> <p>si les liens ont \u00e9t\u00e9 faits dans <code>~/bin/lmelp</code>, alors lancer depuis host <code>~/bin/lmelp/backup_mongodb.sh</code></p> <p>penser \u00e0 le faire r\u00e9guili\u00e9rement, il n'y a aucun rappel.</p>"},{"location":"#ffmpeg","title":"ffmpeg \ud83c\udf9e\ufe0f","text":"<p>ffmpeg is required to load audio files from filename for whisper use (transcription d'un mp3) \ud83c\udfa7</p> <p>install, it is available in snap (4.3.1) \ud83d\udce6</p>"},{"location":"#locale-fr","title":"locale FR \ud83c\uddeb\ud83c\uddf7","text":"<p>en cas d'erreur de type <code>locale.Error: unsupported locale setting</code> \u2757</p> <p>verifier avec <code>locale -a</code> que <code>fr_FR.UTF-8</code> soit install\u00e9e. \ud83d\udd0d</p> <p>Sinon le faire avec </p> <pre><code>sudo apt-get install language-pack-fr-base\nlocale -a\n</code></pre>"},{"location":"#ulimit","title":"ulimit \u2699\ufe0f","text":"<p>j'ai du augmenter l'ulimit de mon systeme pour utiliser whisper pour eviter l'erreur <code>Too many open files</code> \ud83d\udeab</p> <p>Avec ce parametre je n'ai plus le probleme: <code>ulimit -n 4096</code> \u2714\ufe0f Je l'ai ajoute dans <code>.zshrc</code> \ud83d\udcdd</p>"},{"location":"#env","title":"<code>.env</code> \ud83c\udf10","text":"<p>https://pypi.org/project/python-dotenv/ \ud83d\udca1</p> <p>Python-dotenv reads key-value pairs from a .env file and can set them as environment variables. It helps in the development of applications following the 12-factor principles. \ud83d\udccb</p> <p>creer <code>.env</code> \u00e0 la racine du repo avec \ud83c\udfd7\ufe0f</p>"},{"location":"#rss-info","title":"rss info \ud83c\udf99\ufe0f","text":"<p>L'adresse du flux RSS du podcast du Masque et la Plume \ud83c\udfa7</p> <p>si absent <code>https://radiofrance-podcast.net/podcast09/rss_14007.xml</code> est utilis\u00e9 par defaut \ud83d\udd04  </p> <pre><code>RSS_LMELP_URL=https://radiofrance-podcast.net/podcast09/rss_14007.xml\n</code></pre>"},{"location":"#web-info","title":"web info \ud83c\udf0d","text":"<p>Le lien vers la page web stockee du masque listant les episodes \"legacy\" historiques \ud83d\udcdc</p> <p>si absent <code>db/\u00c0 \u00e9couter plus tard I Radio France/\u00c0 \u00e9couter plus tard I Radio France.html</code> est utilis\u00e9 par defaut \ud83d\udd04  </p> <pre><code>WEB_LMELP_FILENAME=db/\u00c0 \u00e9couter plus tard I Radio France/\u00c0 \u00e9couter plus tard I Radio France.html\n</code></pre>"},{"location":"#db-info","title":"db info \ud83d\uddc4\ufe0f","text":"<p>pour tout ce qui concerne la base mongo \ud83d\udee2\ufe0f</p> <pre><code>DB_HOST=localhost # \u00e0 changer avec nas923 par exemple\nDB_NAME=\"masque_et_la_plume\"\nDB_LOGS=true # si pr\u00e9sent et valant true, va enregistrer toutes les operations dans la collection logs\n</code></pre>"},{"location":"#llm-llamaindex-litellm","title":"llm, llamaindex, litellm \ud83e\udd16","text":"<pre><code># gemini \nGEMINI_API_KEY=\n# gemini vertex\nGOOGLE_PROJECT_ID=\nGOOGLE_AUTH_FILE=\n\n# openai\nOPENAI_API_KEY=\n\n# azure openai\nAZURE_API_KEY=\nAZURE_ENDPOINT=\nAZURE_API_VERSION=\n</code></pre> <p>gemini llm, GEMINI_API_KEY dispo \u00e0 \ud83d\ude80</p> <p>from https://console.cloud.google.com/apis/credentials \ud83d\udd11</p> <p>gemini vertex (llamaindex), GOOGLE_PROJECT_ID \ud83e\udded</p> <p>from https://console.cloud.google.com \ud83c\udf10</p> <p>gemini vertex (llamaindex), GOOGLE_AUTH_FILE \ud83d\udcc2</p> <p>follow instructions at https://stackoverflow.com/a/69941050 \ud83d\udcd8</p> <p>Et pour les modeles locaux LiteLLM</p> <pre><code>LITELLM_API_KEY\n</code></pre>"},{"location":"#websearch","title":"websearch","text":"<p>We need these 2 keys.</p> <pre><code>\nSEARCH_ENGINE_ID\n</code></pre> <p>more details at readme Google</p>"},{"location":"#streamlit","title":"streamlit \ud83d\uddb1\ufe0f","text":"<p>3 ways to run it: from vscode, from devcontainer, from host</p> <p>from vscode: palette &gt; run task &gt; run streamlit \ud83d\ude80</p> <p>from devcontainer terminal: <code>ui/lmelp_ui.sh</code> \u26a1</p> <p>from host terminal: </p> <pre><code>#!/bin/bash \n\nsource ~/git/lmelp/scripts/from_host/get_container.sh\n\ncontainer=$(get_container)\necho \"Using container: $container\"\n\n# Execute the UI script in the found container as the user vscode.\ndocker exec -u vscode \"$container\" /workspaces/lmelp/ui/lmelp_ui.sh\n</code></pre>"},{"location":"config/","title":"Module config","text":""},{"location":"config/#config.get_DB_VARS","title":"<code>get_DB_VARS()</code>","text":"<p>Retrieve the database configuration variables from the environment.</p> <p>This function loads the environment variables and retrieves the following database configuration variables:     - DB_HOST: The hostname for the database.     - DB_NAME: The name of the database.     - DB_LOGS: A flag indicating if logging is enabled.</p> <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str], Optional[str]]</code> <p>Tuple[Optional[str], Optional[str], Optional[str]]: A tuple containing (DB_HOST, DB_NAME, DB_LOGS).</p> Source code in <code>nbs/config.py</code> <pre><code>def get_DB_VARS() -&gt; Tuple[Optional[str], Optional[str], Optional[str]]:\n    \"\"\"Retrieve the database configuration variables from the environment.\n\n    This function loads the environment variables and retrieves the following\n    database configuration variables:\n        - DB_HOST: The hostname for the database.\n        - DB_NAME: The name of the database.\n        - DB_LOGS: A flag indicating if logging is enabled.\n\n    Returns:\n        Tuple[Optional[str], Optional[str], Optional[str]]:\n            A tuple containing (DB_HOST, DB_NAME, DB_LOGS).\n    \"\"\"\n    load_env()\n    DB_HOST: Optional[str] = os.getenv(\"DB_HOST\")\n    DB_NAME: Optional[str] = os.getenv(\"DB_NAME\")\n    DB_LOGS: Optional[str] = os.getenv(\"DB_LOGS\")\n    return DB_HOST, DB_NAME, DB_LOGS\n</code></pre>"},{"location":"config/#config.get_RSS_URL","title":"<code>get_RSS_URL()</code>","text":"<p>R\u00e9cup\u00e8re l'URL du flux RSS \u00e0 partir des variables d'environnement.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>L'URL du flux RSS. Si la variable d'environnement <code>RSS_LMELP_URL</code> n'est pas d\u00e9finie,</p> <code>str</code> <p>retourne une URL par d\u00e9faut.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_RSS_URL() -&gt; str:\n    \"\"\"\n    R\u00e9cup\u00e8re l'URL du flux RSS \u00e0 partir des variables d'environnement.\n\n    Returns:\n        str: L'URL du flux RSS. Si la variable d'environnement `RSS_LMELP_URL` n'est pas d\u00e9finie,\n        retourne une URL par d\u00e9faut.\n    \"\"\"\n    load_env()\n    RSS_LMELP_URL = os.getenv(\"RSS_LMELP_URL\")\n    if RSS_LMELP_URL is None:\n        RSS_LMELP_URL = \"https://radiofrance-podcast.net/podcast09/rss_14007.xml\"\n    return RSS_LMELP_URL\n</code></pre>"},{"location":"config/#config.get_WEB_filename","title":"<code>get_WEB_filename()</code>","text":"<p>Get the filename of the WEB_LMELP file.</p> <p>This function loads environment variables and retrieves the value of the <code>WEB_LMELP_FILENAME</code> environment variable. If the variable is not set, it returns a default file path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The filename of the WEB_LMELP file.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_WEB_filename() -&gt; str:\n    \"\"\"\n    Get the filename of the WEB_LMELP file.\n\n    This function loads environment variables and retrieves the value of the\n    `WEB_LMELP_FILENAME` environment variable. If the variable is not set,\n    it returns a default file path.\n\n    Returns:\n        str: The filename of the WEB_LMELP file.\n    \"\"\"\n    load_env()\n\n    WEB_LMELP_FILENAME = os.getenv(\"WEB_LMELP_FILENAME\")\n    if WEB_LMELP_FILENAME is None:\n        WEB_LMELP_FILENAME = \"db/\u00c0 \u00e9couter plus tard I Radio France/\u00c0 \u00e9couter plus tard I Radio France.html\"\n\n    return str(Path(get_git_root(\"\"), WEB_LMELP_FILENAME))\n</code></pre>"},{"location":"config/#config.get_audio_path","title":"<code>get_audio_path(audio_path=AUDIO_PATH, year='2024')</code>","text":"<p>Returns the full path to the audio files by appending the year as a subdirectory.</p> <p>If the directory does not exist, it is created.</p> <p>Parameters:</p> Name Type Description Default <code>audio_path</code> <code>str</code> <p>Relative path to the audio files.</p> <code>AUDIO_PATH</code> <code>year</code> <code>str</code> <p>The year used as a subdirectory (default \"2024\").</p> <code>'2024'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the corresponding audio directory.</p> Example <p>path = get_audio_path(\"audios\", \"2024\")</p> Source code in <code>nbs/config.py</code> <pre><code>def get_audio_path(audio_path: str = AUDIO_PATH, year: str = \"2024\") -&gt; str:\n    \"\"\"Returns the full path to the audio files by appending the year as a subdirectory.\n\n    If the directory does not exist, it is created.\n\n    Args:\n        audio_path (str): Relative path to the audio files.\n        year (str): The year used as a subdirectory (default \"2024\").\n\n    Returns:\n        str: The full path to the corresponding audio directory.\n\n    Example:\n        &gt;&gt;&gt; path = get_audio_path(\"audios\", \"2024\")\n    \"\"\"\n\n    project_root: str = get_git_root(os.getcwd())\n    full_audio_path: str = os.path.join(project_root, audio_path, year)\n\n    # Create the directory if it does not exist\n    if not os.path.exists(full_audio_path):\n        os.makedirs(full_audio_path)\n\n    return full_audio_path\n</code></pre>"},{"location":"config/#config.get_azure_openai_keys","title":"<code>get_azure_openai_keys()</code>","text":"<p>Get the Azure OpenAI keys from environment variables.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[str, str, str]</code> <p>A tuple containing the Azure API key, endpoint, and API version.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_azure_openai_keys() -&gt; tuple[str, str, str]:\n    \"\"\"\n    Get the Azure OpenAI keys from environment variables.\n\n    Returns:\n        tuple: A tuple containing the Azure API key, endpoint, and API version.\n    \"\"\"\n    load_env()\n    azure_api_key = os.getenv(\"AZURE_API_KEY\")\n    azure_endpoint = os.getenv(\"AZURE_ENDPOINT\")\n    azure_api_version = os.getenv(\"AZURE_API_VERSION\")\n    return azure_api_key, azure_endpoint, azure_api_version\n</code></pre>"},{"location":"config/#config.get_gemini_api_key","title":"<code>get_gemini_api_key()</code>","text":"<p>Get the Gemini API key from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Gemini API key.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_gemini_api_key() -&gt; str:\n    \"\"\"\n    Get the Gemini API key from environment variables.\n\n    Returns:\n        str: The Gemini API key.\n    \"\"\"\n    load_env()\n    gemini_api_key = os.getenv(\"GEMINI_API_KEY\")\n    return gemini_api_key\n</code></pre>"},{"location":"config/#config.get_git_root","title":"<code>get_git_root(path)</code>","text":"<p>Retrieves the root directory of the Git repository.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The current working directory.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The root directory of the Git repository.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_git_root(path: str) -&gt; str:\n    \"\"\"Retrieves the root directory of the Git repository.\n\n    Args:\n        path (str): The current working directory.\n\n    Returns:\n        str: The root directory of the Git repository.\n    \"\"\"\n    git_repo = Repo(path, search_parent_directories=True)\n    return git_repo.git.rev_parse(\"--show-toplevel\")\n</code></pre>"},{"location":"config/#config.get_google_auth_file","title":"<code>get_google_auth_file()</code>","text":"<p>Get the Google authentication file path from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the Google authentication file.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_google_auth_file() -&gt; str:\n    \"\"\"\n    Get the Google authentication file path from environment variables.\n\n    Returns:\n        str: The path to the Google authentication file.\n    \"\"\"\n    load_env()\n    google_auth_file = os.getenv(\"GOOGLE_AUTH_FILE\")\n    return google_auth_file\n</code></pre>"},{"location":"config/#config.get_google_projectID","title":"<code>get_google_projectID()</code>","text":"<p>Get the Google Project ID from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Google Project ID.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_google_projectID() -&gt; str:\n    \"\"\"\n    Get the Google Project ID from environment variables.\n\n    Returns:\n        str: The Google Project ID.\n    \"\"\"\n    load_env()\n    google_projectID = os.getenv(\"GOOGLE_PROJECT_ID\")\n    return google_projectID\n</code></pre>"},{"location":"config/#config.get_openai_api_key","title":"<code>get_openai_api_key()</code>","text":"<p>Get the OpenAI API key from environment variables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The OpenAI API key.</p> Source code in <code>nbs/config.py</code> <pre><code>def get_openai_api_key() -&gt; str:\n    \"\"\"\n    Get the OpenAI API key from environment variables.\n\n    Returns:\n        str: The OpenAI API key.\n    \"\"\"\n    load_env()\n    openai_api_key = os.getenv(\"OPENAI_API_KEY\")\n    return openai_api_key\n</code></pre>"},{"location":"config/#config.load_env","title":"<code>load_env()</code>","text":"<p>Charge les variables d'environnement \u00e0 partir d'un fichier .env.</p> Source code in <code>nbs/config.py</code> <pre><code>def load_env() -&gt; None:\n    \"\"\"\n    Charge les variables d'environnement \u00e0 partir d'un fichier .env.\n    \"\"\"\n    _ = load_dotenv(find_dotenv())\n</code></pre>"},{"location":"llm/","title":"Module llm","text":""},{"location":"llm/#llm.get_azure_llm","title":"<code>get_azure_llm(engine='gpt-4o')</code>","text":"<p>Get the Azure OpenAI language model.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>str</code> <p>The engine to use for the Azure OpenAI model. Default is \"gpt-4o\".</p> <code>'gpt-4o'</code> <p>Returns:</p> Name Type Description <code>AzureOpenAI</code> <code>AzureOpenAI</code> <p>An instance of the AzureOpenAI language model.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_azure_llm(engine=\"gpt-4o\") -&gt; AzureOpenAI:\n    \"\"\"\n    Get the Azure OpenAI language model.\n\n    Args:\n        engine (str): The engine to use for the Azure OpenAI model. Default is \"gpt-4o\".\n\n    Returns:\n        AzureOpenAI: An instance of the AzureOpenAI language model.\n    \"\"\"\n    AZURE_API_KEY, AZURE_ENDPOINT, AZURE_API_VERSION = get_azure_openai_keys()\n    llm = AzureOpenAI(\n        engine=engine,\n        api_key=AZURE_API_KEY,\n        azure_endpoint=AZURE_ENDPOINT,\n        api_version=AZURE_API_VERSION,\n        # increase timeout to 300 seconds (5 minutes) to avoid timeout on long transcriptions\n        timeout=300.0,\n    )\n    Settings.llm = llm\n    return llm\n</code></pre>"},{"location":"llm/#llm.get_gemini_llm","title":"<code>get_gemini_llm(model='gemini-1.5-flash')</code>","text":"<p>Get the Gemini language model.</p> <p>This function configures the Gemini API using the API key obtained from the environment variables and returns an instance of the GenerativeModel.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use for the Gemini language model. Default is \"gemini-1.5-flash\".</p> <code>'gemini-1.5-flash'</code> <p>Returns:</p> Name Type Description <code>GenerativeModel</code> <code>GenerativeModel</code> <p>An instance of the GenerativeModel.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_gemini_llm(model=\"gemini-1.5-flash\") -&gt; genai.GenerativeModel:\n    \"\"\"\n    Get the Gemini language model.\n\n    This function configures the Gemini API using the API key obtained from the environment variables\n    and returns an instance of the GenerativeModel.\n\n    Args:\n        model (str): The model to use for the Gemini language model. Default is \"gemini-1.5-flash\".\n\n    Returns:\n        GenerativeModel: An instance of the GenerativeModel.\n    \"\"\"\n    genai.configure(api_key=get_gemini_api_key())\n    llm = genai.GenerativeModel(model)\n    return llm\n</code></pre>"},{"location":"llm/#llm.get_vertex_llm","title":"<code>get_vertex_llm(model='gemini-1.5-flash-001')</code>","text":"<p>Get the Vertex language model.</p> <p>This function configures the Vertex API using the project ID and API key obtained from the environment variables and returns an instance of the Vertex model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use for the Vertex language model. Default is \"gemini-1.5-flash-001\".</p> <code>'gemini-1.5-flash-001'</code> <p>Returns:</p> Name Type Description <code>Vertex</code> <code>Vertex</code> <p>An instance of the Vertex language model.</p> Source code in <code>nbs/llm.py</code> <pre><code>def get_vertex_llm(model=\"gemini-1.5-flash-001\") -&gt; Vertex:\n    \"\"\"\n    Get the Vertex language model.\n\n    This function configures the Vertex API using the project ID and API key obtained from the environment variables\n    and returns an instance of the Vertex model.\n\n    Args:\n        model (str): The model to use for the Vertex language model. Default is \"gemini-1.5-flash-001\".\n\n    Returns:\n        Vertex: An instance of the Vertex language model.\n    \"\"\"\n    # Set up necessary variables\n    credentials = {\n        \"project_id\": get_google_projectID(),\n        \"api_key\": get_gemini_api_key(),\n    }\n\n    # filename = get_google_auth_file()\n    # credentials_service: service_account.Credentials = (\n    #     service_account.Credentials.from_service_account_file(filename)\n    # )\n\n    # Create an instance of the Vertex class\n    llm = Vertex(\n        model=model,\n        project=credentials[\"project_id\"],\n        credentials=credentials,\n        context_window=100000,\n    )\n    # llm = Vertex(\n    #     model=model,\n    #     project=credentials_service.project_id,\n    #     credentials=credentials_service,\n    #     context_window=100000,    )\n    Settings.llm = llm\n    return llm\n</code></pre>"},{"location":"mongo/","title":"Module mongo","text":""},{"location":"mongo/#mongo.BaseEntity","title":"<code>BaseEntity</code>","text":"Source code in <code>nbs/mongo.py</code> <pre><code>class BaseEntity:\n    def __init__(self, nom: str, collection_name: str) -&gt; None:\n        \"\"\"Initializes a new BaseEntity instance.\n\n        Args:\n            nom (str): The name of the entity.\n            collection_name (str): The name of the collection.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        self.nom = nom\n\n    def exists(self) -&gt; bool:\n        \"\"\"Checks if the entity exists in the database.\n\n        Returns:\n            bool: True if the entity exists, False otherwise.\n        \"\"\"\n        return self.collection.find_one({\"nom\": self.nom}) is not None\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        S\u00e9rialise l'instance en dictionnaire en excluant les attributs non d\u00e9sir\u00e9s.\n        On exclut ici 'collection' par exemple.\n        \"\"\"\n        # On r\u00e9cup\u00e8re l'ensemble des attributs de l'objet\n        data = self.__dict__.copy()\n        # On retire attributes non serialisables\n        data.pop(\"collection\", None)\n        return data\n\n    def keep(self) -&gt; None:\n        \"\"\"\n        Insert ou met \u00e0 jour l'entit\u00e9 dans la base.\n        Utilise la s\u00e9rialisation via to_dict() pour conserver tous les attributs serialisables.\n        \"\"\"\n        data = self.to_dict()\n        if not self.exists():\n            mongolog(\"insert\", self.collection.name, self.nom)\n            self.collection.insert_one(data)\n        else:\n            mongolog(\"update\", self.collection.name, self.nom)\n            self.collection.replace_one({\"nom\": self.nom}, data)\n\n    def remove(self) -&gt; None:\n        \"\"\"Removes the entity from the database.\"\"\"\n        self.collection.delete_one({\"nom\": self.nom})\n        mongolog(\"delete\", self.collection.name, self.nom)\n\n    def get_oid(self) -&gt; Optional[ObjectId]:\n        \"\"\"Retrieves the ObjectId of the entity from the database.\n\n        Returns:\n            Optional[ObjectId]: The ObjectId of the entity if found, otherwise None.\n        \"\"\"\n        document = self.collection.find_one({\"nom\": self.nom})\n        if document:\n            return document[\"_id\"]\n        else:\n            return None\n\n    @classmethod\n    def from_oid(cls: Type[T], oid: ObjectId) -&gt; T:\n        \"\"\"Creates an instance of the derived class from a MongoDB ObjectId.\n        Returns None if the ObjectId is not found in the database or is None.\n\n        Args:\n            oid (ObjectId): The MongoDB ObjectId.\n\n        Returns:\n            T: An instance of the derived class.\n        \"\"\"\n        if oid is None:\n            return None\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n        )\n        document = collection.find_one({\"_id\": oid})\n        if document is None:\n            return None\n        inst = cls(document.get(\"nom\"))\n        return inst\n\n    @classmethod\n    def get_entries(cls: Type[T], request: str = \"\") -&gt; List[T]:\n        \"\"\"Retrieves a list of entries matching the query.\n\n        Args:\n            request (str, optional): A substring of the name to filter results\n                (case-insensitive). Defaults to an empty string.\n\n        Returns:\n            List[T]: A list of instances of the derived class.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n        )\n        query = {\n            \"nom\": {\n                \"$regex\": request,\n                \"$options\": \"i\",\n            }\n        }\n        result = collection.find(query)\n        list_baseentity = [cls.from_oid(entry.get(\"_id\")) for entry in result]\n        return list_baseentity\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Official string representation of the entity.\n\n        Returns:\n            str: The name of the entity.\n        \"\"\"\n        return self.nom\n\n    def __str__(self) -&gt; str:\n        \"\"\"Informal string representation of the entity.\n\n        Returns:\n            str: The name of the entity.\n        \"\"\"\n        return self.nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.__init__","title":"<code>__init__(nom, collection_name)</code>","text":"<p>Initializes a new BaseEntity instance.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>The name of the entity.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def __init__(self, nom: str, collection_name: str) -&gt; None:\n    \"\"\"Initializes a new BaseEntity instance.\n\n    Args:\n        nom (str): The name of the entity.\n        collection_name (str): The name of the collection.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    self.nom = nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.__repr__","title":"<code>__repr__()</code>","text":"<p>Official string representation of the entity.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the entity.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Official string representation of the entity.\n\n    Returns:\n        str: The name of the entity.\n    \"\"\"\n    return self.nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.__str__","title":"<code>__str__()</code>","text":"<p>Informal string representation of the entity.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the entity.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Informal string representation of the entity.\n\n    Returns:\n        str: The name of the entity.\n    \"\"\"\n    return self.nom\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.exists","title":"<code>exists()</code>","text":"<p>Checks if the entity exists in the database.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the entity exists, False otherwise.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Checks if the entity exists in the database.\n\n    Returns:\n        bool: True if the entity exists, False otherwise.\n    \"\"\"\n    return self.collection.find_one({\"nom\": self.nom}) is not None\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.from_oid","title":"<code>from_oid(oid)</code>  <code>classmethod</code>","text":"<p>Creates an instance of the derived class from a MongoDB ObjectId. Returns None if the ObjectId is not found in the database or is None.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>ObjectId</code> <p>The MongoDB ObjectId.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the derived class.</p> Source code in <code>nbs/mongo.py</code> <pre><code>@classmethod\ndef from_oid(cls: Type[T], oid: ObjectId) -&gt; T:\n    \"\"\"Creates an instance of the derived class from a MongoDB ObjectId.\n    Returns None if the ObjectId is not found in the database or is None.\n\n    Args:\n        oid (ObjectId): The MongoDB ObjectId.\n\n    Returns:\n        T: An instance of the derived class.\n    \"\"\"\n    if oid is None:\n        return None\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n    )\n    document = collection.find_one({\"_id\": oid})\n    if document is None:\n        return None\n    inst = cls(document.get(\"nom\"))\n    return inst\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.get_entries","title":"<code>get_entries(request='')</code>  <code>classmethod</code>","text":"<p>Retrieves a list of entries matching the query.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>str</code> <p>A substring of the name to filter results (case-insensitive). Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>List[T]: A list of instances of the derived class.</p> Source code in <code>nbs/mongo.py</code> <pre><code>@classmethod\ndef get_entries(cls: Type[T], request: str = \"\") -&gt; List[T]:\n    \"\"\"Retrieves a list of entries matching the query.\n\n    Args:\n        request (str, optional): A substring of the name to filter results\n            (case-insensitive). Defaults to an empty string.\n\n    Returns:\n        List[T]: A list of instances of the derived class.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n    )\n    query = {\n        \"nom\": {\n            \"$regex\": request,\n            \"$options\": \"i\",\n        }\n    }\n    result = collection.find(query)\n    list_baseentity = [cls.from_oid(entry.get(\"_id\")) for entry in result]\n    return list_baseentity\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.get_oid","title":"<code>get_oid()</code>","text":"<p>Retrieves the ObjectId of the entity from the database.</p> <p>Returns:</p> Type Description <code>Optional[ObjectId]</code> <p>Optional[ObjectId]: The ObjectId of the entity if found, otherwise None.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def get_oid(self) -&gt; Optional[ObjectId]:\n    \"\"\"Retrieves the ObjectId of the entity from the database.\n\n    Returns:\n        Optional[ObjectId]: The ObjectId of the entity if found, otherwise None.\n    \"\"\"\n    document = self.collection.find_one({\"nom\": self.nom})\n    if document:\n        return document[\"_id\"]\n    else:\n        return None\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.keep","title":"<code>keep()</code>","text":"<p>Insert ou met \u00e0 jour l'entit\u00e9 dans la base. Utilise la s\u00e9rialisation via to_dict() pour conserver tous les attributs serialisables.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def keep(self) -&gt; None:\n    \"\"\"\n    Insert ou met \u00e0 jour l'entit\u00e9 dans la base.\n    Utilise la s\u00e9rialisation via to_dict() pour conserver tous les attributs serialisables.\n    \"\"\"\n    data = self.to_dict()\n    if not self.exists():\n        mongolog(\"insert\", self.collection.name, self.nom)\n        self.collection.insert_one(data)\n    else:\n        mongolog(\"update\", self.collection.name, self.nom)\n        self.collection.replace_one({\"nom\": self.nom}, data)\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.remove","title":"<code>remove()</code>","text":"<p>Removes the entity from the database.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Removes the entity from the database.\"\"\"\n    self.collection.delete_one({\"nom\": self.nom})\n    mongolog(\"delete\", self.collection.name, self.nom)\n</code></pre>"},{"location":"mongo/#mongo.BaseEntity.to_dict","title":"<code>to_dict()</code>","text":"<p>S\u00e9rialise l'instance en dictionnaire en excluant les attributs non d\u00e9sir\u00e9s. On exclut ici 'collection' par exemple.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    S\u00e9rialise l'instance en dictionnaire en excluant les attributs non d\u00e9sir\u00e9s.\n    On exclut ici 'collection' par exemple.\n    \"\"\"\n    # On r\u00e9cup\u00e8re l'ensemble des attributs de l'objet\n    data = self.__dict__.copy()\n    # On retire attributes non serialisables\n    data.pop(\"collection\", None)\n    return data\n</code></pre>"},{"location":"mongo/#mongo.Critique","title":"<code>Critique</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Class representing a review (Critique) entity stored in the 'critiques' MongoDB collection.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>str</code> <p>MongoDB collection name used to store critiques.</p> Source code in <code>nbs/mongo.py</code> <pre><code>class Critique(BaseEntity):\n    \"\"\"\n    Class representing a review (Critique) entity stored in the 'critiques' MongoDB collection.\n\n    Attributes:\n        collection (str): MongoDB collection name used to store critiques.\n    \"\"\"\n\n    collection: str = \"critiques\"\n\n    def __init__(self, nom: str) -&gt; None:\n        \"\"\"\n        Initializes a Critique instance.\n\n        Args:\n            nom (str): Name of the critique.\n        \"\"\"\n        super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.Critique.__init__","title":"<code>__init__(nom)</code>","text":"<p>Initializes a Critique instance.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>Name of the critique.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def __init__(self, nom: str) -&gt; None:\n    \"\"\"\n    Initializes a Critique instance.\n\n    Args:\n        nom (str): Name of the critique.\n    \"\"\"\n    super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.Editeur","title":"<code>Editeur</code>","text":"<p>               Bases: <code>BaseEntity</code></p> <p>Represents a publisher stored in the 'editeurs' MongoDB collection.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>str</code> <p>The name of the MongoDB collection.</p> Source code in <code>nbs/mongo.py</code> <pre><code>class Editeur(BaseEntity):\n    \"\"\"\n    Represents a publisher stored in the 'editeurs' MongoDB collection.\n\n    Attributes:\n        collection (str): The name of the MongoDB collection.\n    \"\"\"\n\n    collection: str = \"editeurs\"\n\n    def __init__(self, nom: str) -&gt; None:\n        \"\"\"\n        Initialize an Editeur instance.\n\n        Args:\n            nom (str): The name of the publisher.\n        \"\"\"\n        super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.Editeur.__init__","title":"<code>__init__(nom)</code>","text":"<p>Initialize an Editeur instance.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>The name of the publisher.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def __init__(self, nom: str) -&gt; None:\n    \"\"\"\n    Initialize an Editeur instance.\n\n    Args:\n        nom (str): The name of the publisher.\n    \"\"\"\n    super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo/#mongo.get_collection","title":"<code>get_collection(target_db='localhost', client_name='masque_et_la_plume', collection_name='episodes')</code>","text":"<p>Retrieve a MongoDB collection.</p> <p>This function connects to a MongoDB database using the provided database host, client name (database name), and collection name, and returns the collection object.</p> <p>Parameters:</p> Name Type Description Default <code>target_db</code> <code>str</code> <p>The database host address (e.g., \"localhost\" or \"nas923\").</p> <code>'localhost'</code> <code>client_name</code> <code>str</code> <p>The name of the MongoDB client/database.</p> <code>'masque_et_la_plume'</code> <code>collection_name</code> <code>str</code> <p>The name of the collection to retrieve.</p> <code>'episodes'</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The MongoDB collection object.</p> Source code in <code>nbs/mongo.py</code> <pre><code>def get_collection(\n    target_db: str = \"localhost\",\n    client_name: str = \"masque_et_la_plume\",\n    collection_name: str = \"episodes\",\n) -&gt; Collection:\n    \"\"\"Retrieve a MongoDB collection.\n\n    This function connects to a MongoDB database using the provided database host,\n    client name (database name), and collection name, and returns the collection object.\n\n    Args:\n        target_db (str): The database host address (e.g., \"localhost\" or \"nas923\").\n        client_name (str): The name of the MongoDB client/database.\n        collection_name (str): The name of the collection to retrieve.\n\n    Returns:\n        Collection: The MongoDB collection object.\n    \"\"\"\n    client = pymongo.MongoClient(f\"mongodb://{target_db}:27017/\")\n    db = client[client_name]\n    collection = db[collection_name]\n    return collection\n</code></pre>"},{"location":"mongo/#mongo.mongolog","title":"<code>mongolog(operation, entite, desc)</code>","text":"<p>Enregistre une op\u00e9ration de log dans la collection 'logs' si la configuration autorise les logs.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>L'op\u00e9ration effectu\u00e9e (par exemple, \"insert\", \"update\", \"delete\").</p> required <code>entite</code> <code>str</code> <p>Le nom de l'entit\u00e9 concern\u00e9e.</p> required <code>desc</code> <code>str</code> <p>Une description d\u00e9taill\u00e9e de l'op\u00e9ration.</p> required Source code in <code>nbs/mongo.py</code> <pre><code>def mongolog(operation: str, entite: str, desc: str) -&gt; None:\n    \"\"\"Enregistre une op\u00e9ration de log dans la collection 'logs' si la configuration autorise les logs.\n\n    Args:\n        operation (str): L'op\u00e9ration effectu\u00e9e (par exemple, \"insert\", \"update\", \"delete\").\n        entite (str): Le nom de l'entit\u00e9 concern\u00e9e.\n        desc (str): Une description d\u00e9taill\u00e9e de l'op\u00e9ration.\n    \"\"\"\n    DB_HOST, DB_NAME, DB_LOGS = get_DB_VARS()\n    if DB_LOGS in [\"true\", \"True\"]:\n        coll_logs = get_collection(DB_HOST, DB_NAME, \"logs\")\n        coll_logs.insert_one(\n            {\n                \"operation\": operation,\n                \"entite\": entite,\n                \"desc\": desc,\n                \"date\": datetime.now(),\n            }\n        )\n</code></pre>"},{"location":"mongo/#mongo.print_logs","title":"<code>print_logs(n=10)</code>","text":"<p>Affiche les n derniers logs de la collection 'logs', tri\u00e9s par date d\u00e9croissante.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Le nombre maximum de logs \u00e0 afficher. Par d\u00e9faut \u00e0 10.</p> <code>10</code> Source code in <code>nbs/mongo.py</code> <pre><code>def print_logs(n: int = 10) -&gt; None:\n    \"\"\"Affiche les n derniers logs de la collection 'logs', tri\u00e9s par date d\u00e9croissante.\n\n    Args:\n        n (int, optional): Le nombre maximum de logs \u00e0 afficher. Par d\u00e9faut \u00e0 10.\n    \"\"\"\n    DB_HOST, DB_NAME, DB_LOGS = get_DB_VARS()\n    coll_logs = get_collection(DB_HOST, DB_NAME, \"logs\")\n    for i, log in enumerate(coll_logs.find().sort(\"date\", pymongo.DESCENDING)):\n        if i == n:\n            break\n        print(log)\n</code></pre>"},{"location":"mongo_auteur/","title":"Module mongo_auteur","text":""},{"location":"mongo_auteur/#mongo_auteur.Auteur","title":"<code>Auteur</code>","text":"<p>               Bases: <code>BaseEntity</code></p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>class Auteur(BaseEntity):\n    collection: str = \"auteurs\"\n\n    def __init__(self, nom: str) -&gt; None:\n        \"\"\"Initialise une instance d'Auteur.\n\n        Args:\n            nom (str): Le nom de l'auteur.\n        \"\"\"\n        super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.Auteur.__init__","title":"<code>__init__(nom)</code>","text":"<p>Initialise une instance d'Auteur.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>Le nom de l'auteur.</p> required Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def __init__(self, nom: str) -&gt; None:\n    \"\"\"Initialise une instance d'Auteur.\n\n    Args:\n        nom (str): Le nom de l'auteur.\n    \"\"\"\n    super().__init__(nom, self.collection)\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker","title":"<code>AuthorChecker</code>","text":"<p>Class to verify and correct an author's name using multiple data sources.</p> This class verifies an author in an episode through sources including <ul> <li>RSS metadata (title, description)</li> <li>MongoDB database of known authors</li> <li>LLM suggestions</li> <li>Web search analysis</li> </ul> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>class AuthorChecker:\n    \"\"\"Class to verify and correct an author's name using multiple data sources.\n\n    This class verifies an author in an episode through sources including:\n      - RSS metadata (title, description)\n      - MongoDB database of known authors\n      - LLM suggestions\n      - Web search analysis\n    \"\"\"\n\n    def __init__(self, episode: Episode) -&gt; None:\n        \"\"\"Initializes the AuthorChecker with an episode.\n\n        Args:\n            episode (Episode): An episode instance containing title and description.\n        \"\"\"\n        self.episode = episode\n        self.llm_structured_output = get_azure_llm(\"gpt-4o\")\n        self.authors_titre_description = self._get_authors_from_titre_description()\n\n    def _get_filtered_titre_description(self, titre_or_description: str) -&gt; str:\n        \"\"\"Filter the given titre or description to avoid Error 400.\n\n        Filters out substrings that may trigger Azure OpenAI's content management policy (resulting in a 400 error).\n        Specifically, for certain dates, predefined terms are replaced as specified in the filter mapping.\n\n        For more details, see:\n            https://github.com/castorfou/lmelp/issues/21\n\n        Args:\n            titre_or_description (str): 'titre' or 'description'depending on what to filter.\n\n        Returns:\n            str: The filtered titre or description.\n        \"\"\"\n        filtering = {\n            \"2020/11/15\": {\"fossoyeur\": \"rigolo\"},\n        }\n        fmt_date = self.episode.date.strftime(\"%Y/%m/%d\")\n        replacements = filtering.get(fmt_date)\n\n        text = (\n            self.episode.titre\n            if titre_or_description == \"titre\"\n            else self.episode.description\n        )\n        if replacements:\n            for key, value in replacements.items():\n                text = text.replace(key, value)\n        return text\n\n    def _get_authors_from_titre_description(self) -&gt; List[str]:\n        \"\"\"Retrieves a list of author names extracted from the episode title and description using LLM.\n\n        Returns:\n            List[str]: A list of author names extracted from the title and description.\n        \"\"\"\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorTitreDescriptionList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors_TitreDescription\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"A list of names from title and description\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors_TitreDescription\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n        try:\n            titre = self._get_filtered_titre_description(\"titre\")\n            description = self._get_filtered_titre_description(\"description\")\n            response = self.llm_structured_output.chat(\n                messages=[\n                    ChatMessage(\n                        role=\"system\",\n                        content=\"Tu es un assistant utile qui retourne une liste JSON de noms.\",\n                    ),\n                    ChatMessage(\n                        role=\"user\",\n                        content=f\"Est-ce que tu peux me lister tous les noms qui sont cit\u00e9s dans le titre et la description de l'\u00e9pisode suivant : {titre} {description}. \",\n                    ),\n                ],\n                response_format=response_schema,\n            )\n        except Exception as e:\n            print(f\"Error getting authors from titre/description: {e}\")\n            print(f\"prompt: {titre} {description}\")\n            return []\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []  # Return an empty list if parsing fails\n        return json_dict[\"Authors_TitreDescription\"]\n\n    def _get_authors_from_llm(self, autor: str) -&gt; List[str]:\n        \"\"\"Queries the LLM to retrieve a list of potential author names based on a provided name.\n\n        Args:\n            autor (str): The author name to query.\n\n        Returns:\n            List[str]: A list of author names suggested by the LLM.\n        \"\"\"\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors_LLM\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"A list of authors' names\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors_LLM\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n\n        prompt = (\n            \"\"\"\n        Tu es un agent expert en litt\u00e9rature.\n        Donne moi quelques auteurs dont le nom s'approche de celui-ci : \"\"\"\n            + autor\n            + \"\"\"\n\n        S'il s'agit deja d'un auteur connu, retourne moi juste son nom. S'il y a une erreur dans le nom que je t'ai donne, corrige moi en me donnant le nom de l'auteur que tu penses que j'ai voulu dire.\n\n        Je veux que tu me donnes le prenom puis le nom dans cet ordre. Par exemple \"Marcel Pagnol\" ou \"Victor Hugo\".\n        Ces auteurs sont susceptibles d'etre discutes dans \"Le Masque et la Plume\".\n\n        Si tu me retournes plusieurs auteurs, fais le sous forme de liste par exemple si tu as identifie \"auteur 1\" et \"auteur 2\" alors retourne [\"auteur 1\", \"auteur 2\"]\n        \"\"\"\n        )\n\n        response = self.llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un agent litteraire qui connait parfaitement les auteurs.\",\n                ),\n                ChatMessage(role=\"user\", content=f\"{prompt}. \"),\n            ],\n            response_format=response_schema,\n        )\n\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []\n        return json_dict[\"Authors_LLM\"]\n\n    def _get_author_from_web(self, author: str) -&gt; Dict[str, Union[str, int]]:\n        \"\"\"Analyzes a Google search result to verify if a given name corresponds to an author.\n\n        Args:\n            author (str): The author name to verify.\n\n        Returns:\n            Dict[str, Union[str, int]]: A dictionary containing:\n                - \"auteur\": The corrected author name if applicable.\n                - \"certitude\": An integer between 0 and 100 indicating the confidence.\n                - \"analyse\": A textual analysis of the Google search query.\n        \"\"\"\n        result_google = google_search(author)\n\n        prompt_incertitude_auteur = f\"\"\"\n        Voici le resultat d'une requete google concernant un probable auteur inconnu de mon llm : {author}\n        La requete est au format dict avec du json a l'interieur.\n        Est-ce que tu peux analyser le contenu de cette requete et me dire si oui ou non {author} est un auteur de livres, \n        et accompagner ta reponse d'un pourcentage de certitude :\n        * 100% de certitude signifie que tu es certain que {author} est un auteur de livres\n        *  50% tu es ni sure ni pas sure que {author} est un auteur de livres\n        *   0% tu es certain que {author} n'est pas un auteur de livres\n\n        Voici le contenu de la requete google : {result_google}\n\n        Tu repondras uniquement avec un dictionnaire qui va contenir 3 entrees :\n\n        - \"auteur\" : le nom de l'auteur, eventuellement corrige si j'ai oublie des accents ou une faute de frappe\n        - \"certitude\" : le pourcentage de certitude de 0 \u00e0 100, un entier\n        - \"analyse\" : une analyse de la requete Google concernant l'auteur.\n        \"\"\"\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuteurSchema\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"auteur\": {\n                            \"type\": \"string\",\n                            \"description\": \"Le nom de l'auteur \u00e9ventuellement corrig\u00e9 (accents, fautes de frappe).\",\n                        },\n                        \"certitude\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Pourcentage de certitude (0 \u00e0 100).\",\n                            \"minimum\": 0,\n                            \"maximum\": 100,\n                        },\n                        \"analyse\": {\n                            \"type\": \"string\",\n                            \"description\": \"Analyse de la requ\u00eate Google concernant l'auteur.\",\n                        },\n                    },\n                    \"required\": [\"auteur\", \"certitude\", \"analyse\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n\n        response = self.llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un assistant utile qui analyse des requetes Google pour y deceler si un auteur de livre s'y cache.\",\n                ),\n                ChatMessage(\n                    role=\"user\",\n                    content=prompt_incertitude_auteur,\n                ),\n            ],\n            response_format=response_schema,\n        )\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return {}\n        return json_dict\n\n    def _check_author_source(\n        self, author: str, authors_list: List[str]\n    ) -&gt; Optional[str]:\n        \"\"\"Determines the best matching author from a provided list using fuzzy matching.\n\n        Args:\n            author (str): The author name to match.\n            authors_list (List[str]): A list of author names to check against.\n\n        Returns:\n            Optional[str]: The best matching author name if the match score is above the threshold, otherwise None.\n        \"\"\"\n        matcher = AuthorFuzzMatcher(authors_list)\n        best_match, score = matcher.find_best_match(author)\n        if score &gt;= score_fuzz_threshold:\n            return best_match\n        else:\n            return None\n\n    def check_author(\n        self, author: str, return_details: bool = False, verbose: bool = False\n    ) -&gt; Union[str, Dict[str, Union[str, int]], None]:\n        \"\"\"Verifies an author's name through various sources and returns the corrected name.\n\n        It checks in the following order:\n          1. RSS metadata (title, description)\n          2. MongoDB list of known authors\n          3. LLM suggested names\n          4. Web search analysis\n\n        Args:\n            author (str): The author name to verify.\n            return_details (bool, optional): If True, returns a detailed dictionary with source and analysis. Defaults to False.\n            verbose (bool, optional): If True, prints debug messages. Defaults to False.\n\n        Returns:\n            Union[str, Dict[str, Union[str, int]], None]: The corrected author name as a string if return_details is False;\n                a detailed dict if return_details is True; or None if no match is found.\n        \"\"\"\n        details = {\"author_original\": author, \"author_corrected\": None, \"source\": None}\n\n        # 1. V\u00e9rification dans rss:metadata (titre, description)\n        match = self._check_author_source(author, self.authors_titre_description)\n        if match:\n            details[\"author_corrected\"] = match\n            details[\"source\"] = \"rss:metadata\"\n            if verbose:\n                print(f\"Trouv\u00e9 avec rss:metadata: {match}\")\n            return details if return_details else match\n\n        # 2. V\u00e9rification dans la base de donn\u00e9es (mongodb:auteurs)\n        list_db_auteurs = [auteur.nom for auteur in Auteur.get_entries()]\n        match = self._check_author_source(author, list_db_auteurs)\n        if match:\n            details[\"author_corrected\"] = match\n            details[\"source\"] = \"mongodb:auteurs\"\n            if verbose:\n                print(f\"Trouv\u00e9 avec mongodb:auteurs: {match}\")\n            return details if return_details else match\n\n        # 3. V\u00e9rification via llm\n        list_llm_auteurs = self._get_authors_from_llm(author)\n        match = self._check_author_source(author, list_llm_auteurs)\n        if match:\n            details[\"author_corrected\"] = match\n            details[\"source\"] = \"llm\"\n            if verbose:\n                print(f\"Trouv\u00e9 avec llm: {match}\")\n            return details if return_details else match\n\n        # 4. V\u00e9rification via web search\n        web_result_dict = self._get_author_from_web(author)\n        match = web_result_dict.get(\"auteur\")\n        score = web_result_dict.get(\"certitude\", 0)\n        details.update(\n            {\n                \"author_corrected\": match,\n                \"score\": score,\n                \"analyse\": web_result_dict.get(\"analyse\", \"\"),\n                \"source\": \"web search\",\n            }\n        )\n        if score &gt;= score_fuzz_threshold:\n            if verbose:\n                print(f\"Trouv\u00e9 avec web search: {match}\")\n            return details if return_details else match\n        else:\n            if verbose:\n                print(\n                    f\"Score insuffisant {score} avec web search: {web_result_dict.get('analyse', '')}\"\n                )\n            details[\"author_corrected\"] = None\n            return details if return_details else None\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker.__init__","title":"<code>__init__(episode)</code>","text":"<p>Initializes the AuthorChecker with an episode.</p> <p>Parameters:</p> Name Type Description Default <code>episode</code> <code>Episode</code> <p>An episode instance containing title and description.</p> required Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def __init__(self, episode: Episode) -&gt; None:\n    \"\"\"Initializes the AuthorChecker with an episode.\n\n    Args:\n        episode (Episode): An episode instance containing title and description.\n    \"\"\"\n    self.episode = episode\n    self.llm_structured_output = get_azure_llm(\"gpt-4o\")\n    self.authors_titre_description = self._get_authors_from_titre_description()\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorChecker.check_author","title":"<code>check_author(author, return_details=False, verbose=False)</code>","text":"<p>Verifies an author's name through various sources and returns the corrected name.</p> It checks in the following order <ol> <li>RSS metadata (title, description)</li> <li>MongoDB list of known authors</li> <li>LLM suggested names</li> <li>Web search analysis</li> </ol> <p>Parameters:</p> Name Type Description Default <code>author</code> <code>str</code> <p>The author name to verify.</p> required <code>return_details</code> <code>bool</code> <p>If True, returns a detailed dictionary with source and analysis. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints debug messages. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Union[str, int]], None]</code> <p>Union[str, Dict[str, Union[str, int]], None]: The corrected author name as a string if return_details is False; a detailed dict if return_details is True; or None if no match is found.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def check_author(\n    self, author: str, return_details: bool = False, verbose: bool = False\n) -&gt; Union[str, Dict[str, Union[str, int]], None]:\n    \"\"\"Verifies an author's name through various sources and returns the corrected name.\n\n    It checks in the following order:\n      1. RSS metadata (title, description)\n      2. MongoDB list of known authors\n      3. LLM suggested names\n      4. Web search analysis\n\n    Args:\n        author (str): The author name to verify.\n        return_details (bool, optional): If True, returns a detailed dictionary with source and analysis. Defaults to False.\n        verbose (bool, optional): If True, prints debug messages. Defaults to False.\n\n    Returns:\n        Union[str, Dict[str, Union[str, int]], None]: The corrected author name as a string if return_details is False;\n            a detailed dict if return_details is True; or None if no match is found.\n    \"\"\"\n    details = {\"author_original\": author, \"author_corrected\": None, \"source\": None}\n\n    # 1. V\u00e9rification dans rss:metadata (titre, description)\n    match = self._check_author_source(author, self.authors_titre_description)\n    if match:\n        details[\"author_corrected\"] = match\n        details[\"source\"] = \"rss:metadata\"\n        if verbose:\n            print(f\"Trouv\u00e9 avec rss:metadata: {match}\")\n        return details if return_details else match\n\n    # 2. V\u00e9rification dans la base de donn\u00e9es (mongodb:auteurs)\n    list_db_auteurs = [auteur.nom for auteur in Auteur.get_entries()]\n    match = self._check_author_source(author, list_db_auteurs)\n    if match:\n        details[\"author_corrected\"] = match\n        details[\"source\"] = \"mongodb:auteurs\"\n        if verbose:\n            print(f\"Trouv\u00e9 avec mongodb:auteurs: {match}\")\n        return details if return_details else match\n\n    # 3. V\u00e9rification via llm\n    list_llm_auteurs = self._get_authors_from_llm(author)\n    match = self._check_author_source(author, list_llm_auteurs)\n    if match:\n        details[\"author_corrected\"] = match\n        details[\"source\"] = \"llm\"\n        if verbose:\n            print(f\"Trouv\u00e9 avec llm: {match}\")\n        return details if return_details else match\n\n    # 4. V\u00e9rification via web search\n    web_result_dict = self._get_author_from_web(author)\n    match = web_result_dict.get(\"auteur\")\n    score = web_result_dict.get(\"certitude\", 0)\n    details.update(\n        {\n            \"author_corrected\": match,\n            \"score\": score,\n            \"analyse\": web_result_dict.get(\"analyse\", \"\"),\n            \"source\": \"web search\",\n        }\n    )\n    if score &gt;= score_fuzz_threshold:\n        if verbose:\n            print(f\"Trouv\u00e9 avec web search: {match}\")\n        return details if return_details else match\n    else:\n        if verbose:\n            print(\n                f\"Score insuffisant {score} avec web search: {web_result_dict.get('analyse', '')}\"\n            )\n        details[\"author_corrected\"] = None\n        return details if return_details else None\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher","title":"<code>AuthorFuzzMatcher</code>","text":"Source code in <code>nbs/mongo_auteur.py</code> <pre><code>class AuthorFuzzMatcher:\n    def __init__(self, reference_authors: Optional[List[str]] = None) -&gt; None:\n        \"\"\"Initializes an AuthorFuzzMatcher with a list of known author names.\n\n        Args:\n            reference_authors (Optional[List[str]]): A list of known author names. Defaults to None.\n        \"\"\"\n        self.reference_authors = set(reference_authors) if reference_authors else set()\n\n    def add_reference_author(self, author: str) -&gt; None:\n        \"\"\"Adds a new reference author to the set.\n\n        Args:\n            author (str): The author name to be added.\n        \"\"\"\n        self.reference_authors.add(author.strip())\n\n    def find_best_match(\n        self, name: str, min_score: int = 80\n    ) -&gt; Tuple[Optional[str], int]:\n        \"\"\"Finds the best matching reference author for a given name using token set ratio.\n\n        Args:\n            name (str): The name to match against the reference authors.\n            min_score (int, optional): The minimal score required for a match. Defaults to 80.\n\n        Returns:\n            Tuple[Optional[str], int]: A tuple with the best matching author's name (or None if no match satisfies the minimum score) and the matching score.\n        \"\"\"\n        if not name or not self.reference_authors:\n            return None, 0\n        best_match, score = process.extractOne(\n            name, self.reference_authors, scorer=fuzz.token_set_ratio\n        )\n        if score &gt;= min_score:\n            return best_match, score\n        return None, score\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher.__init__","title":"<code>__init__(reference_authors=None)</code>","text":"<p>Initializes an AuthorFuzzMatcher with a list of known author names.</p> <p>Parameters:</p> Name Type Description Default <code>reference_authors</code> <code>Optional[List[str]]</code> <p>A list of known author names. Defaults to None.</p> <code>None</code> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def __init__(self, reference_authors: Optional[List[str]] = None) -&gt; None:\n    \"\"\"Initializes an AuthorFuzzMatcher with a list of known author names.\n\n    Args:\n        reference_authors (Optional[List[str]]): A list of known author names. Defaults to None.\n    \"\"\"\n    self.reference_authors = set(reference_authors) if reference_authors else set()\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher.add_reference_author","title":"<code>add_reference_author(author)</code>","text":"<p>Adds a new reference author to the set.</p> <p>Parameters:</p> Name Type Description Default <code>author</code> <code>str</code> <p>The author name to be added.</p> required Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def add_reference_author(self, author: str) -&gt; None:\n    \"\"\"Adds a new reference author to the set.\n\n    Args:\n        author (str): The author name to be added.\n    \"\"\"\n    self.reference_authors.add(author.strip())\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.AuthorFuzzMatcher.find_best_match","title":"<code>find_best_match(name, min_score=80)</code>","text":"<p>Finds the best matching reference author for a given name using token set ratio.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to match against the reference authors.</p> required <code>min_score</code> <code>int</code> <p>The minimal score required for a match. Defaults to 80.</p> <code>80</code> <p>Returns:</p> Type Description <code>Tuple[Optional[str], int]</code> <p>Tuple[Optional[str], int]: A tuple with the best matching author's name (or None if no match satisfies the minimum score) and the matching score.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def find_best_match(\n    self, name: str, min_score: int = 80\n) -&gt; Tuple[Optional[str], int]:\n    \"\"\"Finds the best matching reference author for a given name using token set ratio.\n\n    Args:\n        name (str): The name to match against the reference authors.\n        min_score (int, optional): The minimal score required for a match. Defaults to 80.\n\n    Returns:\n        Tuple[Optional[str], int]: A tuple with the best matching author's name (or None if no match satisfies the minimum score) and the matching score.\n    \"\"\"\n    if not name or not self.reference_authors:\n        return None, 0\n    best_match, score = process.extractOne(\n        name, self.reference_authors, scorer=fuzz.token_set_ratio\n    )\n    if score &gt;= min_score:\n        return best_match, score\n    return None, score\n</code></pre>"},{"location":"mongo_auteur/#mongo_auteur.google_search","title":"<code>google_search(query)</code>","text":"<p>Effectue une recherche Google en utilisant l'API Custom Search et retourne les r\u00e9sultats.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>La requ\u00eate de recherche.</p> required <p>Returns:</p> Type Description <code>Optional[List[Dict[str, Optional[str]]]]</code> <p>Optional[List[Dict[str, Optional[str]]]]: Une liste de dictionnaires repr\u00e9sentant les r\u00e9sultats de la recherche, chaque dictionnaire contenant les cl\u00e9s 'title', 'snippet' et 'link'. Retourne None en cas d'erreur.</p> Source code in <code>nbs/mongo_auteur.py</code> <pre><code>def google_search(query: str) -&gt; Optional[List[Dict[str, Optional[str]]]]:\n    \"\"\"Effectue une recherche Google en utilisant l'API Custom Search et retourne les r\u00e9sultats.\n\n    Args:\n        query (str): La requ\u00eate de recherche.\n\n    Returns:\n        Optional[List[Dict[str, Optional[str]]]]:\n            Une liste de dictionnaires repr\u00e9sentant les r\u00e9sultats de la recherche, chaque dictionnaire contenant\n            les cl\u00e9s 'title', 'snippet' et 'link'. Retourne None en cas d'erreur.\n    \"\"\"\n    try:\n        service = build(\"customsearch\", \"v1\", developerKey=api_key)\n        res = service.cse().list(q=query, cx=cse_id).execute()\n\n        results: List[Dict[str, Optional[str]]] = []\n        for item in res.get(\"items\", []):\n            title: Optional[str] = item.get(\"title\")\n            snippet: Optional[str] = item.get(\"snippet\")\n            link: Optional[str] = item.get(\"link\")\n            results.append({\"title\": title, \"snippet\": snippet, \"link\": link})\n        return results\n    except Exception as e:\n        print(f\"Erreur lors de la recherche Google: {e}\")\n        return None\n</code></pre>"},{"location":"mongo_episode/","title":"Module mongo_episode","text":""},{"location":"mongo_episode/#mongo_episode.Episode","title":"<code>Episode</code>","text":"Source code in <code>nbs/mongo_episode.py</code> <pre><code>class Episode:\n    def __init__(\n        self, date: str, titre: str, collection_name: str = \"episodes\"\n    ) -&gt; None:\n        \"\"\"Initialise une instance d'Episode.\n\n        Args:\n            date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\" conforme \u00e0 DATE_FORMAT.\n            titre (str): Le titre de l'\u00e9pisode.\n            collection_name (str, optional): Le nom de la collection dans la base de donn\u00e9es. D\u00e9faut: \"episodes\".\n\n        Notes:\n            Si l'\u00e9pisode existe d\u00e9j\u00e0 en base, ses attributs seront charg\u00e9s.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        self.date: datetime = Episode.get_date_from_string(date)\n        self.titre: str = titre\n\n        if self.exists():\n            episode = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n            self.description: Optional[str] = episode.get(\"description\")\n            self.url_telechargement: Optional[str] = episode.get(\"url\")\n            self.audio_rel_filename: Optional[str] = episode.get(\"audio_rel_filename\")\n            self.transcription: Optional[str] = episode.get(\"transcription\")\n            self.type: Optional[str] = episode.get(\"type\")\n            self.duree: int = episode.get(\"duree\", -1)\n        else:\n            self.description = None\n            self.url_telechargement = None\n            self.audio_rel_filename = None\n            self.transcription = None\n            self.type = None\n            self.duree = -1  # en secondes\n\n    @classmethod\n    def from_oid(cls, oid: ObjectId, collection_name: str = \"episodes\") -&gt; \"Episode\":\n        \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'un ObjectId dans la base de donn\u00e9es.\n\n        Args:\n            oid (ObjectId): L'identifiant de l'\u00e9pisode dans Mongo.\n            collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n        Returns:\n            Episode: L'instance d'Episode correspondante.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        document = collection.find_one({\"_id\": oid})\n        date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n        instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n        return instance\n\n    @classmethod\n    def from_date(\n        cls, date: datetime, collection_name: str = \"episodes\"\n    ) -&gt; Optional[\"Episode\"]:\n        \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'une date dans la base de donn\u00e9es.\n\n        Args:\n            date (datetime): La date recherch\u00e9e.\n            collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n        Returns:\n            Optional[Episode]: L'instance d'Episode si trouv\u00e9e, sinon None.\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        start_date = datetime(date.year, date.month, date.day)\n        end_date = datetime(date.year, date.month, date.day, 23, 59, 59)\n        document = collection.find_one({\"date\": {\"$gte\": start_date, \"$lte\": end_date}})\n        if document:\n            date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n            instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n            return instance\n        else:\n            return None\n\n    def exists(self) -&gt; bool:\n        \"\"\"V\u00e9rifie si l'\u00e9pisode existe dans la base de donn\u00e9es.\n\n        Returns:\n            bool: True si l'\u00e9pisode existe, False sinon.\n        \"\"\"\n        return (\n            self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n            is not None\n        )\n\n    def keep(self) -&gt; int:\n        \"\"\"T\u00e9l\u00e9charge le fichier audio si n\u00e9cessaire et conserve l'\u00e9pisode dans la base de donn\u00e9es.\n\n        Returns:\n            int: 1 si une nouvelle entr\u00e9e est cr\u00e9\u00e9e en base, 0 sinon.\n        \"\"\"\n        message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n        if not self.exists():\n            print(\n                f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} nouveau: Duree: {self.duree}, Type: {self.type}\"\n            )\n            mongolog(\"insert\", self.collection.name, message_log)\n            self.download_audio(verbose=True)\n            self.collection.insert_one(\n                {\n                    \"titre\": self.titre,\n                    \"date\": self.date,\n                    \"description\": self.description,\n                    \"url\": self.url_telechargement,\n                    \"audio_rel_filename\": self.audio_rel_filename,\n                    \"transcription\": self.transcription,\n                    \"type\": self.type,\n                    \"duree\": self.duree,\n                }\n            )\n            return 1\n        else:\n            print(\n                f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} deja existant\"\n            )\n            mongolog(\"update\", self.collection.name, message_log)\n            return 0\n\n    def update_date(self, new_date: datetime) -&gt; None:\n        \"\"\"Met \u00e0 jour la date de l'\u00e9pisode dans la base de donn\u00e9es.\n\n        Args:\n            new_date (datetime): La nouvelle date de l'\u00e9pisode.\n        \"\"\"\n        self.collection.update_one(\n            {\"_id\": self.get_oid()}, {\"$set\": {\"date\": new_date}}\n        )\n        message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre} -&gt; {Episode.get_string_from_date(new_date, format=LOG_DATE_FORMAT)}\"\n        self.date = new_date\n        mongolog(\"force_update\", self.collection.name, message_log)\n\n    def remove(self) -&gt; None:\n        \"\"\"Supprime l'\u00e9pisode de la base de donn\u00e9es.\"\"\"\n        message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n        self.collection.delete_one({\"titre\": self.titre, \"date\": self.date})\n        mongolog(\"delete\", self.collection.name, message_log)\n\n    def get_oid(self) -&gt; Optional[ObjectId]:\n        \"\"\"R\u00e9cup\u00e8re l'identifiant Mongo (_id) de l'\u00e9pisode.\n\n        Returns:\n            Optional[ObjectId]: L'ObjectId de l'\u00e9pisode s'il existe, sinon None.\n        \"\"\"\n        document = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n        if document:\n            return document[\"_id\"]\n        else:\n            return None\n\n    @staticmethod\n    def get_date_from_string(date: str, DATE_FORMAT: str = DATE_FORMAT) -&gt; datetime:\n        \"\"\"Convertit une cha\u00eene de caract\u00e8res en objet datetime.\n\n        Args:\n            date (str): La cha\u00eene repr\u00e9sentant la date.\n            DATE_FORMAT (str, optional): Le format de la date. D\u00e9faut est DATE_FORMAT.\n\n        Returns:\n            datetime: L'objet datetime correspondant.\n        \"\"\"\n        return datetime.strptime(date, DATE_FORMAT)\n\n    @staticmethod\n    def get_string_from_date(date: datetime, format: Optional[str] = None) -&gt; str:\n        \"\"\"Convertit un objet datetime en cha\u00eene de caract\u00e8res.\n\n        Args:\n            date (datetime): L'objet datetime.\n            format (Optional[str], optional): Le format de sortie. Si None, DATE_FORMAT est utilis\u00e9.\n\n        Returns:\n            str: La cha\u00eene repr\u00e9sentant la date.\n        \"\"\"\n        if format is not None:\n            return date.strftime(format)\n        else:\n            return date.strftime(DATE_FORMAT)\n\n    @staticmethod\n    def format_duration(seconds: int) -&gt; str:\n        \"\"\"Convertit une dur\u00e9e en secondes au format HH:MM:SS.\n\n        Args:\n            seconds (int): La dur\u00e9e en secondes.\n\n        Returns:\n            str: La dur\u00e9e format\u00e9e en cha\u00eene de caract\u00e8res.\n        \"\"\"\n        if seconds &lt; 0:\n            return f\"-{Episode.format_duration(-seconds)}\"\n        hours = seconds // 3600\n        minutes = (seconds % 3600) // 60\n        seconds = seconds % 60\n        return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Renvoie une repr\u00e9sentation textuelle de l'\u00e9pisode.\n\n        Returns:\n            str: Les informations de l'\u00e9pisode sous forme de cha\u00eene de caract\u00e8res.\n        \"\"\"\n        return (\n            f\"_oid: {self.get_oid()}\\n\"\n            f\"Date: {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)}\\n\"\n            f\"Titre: {self.titre}\\n\"\n            f\"Description: {self.description}\\n\"\n            f\"URL de t\u00e9l\u00e9chargement: {self.url_telechargement}\\n\"\n            f\"Fichier audio: {self.audio_rel_filename}\\n\"\n            f\"Duree: {self.duree} en secondes ({Episode.format_duration(self.duree)})\\n\"\n            f\"Transcription: {self.transcription[:100] if self.transcription else 'No transcription yet available'}...\"\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Renvoie une repr\u00e9sentation officielle de l'objet.\n\n        Returns:\n            str: La repr\u00e9sentation de l'objet (\u00e9quivalente \u00e0 __str__).\n        \"\"\"\n        return self.__str__()\n\n    def download_audio(self, verbose: bool = False) -&gt; None:\n        \"\"\"T\u00e9l\u00e9charge le fichier audio \u00e0 partir de l'URL de t\u00e9l\u00e9chargement et le sauvegarde localement.\n\n        Args:\n            verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n        \"\"\"\n        if self.url_telechargement is None:\n            return\n        year = str(self.date.year)\n        full_audio_path = get_audio_path(AUDIO_PATH, year)\n        full_filename = os.path.join(\n            full_audio_path, os.path.basename(self.url_telechargement)\n        )\n        self.audio_rel_filename = os.path.relpath(\n            full_filename, get_audio_path(AUDIO_PATH, year=\"\")\n        )\n        if not os.path.exists(full_filename):\n            if verbose:\n                print(\n                    f\"T\u00e9l\u00e9chargement de {self.url_telechargement} vers {full_filename}\"\n                )\n            response = requests.get(self.url_telechargement)\n            with open(full_filename, \"wb\") as file:\n                file.write(response.content)\n        else:\n            if verbose:\n                print(f\"Le fichier {full_filename} existe d\u00e9j\u00e0. Ignor\u00e9.\")\n\n    def set_transcription(self, verbose: bool = False, keep_cache: bool = True) -&gt; None:\n        \"\"\"Extrait et sauvegarde la transcription de l'audio en utilisant un mod\u00e8le Whisper.\n\n        Utilise le cache si disponible ou extrait la transcription de l'audio.\n\n        Args:\n            verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n            keep_cache (bool, optional): Si True, sauvegarde la transcription dans un fichier cache. D\u00e9faut True.\n        \"\"\"\n        if self.transcription is not None:\n            if verbose:\n                print(\"Transcription existe deja\")\n            return\n        mp3_fullfilename = get_audio_path(AUDIO_PATH, year=\"\") + self.audio_rel_filename\n        cache_transcription_filename = f\"{os.path.splitext(mp3_fullfilename)[0]}.txt\"\n        if os.path.exists(cache_transcription_filename):\n            if verbose:\n                print(f\"Transcription cachee trouvee: {cache_transcription_filename}\")\n            with open(cache_transcription_filename, \"r\") as file:\n                self.transcription = file.read()\n            self.collection.update_one(\n                {\"_id\": self.get_oid()},\n                {\"$set\": {\"transcription\": self.transcription}},\n            )\n            return\n\n        self.transcription = extract_whisper(mp3_fullfilename)\n        if keep_cache:\n            with open(cache_transcription_filename, \"w\") as f:\n                f.write(self.transcription)\n        self.collection.update_one(\n            {\"_id\": self.get_oid()}, {\"$set\": {\"transcription\": self.transcription}}\n        )\n\n    def to_dict(self) -&gt; Dict[str, Union[str, datetime, int, None]]:\n        \"\"\"Convertit l'\u00e9pisode en dictionnaire.\n\n        Returns:\n            Dict[str, Union[str, datetime, int, None]]: Dictionnaire contenant les informations de l'\u00e9pisode.\n                Les cl\u00e9s sont ['date', 'titre', 'description', 'url_telechargement', 'audio_rel_filename', 'transcription', 'type', 'duree'].\n        \"\"\"\n        return {\n            \"date\": self.date,\n            \"titre\": self.titre,\n            \"description\": self.description,\n            \"url_telechargement\": self.url_telechargement,\n            \"audio_rel_filename\": self.audio_rel_filename,\n            \"transcription\": self.transcription,\n            \"type\": self.type,\n            \"duree\": self.duree,\n        }\n\n    def get_all_auteurs(self) -&gt; List[str]:\n        \"\"\"Extrait la liste de tous les auteurs mentionn\u00e9s dans la transcription.\n\n        Notes:\n            Utilise le mod\u00e8le GPT-4 via Azure LLM pour extraire une liste JSON de noms d'auteurs.\n\n        Returns:\n            List[str]: La liste des auteurs d\u00e9tect\u00e9s.\n        \"\"\"\n        if self.transcription is None:\n            return []\n\n        llm_structured_output = get_azure_llm(\"gpt-4o\")\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"Une liste des auteurs extraits de la transcription\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n        response = llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un assistant utile qui retourne une liste JSON de noms d'auteurs.\",\n                ),\n                ChatMessage(\n                    role=\"user\",\n                    content=f\"Est-ce que tu peux me lister tous les noms d'auteurs dont on parle des oeuvres \\\ndans cette transcription d'un \u00e9pisode du masque et la plume \\\ndiffuse le {self.date.strftime('%d %b %Y')}. \\\nJe veux toujours avoir le pr\u00e9nom et le nom complet de chaque auteur. \\\nVoici cette transcription : {self.transcription} \",\n                ),\n            ],\n            response_format=response_schema,\n        )\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []\n        return json_dict[\"Authors\"]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.__init__","title":"<code>__init__(date, titre, collection_name='episodes')</code>","text":"<p>Initialise une instance d'Episode.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\" conforme \u00e0 DATE_FORMAT.</p> required <code>titre</code> <code>str</code> <p>Le titre de l'\u00e9pisode.</p> required <code>collection_name</code> <code>str</code> <p>Le nom de la collection dans la base de donn\u00e9es. D\u00e9faut: \"episodes\".</p> <code>'episodes'</code> Notes <p>Si l'\u00e9pisode existe d\u00e9j\u00e0 en base, ses attributs seront charg\u00e9s.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(\n    self, date: str, titre: str, collection_name: str = \"episodes\"\n) -&gt; None:\n    \"\"\"Initialise une instance d'Episode.\n\n    Args:\n        date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\" conforme \u00e0 DATE_FORMAT.\n        titre (str): Le titre de l'\u00e9pisode.\n        collection_name (str, optional): Le nom de la collection dans la base de donn\u00e9es. D\u00e9faut: \"episodes\".\n\n    Notes:\n        Si l'\u00e9pisode existe d\u00e9j\u00e0 en base, ses attributs seront charg\u00e9s.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    self.date: datetime = Episode.get_date_from_string(date)\n    self.titre: str = titre\n\n    if self.exists():\n        episode = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n        self.description: Optional[str] = episode.get(\"description\")\n        self.url_telechargement: Optional[str] = episode.get(\"url\")\n        self.audio_rel_filename: Optional[str] = episode.get(\"audio_rel_filename\")\n        self.transcription: Optional[str] = episode.get(\"transcription\")\n        self.type: Optional[str] = episode.get(\"type\")\n        self.duree: int = episode.get(\"duree\", -1)\n    else:\n        self.description = None\n        self.url_telechargement = None\n        self.audio_rel_filename = None\n        self.transcription = None\n        self.type = None\n        self.duree = -1  # en secondes\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.__repr__","title":"<code>__repr__()</code>","text":"<p>Renvoie une repr\u00e9sentation officielle de l'objet.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La repr\u00e9sentation de l'objet (\u00e9quivalente \u00e0 str).</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Renvoie une repr\u00e9sentation officielle de l'objet.\n\n    Returns:\n        str: La repr\u00e9sentation de l'objet (\u00e9quivalente \u00e0 __str__).\n    \"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.__str__","title":"<code>__str__()</code>","text":"<p>Renvoie une repr\u00e9sentation textuelle de l'\u00e9pisode.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Les informations de l'\u00e9pisode sous forme de cha\u00eene de caract\u00e8res.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Renvoie une repr\u00e9sentation textuelle de l'\u00e9pisode.\n\n    Returns:\n        str: Les informations de l'\u00e9pisode sous forme de cha\u00eene de caract\u00e8res.\n    \"\"\"\n    return (\n        f\"_oid: {self.get_oid()}\\n\"\n        f\"Date: {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)}\\n\"\n        f\"Titre: {self.titre}\\n\"\n        f\"Description: {self.description}\\n\"\n        f\"URL de t\u00e9l\u00e9chargement: {self.url_telechargement}\\n\"\n        f\"Fichier audio: {self.audio_rel_filename}\\n\"\n        f\"Duree: {self.duree} en secondes ({Episode.format_duration(self.duree)})\\n\"\n        f\"Transcription: {self.transcription[:100] if self.transcription else 'No transcription yet available'}...\"\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.download_audio","title":"<code>download_audio(verbose=False)</code>","text":"<p>T\u00e9l\u00e9charge le fichier audio \u00e0 partir de l'URL de t\u00e9l\u00e9chargement et le sauvegarde localement.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Si True, affiche des messages d'information. D\u00e9faut False.</p> <code>False</code> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def download_audio(self, verbose: bool = False) -&gt; None:\n    \"\"\"T\u00e9l\u00e9charge le fichier audio \u00e0 partir de l'URL de t\u00e9l\u00e9chargement et le sauvegarde localement.\n\n    Args:\n        verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n    \"\"\"\n    if self.url_telechargement is None:\n        return\n    year = str(self.date.year)\n    full_audio_path = get_audio_path(AUDIO_PATH, year)\n    full_filename = os.path.join(\n        full_audio_path, os.path.basename(self.url_telechargement)\n    )\n    self.audio_rel_filename = os.path.relpath(\n        full_filename, get_audio_path(AUDIO_PATH, year=\"\")\n    )\n    if not os.path.exists(full_filename):\n        if verbose:\n            print(\n                f\"T\u00e9l\u00e9chargement de {self.url_telechargement} vers {full_filename}\"\n            )\n        response = requests.get(self.url_telechargement)\n        with open(full_filename, \"wb\") as file:\n            file.write(response.content)\n    else:\n        if verbose:\n            print(f\"Le fichier {full_filename} existe d\u00e9j\u00e0. Ignor\u00e9.\")\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.exists","title":"<code>exists()</code>","text":"<p>V\u00e9rifie si l'\u00e9pisode existe dans la base de donn\u00e9es.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si l'\u00e9pisode existe, False sinon.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"V\u00e9rifie si l'\u00e9pisode existe dans la base de donn\u00e9es.\n\n    Returns:\n        bool: True si l'\u00e9pisode existe, False sinon.\n    \"\"\"\n    return (\n        self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n        is not None\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.format_duration","title":"<code>format_duration(seconds)</code>  <code>staticmethod</code>","text":"<p>Convertit une dur\u00e9e en secondes au format HH:MM:SS.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>La dur\u00e9e en secondes.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La dur\u00e9e format\u00e9e en cha\u00eene de caract\u00e8res.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef format_duration(seconds: int) -&gt; str:\n    \"\"\"Convertit une dur\u00e9e en secondes au format HH:MM:SS.\n\n    Args:\n        seconds (int): La dur\u00e9e en secondes.\n\n    Returns:\n        str: La dur\u00e9e format\u00e9e en cha\u00eene de caract\u00e8res.\n    \"\"\"\n    if seconds &lt; 0:\n        return f\"-{Episode.format_duration(-seconds)}\"\n    hours = seconds // 3600\n    minutes = (seconds % 3600) // 60\n    seconds = seconds % 60\n    return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.from_date","title":"<code>from_date(date, collection_name='episodes')</code>  <code>classmethod</code>","text":"<p>Cr\u00e9e un \u00e9pisode \u00e0 partir d'une date dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>datetime</code> <p>La date recherch\u00e9e.</p> required <code>collection_name</code> <code>str</code> <p>Le nom de la collection. D\u00e9faut: \"episodes\".</p> <code>'episodes'</code> <p>Returns:</p> Type Description <code>Optional[Episode]</code> <p>Optional[Episode]: L'instance d'Episode si trouv\u00e9e, sinon None.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_date(\n    cls, date: datetime, collection_name: str = \"episodes\"\n) -&gt; Optional[\"Episode\"]:\n    \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'une date dans la base de donn\u00e9es.\n\n    Args:\n        date (datetime): La date recherch\u00e9e.\n        collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n    Returns:\n        Optional[Episode]: L'instance d'Episode si trouv\u00e9e, sinon None.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    start_date = datetime(date.year, date.month, date.day)\n    end_date = datetime(date.year, date.month, date.day, 23, 59, 59)\n    document = collection.find_one({\"date\": {\"$gte\": start_date, \"$lte\": end_date}})\n    if document:\n        date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n        instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n        return instance\n    else:\n        return None\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.from_oid","title":"<code>from_oid(oid, collection_name='episodes')</code>  <code>classmethod</code>","text":"<p>Cr\u00e9e un \u00e9pisode \u00e0 partir d'un ObjectId dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>ObjectId</code> <p>L'identifiant de l'\u00e9pisode dans Mongo.</p> required <code>collection_name</code> <code>str</code> <p>Le nom de la collection. D\u00e9faut: \"episodes\".</p> <code>'episodes'</code> <p>Returns:</p> Name Type Description <code>Episode</code> <code>Episode</code> <p>L'instance d'Episode correspondante.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_oid(cls, oid: ObjectId, collection_name: str = \"episodes\") -&gt; \"Episode\":\n    \"\"\"Cr\u00e9e un \u00e9pisode \u00e0 partir d'un ObjectId dans la base de donn\u00e9es.\n\n    Args:\n        oid (ObjectId): L'identifiant de l'\u00e9pisode dans Mongo.\n        collection_name (str, optional): Le nom de la collection. D\u00e9faut: \"episodes\".\n\n    Returns:\n        Episode: L'instance d'Episode correspondante.\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    document = collection.find_one({\"_id\": oid})\n    date_doc_str = cls.get_string_from_date(document.get(\"date\"), DATE_FORMAT)\n    instance = cls(date=date_doc_str, titre=document.get(\"titre\"))\n    return instance\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_all_auteurs","title":"<code>get_all_auteurs()</code>","text":"<p>Extrait la liste de tous les auteurs mentionn\u00e9s dans la transcription.</p> Notes <p>Utilise le mod\u00e8le GPT-4 via Azure LLM pour extraire une liste JSON de noms d'auteurs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: La liste des auteurs d\u00e9tect\u00e9s.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>    def get_all_auteurs(self) -&gt; List[str]:\n        \"\"\"Extrait la liste de tous les auteurs mentionn\u00e9s dans la transcription.\n\n        Notes:\n            Utilise le mod\u00e8le GPT-4 via Azure LLM pour extraire une liste JSON de noms d'auteurs.\n\n        Returns:\n            List[str]: La liste des auteurs d\u00e9tect\u00e9s.\n        \"\"\"\n        if self.transcription is None:\n            return []\n\n        llm_structured_output = get_azure_llm(\"gpt-4o\")\n        response_schema = {\n            \"type\": \"json_schema\",\n            \"json_schema\": {\n                \"name\": \"AuthorList\",\n                \"schema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"Authors\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"description\": \"Une liste des auteurs extraits de la transcription\",\n                            },\n                        }\n                    },\n                    \"required\": [\"Authors\"],\n                    \"additionalProperties\": False,\n                },\n            },\n        }\n        response = llm_structured_output.chat(\n            messages=[\n                ChatMessage(\n                    role=\"system\",\n                    content=\"Tu es un assistant utile qui retourne une liste JSON de noms d'auteurs.\",\n                ),\n                ChatMessage(\n                    role=\"user\",\n                    content=f\"Est-ce que tu peux me lister tous les noms d'auteurs dont on parle des oeuvres \\\ndans cette transcription d'un \u00e9pisode du masque et la plume \\\ndiffuse le {self.date.strftime('%d %b %Y')}. \\\nJe veux toujours avoir le pr\u00e9nom et le nom complet de chaque auteur. \\\nVoici cette transcription : {self.transcription} \",\n                ),\n            ],\n            response_format=response_schema,\n        )\n        try:\n            json_dict = json.loads(response.message.content)\n        except json.JSONDecodeError as e:\n            print(\"Error parsing JSON:\", e)\n            print(\"Raw response:\", response.message.content)\n            return []\n        return json_dict[\"Authors\"]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_date_from_string","title":"<code>get_date_from_string(date, DATE_FORMAT=DATE_FORMAT)</code>  <code>staticmethod</code>","text":"<p>Convertit une cha\u00eene de caract\u00e8res en objet datetime.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>La cha\u00eene repr\u00e9sentant la date.</p> required <code>DATE_FORMAT</code> <code>str</code> <p>Le format de la date. D\u00e9faut est DATE_FORMAT.</p> <code>DATE_FORMAT</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>L'objet datetime correspondant.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef get_date_from_string(date: str, DATE_FORMAT: str = DATE_FORMAT) -&gt; datetime:\n    \"\"\"Convertit une cha\u00eene de caract\u00e8res en objet datetime.\n\n    Args:\n        date (str): La cha\u00eene repr\u00e9sentant la date.\n        DATE_FORMAT (str, optional): Le format de la date. D\u00e9faut est DATE_FORMAT.\n\n    Returns:\n        datetime: L'objet datetime correspondant.\n    \"\"\"\n    return datetime.strptime(date, DATE_FORMAT)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_oid","title":"<code>get_oid()</code>","text":"<p>R\u00e9cup\u00e8re l'identifiant Mongo (_id) de l'\u00e9pisode.</p> <p>Returns:</p> Type Description <code>Optional[ObjectId]</code> <p>Optional[ObjectId]: L'ObjectId de l'\u00e9pisode s'il existe, sinon None.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_oid(self) -&gt; Optional[ObjectId]:\n    \"\"\"R\u00e9cup\u00e8re l'identifiant Mongo (_id) de l'\u00e9pisode.\n\n    Returns:\n        Optional[ObjectId]: L'ObjectId de l'\u00e9pisode s'il existe, sinon None.\n    \"\"\"\n    document = self.collection.find_one({\"titre\": self.titre, \"date\": self.date})\n    if document:\n        return document[\"_id\"]\n    else:\n        return None\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.get_string_from_date","title":"<code>get_string_from_date(date, format=None)</code>  <code>staticmethod</code>","text":"<p>Convertit un objet datetime en cha\u00eene de caract\u00e8res.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>datetime</code> <p>L'objet datetime.</p> required <code>format</code> <code>Optional[str]</code> <p>Le format de sortie. Si None, DATE_FORMAT est utilis\u00e9.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La cha\u00eene repr\u00e9sentant la date.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef get_string_from_date(date: datetime, format: Optional[str] = None) -&gt; str:\n    \"\"\"Convertit un objet datetime en cha\u00eene de caract\u00e8res.\n\n    Args:\n        date (datetime): L'objet datetime.\n        format (Optional[str], optional): Le format de sortie. Si None, DATE_FORMAT est utilis\u00e9.\n\n    Returns:\n        str: La cha\u00eene repr\u00e9sentant la date.\n    \"\"\"\n    if format is not None:\n        return date.strftime(format)\n    else:\n        return date.strftime(DATE_FORMAT)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.keep","title":"<code>keep()</code>","text":"<p>T\u00e9l\u00e9charge le fichier audio si n\u00e9cessaire et conserve l'\u00e9pisode dans la base de donn\u00e9es.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>1 si une nouvelle entr\u00e9e est cr\u00e9\u00e9e en base, 0 sinon.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def keep(self) -&gt; int:\n    \"\"\"T\u00e9l\u00e9charge le fichier audio si n\u00e9cessaire et conserve l'\u00e9pisode dans la base de donn\u00e9es.\n\n    Returns:\n        int: 1 si une nouvelle entr\u00e9e est cr\u00e9\u00e9e en base, 0 sinon.\n    \"\"\"\n    message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n    if not self.exists():\n        print(\n            f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} nouveau: Duree: {self.duree}, Type: {self.type}\"\n        )\n        mongolog(\"insert\", self.collection.name, message_log)\n        self.download_audio(verbose=True)\n        self.collection.insert_one(\n            {\n                \"titre\": self.titre,\n                \"date\": self.date,\n                \"description\": self.description,\n                \"url\": self.url_telechargement,\n                \"audio_rel_filename\": self.audio_rel_filename,\n                \"transcription\": self.transcription,\n                \"type\": self.type,\n                \"duree\": self.duree,\n            }\n        )\n        return 1\n    else:\n        print(\n            f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} deja existant\"\n        )\n        mongolog(\"update\", self.collection.name, message_log)\n        return 0\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.remove","title":"<code>remove()</code>","text":"<p>Supprime l'\u00e9pisode de la base de donn\u00e9es.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Supprime l'\u00e9pisode de la base de donn\u00e9es.\"\"\"\n    message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre}\"\n    self.collection.delete_one({\"titre\": self.titre, \"date\": self.date})\n    mongolog(\"delete\", self.collection.name, message_log)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.set_transcription","title":"<code>set_transcription(verbose=False, keep_cache=True)</code>","text":"<p>Extrait et sauvegarde la transcription de l'audio en utilisant un mod\u00e8le Whisper.</p> <p>Utilise le cache si disponible ou extrait la transcription de l'audio.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Si True, affiche des messages d'information. D\u00e9faut False.</p> <code>False</code> <code>keep_cache</code> <code>bool</code> <p>Si True, sauvegarde la transcription dans un fichier cache. D\u00e9faut True.</p> <code>True</code> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def set_transcription(self, verbose: bool = False, keep_cache: bool = True) -&gt; None:\n    \"\"\"Extrait et sauvegarde la transcription de l'audio en utilisant un mod\u00e8le Whisper.\n\n    Utilise le cache si disponible ou extrait la transcription de l'audio.\n\n    Args:\n        verbose (bool, optional): Si True, affiche des messages d'information. D\u00e9faut False.\n        keep_cache (bool, optional): Si True, sauvegarde la transcription dans un fichier cache. D\u00e9faut True.\n    \"\"\"\n    if self.transcription is not None:\n        if verbose:\n            print(\"Transcription existe deja\")\n        return\n    mp3_fullfilename = get_audio_path(AUDIO_PATH, year=\"\") + self.audio_rel_filename\n    cache_transcription_filename = f\"{os.path.splitext(mp3_fullfilename)[0]}.txt\"\n    if os.path.exists(cache_transcription_filename):\n        if verbose:\n            print(f\"Transcription cachee trouvee: {cache_transcription_filename}\")\n        with open(cache_transcription_filename, \"r\") as file:\n            self.transcription = file.read()\n        self.collection.update_one(\n            {\"_id\": self.get_oid()},\n            {\"$set\": {\"transcription\": self.transcription}},\n        )\n        return\n\n    self.transcription = extract_whisper(mp3_fullfilename)\n    if keep_cache:\n        with open(cache_transcription_filename, \"w\") as f:\n            f.write(self.transcription)\n    self.collection.update_one(\n        {\"_id\": self.get_oid()}, {\"$set\": {\"transcription\": self.transcription}}\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.to_dict","title":"<code>to_dict()</code>","text":"<p>Convertit l'\u00e9pisode en dictionnaire.</p> <p>Returns:</p> Type Description <code>Dict[str, Union[str, datetime, int, None]]</code> <p>Dict[str, Union[str, datetime, int, None]]: Dictionnaire contenant les informations de l'\u00e9pisode. Les cl\u00e9s sont ['date', 'titre', 'description', 'url_telechargement', 'audio_rel_filename', 'transcription', 'type', 'duree'].</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Union[str, datetime, int, None]]:\n    \"\"\"Convertit l'\u00e9pisode en dictionnaire.\n\n    Returns:\n        Dict[str, Union[str, datetime, int, None]]: Dictionnaire contenant les informations de l'\u00e9pisode.\n            Les cl\u00e9s sont ['date', 'titre', 'description', 'url_telechargement', 'audio_rel_filename', 'transcription', 'type', 'duree'].\n    \"\"\"\n    return {\n        \"date\": self.date,\n        \"titre\": self.titre,\n        \"description\": self.description,\n        \"url_telechargement\": self.url_telechargement,\n        \"audio_rel_filename\": self.audio_rel_filename,\n        \"transcription\": self.transcription,\n        \"type\": self.type,\n        \"duree\": self.duree,\n    }\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episode.update_date","title":"<code>update_date(new_date)</code>","text":"<p>Met \u00e0 jour la date de l'\u00e9pisode dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>new_date</code> <code>datetime</code> <p>La nouvelle date de l'\u00e9pisode.</p> required Source code in <code>nbs/mongo_episode.py</code> <pre><code>def update_date(self, new_date: datetime) -&gt; None:\n    \"\"\"Met \u00e0 jour la date de l'\u00e9pisode dans la base de donn\u00e9es.\n\n    Args:\n        new_date (datetime): La nouvelle date de l'\u00e9pisode.\n    \"\"\"\n    self.collection.update_one(\n        {\"_id\": self.get_oid()}, {\"$set\": {\"date\": new_date}}\n    )\n    message_log = f\"{Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} - {self.titre} -&gt; {Episode.get_string_from_date(new_date, format=LOG_DATE_FORMAT)}\"\n    self.date = new_date\n    mongolog(\"force_update\", self.collection.name, message_log)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes","title":"<code>Episodes</code>","text":"<p>Classe pour rechercher et g\u00e9rer la qualit\u00e9 des donn\u00e9es des \u00e9pisodes.</p> <p>Cette classe permet par exemple de r\u00e9cup\u00e9rer de nouvelles transcriptions en se connectant \u00e0 la base de donn\u00e9es MongoDB.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>class Episodes:\n    \"\"\"Classe pour rechercher et g\u00e9rer la qualit\u00e9 des donn\u00e9es des \u00e9pisodes.\n\n    Cette classe permet par exemple de r\u00e9cup\u00e9rer de nouvelles transcriptions\n    en se connectant \u00e0 la base de donn\u00e9es MongoDB.\n    \"\"\"\n\n    def __init__(self, collection_name: str = \"episodes\") -&gt; None:\n        \"\"\"Initialise une instance du gestionnaire d'\u00e9pisodes.\n\n        Se connecte \u00e0 la base de donn\u00e9es et charge les \u00e9pisodes.\n\n        Args:\n            collection_name (str): Nom de la collection \u00e0 utiliser. Par d\u00e9faut \"episodes\".\n        \"\"\"\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n        )\n        # je ne charge plus par defaut tous les episodes c'est inefficace\n        self.oid_episodes = []\n\n    # def _load_all_episodes(self) -&gt; List[\"Episode\"]:\n    #     \"\"\"Charge tous les \u00e9pisodes depuis la base de donn\u00e9es.\n\n    #     Returns:\n    #         List[Episode]: Liste des \u00e9pisodes charg\u00e9s.\n    #     \"\"\"\n    #     return self.get_entries()\n\n    def get_entries(self, request: Any = \"\", limit: int = -1):\n        \"\"\"\n        Mets dans self.oid_episodes les oids correspondant \u00e0 une requ\u00eate sp\u00e9cifique, tri\u00e9s par date d\u00e9croissante.\n        Si limit est sp\u00e9cifi\u00e9, seuls les limit premiers r\u00e9sultats sont conserv\u00e9s.\n        Args:\n            request (Any): Requ\u00eate MongoDB \u00e0 ex\u00e9cuter. Exemples:\n                {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}.\n                Par d\u00e9faut, une requ\u00eate vide qui retourne tous les \u00e9pisodes.\n        \"\"\"\n        if limit == -1:\n            results = self.collection.find(request, {\"_id\": 1}).sort({\"date\": -1})\n        else:\n            results = (\n                self.collection.find(request, {\"_id\": 1})\n                .sort({\"date\": -1})\n                .limit(limit)\n            )\n        self.oid_episodes = [document[\"_id\"] for document in results]\n\n    def len_total_entries(self) -&gt; int:\n        \"\"\"\n        Retourne le nombre total d'\u00e9pisodes dans la collection.\"\"\"\n        return self.collection.estimated_document_count()\n\n    def get_missing_transcriptions(self):\n        \"\"\"\n        Mets dans self.oid_episodes les oids correspondant aux \u00e9pisodes sans transcription.\n        \"\"\"\n        self.get_entries({\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]})\n\n    def get_transcriptions(self):\n        \"\"\"\n        Mets dans self.oid_episodes les oids correspondant aux \u00e9pisodes qui poss\u00e8dent une transcription.\n        \"\"\"\n        self.get_entries(\n            {\"$and\": [{\"transcription\": {\"$ne\": None}}, {\"transcription\": {\"$ne\": \"\"}}]}\n        )\n\n    def __getitem__(self, index: int) -&gt; \"Episode\":\n        \"\"\"Permet l'acc\u00e8s aux \u00e9pisodes par indexation.\n\n        Args:\n            index (int): Position de l'\u00e9pisode dans la liste.\n\n        Returns:\n            Episode: L'\u00e9pisode \u00e0 la position donn\u00e9e.\n        \"\"\"\n        return Episode.from_oid(self.oid_episodes[index])\n\n    def __len__(self) -&gt; int:\n        \"\"\"Retourne le nombre total d'\u00e9pisodes dans oid_episodes.\n\n        Returns:\n            int: Nombre d'\u00e9pisodes.\n        \"\"\"\n        return len(self.oid_episodes)\n\n    def __iter__(self) -&gt; Iterator[\"Episode\"]:\n        \"\"\"Permet d'it\u00e9rer sur les \u00e9pisodes.\n\n        Returns:\n            Iterator[Episode]: It\u00e9rateur sur la liste des \u00e9pisodes.\n        \"\"\"\n        return iter(self.oid_episodes)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Permet l'acc\u00e8s aux \u00e9pisodes par indexation.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Position de l'\u00e9pisode dans la liste.</p> required <p>Returns:</p> Name Type Description <code>Episode</code> <code>Episode</code> <p>L'\u00e9pisode \u00e0 la position donn\u00e9e.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __getitem__(self, index: int) -&gt; \"Episode\":\n    \"\"\"Permet l'acc\u00e8s aux \u00e9pisodes par indexation.\n\n    Args:\n        index (int): Position de l'\u00e9pisode dans la liste.\n\n    Returns:\n        Episode: L'\u00e9pisode \u00e0 la position donn\u00e9e.\n    \"\"\"\n    return Episode.from_oid(self.oid_episodes[index])\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__init__","title":"<code>__init__(collection_name='episodes')</code>","text":"<p>Initialise une instance du gestionnaire d'\u00e9pisodes.</p> <p>Se connecte \u00e0 la base de donn\u00e9es et charge les \u00e9pisodes.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Nom de la collection \u00e0 utiliser. Par d\u00e9faut \"episodes\".</p> <code>'episodes'</code> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(self, collection_name: str = \"episodes\") -&gt; None:\n    \"\"\"Initialise une instance du gestionnaire d'\u00e9pisodes.\n\n    Se connecte \u00e0 la base de donn\u00e9es et charge les \u00e9pisodes.\n\n    Args:\n        collection_name (str): Nom de la collection \u00e0 utiliser. Par d\u00e9faut \"episodes\".\n    \"\"\"\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=collection_name\n    )\n    # je ne charge plus par defaut tous les episodes c'est inefficace\n    self.oid_episodes = []\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__iter__","title":"<code>__iter__()</code>","text":"<p>Permet d'it\u00e9rer sur les \u00e9pisodes.</p> <p>Returns:</p> Type Description <code>Iterator[Episode]</code> <p>Iterator[Episode]: It\u00e9rateur sur la liste des \u00e9pisodes.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __iter__(self) -&gt; Iterator[\"Episode\"]:\n    \"\"\"Permet d'it\u00e9rer sur les \u00e9pisodes.\n\n    Returns:\n        Iterator[Episode]: It\u00e9rateur sur la liste des \u00e9pisodes.\n    \"\"\"\n    return iter(self.oid_episodes)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.__len__","title":"<code>__len__()</code>","text":"<p>Retourne le nombre total d'\u00e9pisodes dans oid_episodes.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Nombre d'\u00e9pisodes.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Retourne le nombre total d'\u00e9pisodes dans oid_episodes.\n\n    Returns:\n        int: Nombre d'\u00e9pisodes.\n    \"\"\"\n    return len(self.oid_episodes)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.get_entries","title":"<code>get_entries(request='', limit=-1)</code>","text":"<p>Mets dans self.oid_episodes les oids correspondant \u00e0 une requ\u00eate sp\u00e9cifique, tri\u00e9s par date d\u00e9croissante. Si limit est sp\u00e9cifi\u00e9, seuls les limit premiers r\u00e9sultats sont conserv\u00e9s. Args:     request (Any): Requ\u00eate MongoDB \u00e0 ex\u00e9cuter. Exemples:         {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}.         Par d\u00e9faut, une requ\u00eate vide qui retourne tous les \u00e9pisodes.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_entries(self, request: Any = \"\", limit: int = -1):\n    \"\"\"\n    Mets dans self.oid_episodes les oids correspondant \u00e0 une requ\u00eate sp\u00e9cifique, tri\u00e9s par date d\u00e9croissante.\n    Si limit est sp\u00e9cifi\u00e9, seuls les limit premiers r\u00e9sultats sont conserv\u00e9s.\n    Args:\n        request (Any): Requ\u00eate MongoDB \u00e0 ex\u00e9cuter. Exemples:\n            {\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]}.\n            Par d\u00e9faut, une requ\u00eate vide qui retourne tous les \u00e9pisodes.\n    \"\"\"\n    if limit == -1:\n        results = self.collection.find(request, {\"_id\": 1}).sort({\"date\": -1})\n    else:\n        results = (\n            self.collection.find(request, {\"_id\": 1})\n            .sort({\"date\": -1})\n            .limit(limit)\n        )\n    self.oid_episodes = [document[\"_id\"] for document in results]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.get_missing_transcriptions","title":"<code>get_missing_transcriptions()</code>","text":"<p>Mets dans self.oid_episodes les oids correspondant aux \u00e9pisodes sans transcription.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_missing_transcriptions(self):\n    \"\"\"\n    Mets dans self.oid_episodes les oids correspondant aux \u00e9pisodes sans transcription.\n    \"\"\"\n    self.get_entries({\"$or\": [{\"transcription\": \"\"}, {\"transcription\": None}]})\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.get_transcriptions","title":"<code>get_transcriptions()</code>","text":"<p>Mets dans self.oid_episodes les oids correspondant aux \u00e9pisodes qui poss\u00e8dent une transcription.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def get_transcriptions(self):\n    \"\"\"\n    Mets dans self.oid_episodes les oids correspondant aux \u00e9pisodes qui poss\u00e8dent une transcription.\n    \"\"\"\n    self.get_entries(\n        {\"$and\": [{\"transcription\": {\"$ne\": None}}, {\"transcription\": {\"$ne\": \"\"}}]}\n    )\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.Episodes.len_total_entries","title":"<code>len_total_entries()</code>","text":"<p>Retourne le nombre total d'\u00e9pisodes dans la collection.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def len_total_entries(self) -&gt; int:\n    \"\"\"\n    Retourne le nombre total d'\u00e9pisodes dans la collection.\"\"\"\n    return self.collection.estimated_document_count()\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode","title":"<code>RSS_episode</code>","text":"<p>               Bases: <code>Episode</code></p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>class RSS_episode(Episode):\n    def __init__(self, date: str, titre: str) -&gt; None:\n        \"\"\"\n        Initialize an RSS_episode instance.\n\n        Args:\n            date (str): The episode date in the format \"2024-12-22T09:59:39\".\n            titre (str): The title of the episode.\n        \"\"\"\n        super().__init__(date, titre)\n\n    @classmethod\n    def from_feed_entry(cls, feed_entry: FeedParserDict) -&gt; \"RSS_episode\":\n        \"\"\"\n        Create an RSS_episode instance from an RSS feed entry.\n\n        Args:\n            feed_entry (FeedParserDict): The entry from the RSS feed.\n\n        Returns:\n            RSS_episode: The created RSS_episode instance.\n        \"\"\"\n        locale.setlocale(locale.LC_TIME, \"en_US.UTF-8\")\n        date_rss: datetime = datetime.strptime(feed_entry.published, RSS_DATE_FORMAT)\n        date_rss_str: str = cls.get_string_from_date(date_rss, DATE_FORMAT)\n        inst = cls(\n            date=date_rss_str,\n            titre=feed_entry.title,\n        )\n        inst.description = feed_entry.summary\n\n        for link in feed_entry.links:\n            if link.type == \"audio/mpeg\":\n                inst.url_telechargement = link.href\n                break\n\n        inst.type = cls.set_titre(inst.titre + \" \" + inst.description)\n        inst.duree = cls.get_duree_in_seconds(feed_entry.itunes_duration)  # in seconds\n\n        return inst\n\n    @staticmethod\n    def get_duree_in_seconds(duree: str) -&gt; int:\n        \"\"\"\n        Convert a duration string into total seconds.\n\n        The duration can be in formats \"HH:MM:SS\", \"HH:MM\", or simply seconds.\n\n        Args:\n            duree (str): The duration as a string.\n\n        Returns:\n            int: The duration expressed in total seconds.\n        \"\"\"\n        duree_parts = duree.split(\":\")\n        if len(duree_parts) == 3:\n            return (\n                int(duree_parts[0]) * 3600\n                + int(duree_parts[1]) * 60\n                + int(duree_parts[2])\n            )\n        elif len(duree_parts) == 2:\n            return int(duree_parts[0]) * 60 + int(duree_parts[1])\n        else:\n            return int(duree_parts[0])\n\n    def keep(self) -&gt; int:\n        \"\"\"\n        Save the episode to the database if conditions are met.\n\n        The episode is saved if:\n            - The duration is greater than RSS_DUREE_MINI_MINUTES * 60 seconds.\n            - The type is equal to \"livres\".\n\n        Returns:\n            int: 1 if an entry is created in the database, 0 otherwise.\n        \"\"\"\n        if (self.duree &gt; RSS_DUREE_MINI_MINUTES * 60) and (self.type == \"livres\"):\n            return super().keep()\n        else:\n            print(\n                f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} ignored: Duree: {self.duree}, Type: {self.type}\"\n            )\n            return 0\n\n    @staticmethod\n    def set_titre(description: str) -&gt; str:\n        \"\"\"\n        Classify the episode by using a zero-shot classification model from HuggingFace based on the provided description.\n\n        Args:\n            description (str): The description combining the title and summary.\n\n        Returns:\n            str: The label with the highest score among [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"].\n        \"\"\"\n        classifier = pipeline(\n            \"zero-shot-classification\", model=\"facebook/bart-large-mnli\"\n        )\n        labels = [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"]\n\n        result = classifier(description, labels)\n        return result[\"labels\"][0]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.__init__","title":"<code>__init__(date, titre)</code>","text":"<p>Initialize an RSS_episode instance.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>The episode date in the format \"2024-12-22T09:59:39\".</p> required <code>titre</code> <code>str</code> <p>The title of the episode.</p> required Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(self, date: str, titre: str) -&gt; None:\n    \"\"\"\n    Initialize an RSS_episode instance.\n\n    Args:\n        date (str): The episode date in the format \"2024-12-22T09:59:39\".\n        titre (str): The title of the episode.\n    \"\"\"\n    super().__init__(date, titre)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.from_feed_entry","title":"<code>from_feed_entry(feed_entry)</code>  <code>classmethod</code>","text":"<p>Create an RSS_episode instance from an RSS feed entry.</p> <p>Parameters:</p> Name Type Description Default <code>feed_entry</code> <code>FeedParserDict</code> <p>The entry from the RSS feed.</p> required <p>Returns:</p> Name Type Description <code>RSS_episode</code> <code>RSS_episode</code> <p>The created RSS_episode instance.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_feed_entry(cls, feed_entry: FeedParserDict) -&gt; \"RSS_episode\":\n    \"\"\"\n    Create an RSS_episode instance from an RSS feed entry.\n\n    Args:\n        feed_entry (FeedParserDict): The entry from the RSS feed.\n\n    Returns:\n        RSS_episode: The created RSS_episode instance.\n    \"\"\"\n    locale.setlocale(locale.LC_TIME, \"en_US.UTF-8\")\n    date_rss: datetime = datetime.strptime(feed_entry.published, RSS_DATE_FORMAT)\n    date_rss_str: str = cls.get_string_from_date(date_rss, DATE_FORMAT)\n    inst = cls(\n        date=date_rss_str,\n        titre=feed_entry.title,\n    )\n    inst.description = feed_entry.summary\n\n    for link in feed_entry.links:\n        if link.type == \"audio/mpeg\":\n            inst.url_telechargement = link.href\n            break\n\n    inst.type = cls.set_titre(inst.titre + \" \" + inst.description)\n    inst.duree = cls.get_duree_in_seconds(feed_entry.itunes_duration)  # in seconds\n\n    return inst\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.get_duree_in_seconds","title":"<code>get_duree_in_seconds(duree)</code>  <code>staticmethod</code>","text":"<p>Convert a duration string into total seconds.</p> <p>The duration can be in formats \"HH:MM:SS\", \"HH:MM\", or simply seconds.</p> <p>Parameters:</p> Name Type Description Default <code>duree</code> <code>str</code> <p>The duration as a string.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The duration expressed in total seconds.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef get_duree_in_seconds(duree: str) -&gt; int:\n    \"\"\"\n    Convert a duration string into total seconds.\n\n    The duration can be in formats \"HH:MM:SS\", \"HH:MM\", or simply seconds.\n\n    Args:\n        duree (str): The duration as a string.\n\n    Returns:\n        int: The duration expressed in total seconds.\n    \"\"\"\n    duree_parts = duree.split(\":\")\n    if len(duree_parts) == 3:\n        return (\n            int(duree_parts[0]) * 3600\n            + int(duree_parts[1]) * 60\n            + int(duree_parts[2])\n        )\n    elif len(duree_parts) == 2:\n        return int(duree_parts[0]) * 60 + int(duree_parts[1])\n    else:\n        return int(duree_parts[0])\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.keep","title":"<code>keep()</code>","text":"<p>Save the episode to the database if conditions are met.</p> The episode is saved if <ul> <li>The duration is greater than RSS_DUREE_MINI_MINUTES * 60 seconds.</li> <li>The type is equal to \"livres\".</li> </ul> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>1 if an entry is created in the database, 0 otherwise.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>def keep(self) -&gt; int:\n    \"\"\"\n    Save the episode to the database if conditions are met.\n\n    The episode is saved if:\n        - The duration is greater than RSS_DUREE_MINI_MINUTES * 60 seconds.\n        - The type is equal to \"livres\".\n\n    Returns:\n        int: 1 if an entry is created in the database, 0 otherwise.\n    \"\"\"\n    if (self.duree &gt; RSS_DUREE_MINI_MINUTES * 60) and (self.type == \"livres\"):\n        return super().keep()\n    else:\n        print(\n            f\"Episode du {Episode.get_string_from_date(self.date, format=LOG_DATE_FORMAT)} ignored: Duree: {self.duree}, Type: {self.type}\"\n        )\n        return 0\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.RSS_episode.set_titre","title":"<code>set_titre(description)</code>  <code>staticmethod</code>","text":"<p>Classify the episode by using a zero-shot classification model from HuggingFace based on the provided description.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description combining the title and summary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The label with the highest score among [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"].</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@staticmethod\ndef set_titre(description: str) -&gt; str:\n    \"\"\"\n    Classify the episode by using a zero-shot classification model from HuggingFace based on the provided description.\n\n    Args:\n        description (str): The description combining the title and summary.\n\n    Returns:\n        str: The label with the highest score among [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"].\n    \"\"\"\n    classifier = pipeline(\n        \"zero-shot-classification\", model=\"facebook/bart-large-mnli\"\n    )\n    labels = [\"livres\", \"films\", \"pi\u00e8ces de th\u00e9\u00e2tre\"]\n\n    result = classifier(description, labels)\n    return result[\"labels\"][0]\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode","title":"<code>WEB_episode</code>","text":"<p>               Bases: <code>Episode</code></p> <p>Repr\u00e9sente un \u00e9pisode web avec ses attributs et m\u00e9thodes de conversion et r\u00e9cup\u00e9ration des donn\u00e9es.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>class WEB_episode(Episode):\n    \"\"\"Repr\u00e9sente un \u00e9pisode web avec ses attributs et m\u00e9thodes de conversion et r\u00e9cup\u00e9ration des donn\u00e9es.\"\"\"\n\n    def __init__(self, date: str, titre: str) -&gt; None:\n        \"\"\"Initialise une instance de WEB_episode.\n\n        Args:\n            date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\".\n            titre (str): Le titre de l'\u00e9pisode.\n        \"\"\"\n        super().__init__(date, titre)\n\n    @staticmethod\n    def parse_web_date(\n        web_date: str, web_date_format: str = WEB_DATE_FORMAT\n    ) -&gt; Optional[datetime]:\n        \"\"\"Convertit une date en fran\u00e7ais extraite d'une page web en un objet datetime.\n\n        Corrige les abr\u00e9viations non standard pour certains mois (exemple : \"f\u00e9v.\" devient \"f\u00e9vr.\", \"juill.\" devient \"juil.\").\n\n        Args:\n            web_date (str): La cha\u00eene repr\u00e9sentant la date en fran\u00e7ais.\n            web_date_format (str, optional): Le format de la date utilis\u00e9 par la page web. Defaults to WEB_DATE_FORMAT.\n\n        Returns:\n            Optional[datetime]: L'objet datetime si la conversion r\u00e9ussit, sinon None.\n        \"\"\"\n        locale.setlocale(locale.LC_TIME, \"fr_FR.UTF-8\")\n\n        def corrige_date(date_str: str) -&gt; str:\n            \"\"\"Corrige les abr\u00e9viations non standard dans la cha\u00eene de date.\n\n            Args:\n                date_str (str): La cha\u00eene de date originale.\n\n            Returns:\n                str: La cha\u00eene de date corrig\u00e9e.\n            \"\"\"\n            month_replacements = {\n                \"f\u00e9v.\": \"f\u00e9vr.\",\n                \"juill.\": \"juil.\",\n            }\n            for fr_month, fr_month_norm in month_replacements.items():\n                date_str = date_str.replace(fr_month, fr_month_norm)\n            return date_str\n\n        try:\n            dt: datetime = datetime.strptime(corrige_date(web_date), web_date_format)\n            return dt\n        except ValueError as e:\n            print(f\"Erreur de conversion pour la date '{web_date}': {e}\")\n            return None\n\n    @staticmethod\n    def get_audio_url(url: str) -&gt; Optional[str]:\n        \"\"\"R\u00e9cup\u00e8re l'URL du fichier audio (.m4a ou .mp3) \u00e0 partir de la page d'un \u00e9pisode.\n\n        Recherche dans une balise &lt;script&gt; contenant la cl\u00e9 \"contentUrl\".\n\n        Args:\n            url (str): L'URL de la page de l'\u00e9pisode.\n\n        Returns:\n            Optional[str]: L'URL du fichier audio si trouv\u00e9e, sinon None.\n        \"\"\"\n        try:\n            response: requests.Response = requests.get(url)\n            response.raise_for_status()\n        except requests.RequestException as e:\n            print(f\"Erreur lors de la requ\u00eate HTTP: {e}\")\n            return None\n\n        soup: BeautifulSoup = BeautifulSoup(response.content, \"html.parser\")\n        script_tag = soup.find(\"script\", string=lambda t: t and \"contentUrl\" in t)\n\n        if script_tag:\n            try:\n                json_text: str = script_tag.string  # type: ignore\n                json_data: Dict[str, Any] = json.loads(json_text)\n                audio_url: Optional[str] = None\n                for item in json_data.get(\"@graph\", []):\n                    if item.get(\"@type\") == \"RadioEpisode\":\n                        main_entity: Dict[str, Any] = item.get(\"mainEntity\", {})\n                        audio_url = main_entity.get(\"contentUrl\")\n                        break\n                return audio_url\n            except (json.JSONDecodeError, KeyError, TypeError) as e:\n                print(f\"Erreur lors de l'analyse du JSON: {e}\")\n                return None\n\n        print(\"Balise &lt;script&gt; contenant 'contentUrl' non trouv\u00e9e\")\n        return None\n\n    @classmethod\n    def from_webpage_entry(cls, dict_web_episode: Dict[str, Any]) -&gt; \"WEB_episode\":\n        \"\"\"Cr\u00e9e une instance de WEB_episode \u00e0 partir d'un dictionnaire repr\u00e9sentant une entr\u00e9e de page web.\n\n        Le dictionnaire doit contenir les cl\u00e9s : 'title', 'url', 'description', 'date', 'duration'.\n        La variable DATE_FORMAT et la m\u00e9thode get_string_from_date doivent \u00eatre d\u00e9finies ailleurs dans le code.\n\n        Args:\n            dict_web_episode (Dict[str, Any]): Dictionnaire contenant les informations de l'\u00e9pisode.\n\n        Returns:\n            WEB_episode: Une instance de WEB_episode initialis\u00e9e avec les donn\u00e9es fournies.\n        \"\"\"\n        date_web: Optional[datetime] = cls.parse_web_date(dict_web_episode[\"date\"])\n        date_web_str: str = cls.get_string_from_date(\n            date_web, DATE_FORMAT\n        )  # DATE_FORMAT doit \u00eatre d\u00e9fini en amont\n        inst: WEB_episode = cls(\n            date=date_web_str,\n            titre=dict_web_episode[\"title\"],\n        )\n        inst.description = dict_web_episode[\"description\"]\n        inst.type = \"livres\"\n        inst.url_telechargement = cls.get_audio_url(dict_web_episode[\"url\"])\n        inst.duree = cls.get_duree_in_seconds(dict_web_episode[\"duration\"])\n        return inst\n\n    @staticmethod\n    def get_duree_in_seconds(duree: str) -&gt; int:\n        \"\"\"Convertit une dur\u00e9e exprim\u00e9e en minutes (\"MM min\") en secondes.\n\n        Args:\n            duree (str): La dur\u00e9e sous forme de cha\u00eene.\n\n        Returns:\n            int: La dur\u00e9e convertie en secondes. Retourne 0 si le format n'est pas correct.\n        \"\"\"\n        parts = duree.split(\" \")\n        if len(parts) == 2:\n            return int(parts[0]) * 60\n        return 0\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode.__init__","title":"<code>__init__(date, titre)</code>","text":"<p>Initialise une instance de WEB_episode.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str</code> <p>La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\".</p> required <code>titre</code> <code>str</code> <p>Le titre de l'\u00e9pisode.</p> required Source code in <code>nbs/mongo_episode.py</code> <pre><code>def __init__(self, date: str, titre: str) -&gt; None:\n    \"\"\"Initialise une instance de WEB_episode.\n\n    Args:\n        date (str): La date de l'\u00e9pisode au format \"2024-12-22T09:59:39\".\n        titre (str): Le titre de l'\u00e9pisode.\n    \"\"\"\n    super().__init__(date, titre)\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode.from_webpage_entry","title":"<code>from_webpage_entry(dict_web_episode)</code>  <code>classmethod</code>","text":"<p>Cr\u00e9e une instance de WEB_episode \u00e0 partir d'un dictionnaire repr\u00e9sentant une entr\u00e9e de page web.</p> <p>Le dictionnaire doit contenir les cl\u00e9s : 'title', 'url', 'description', 'date', 'duration'. La variable DATE_FORMAT et la m\u00e9thode get_string_from_date doivent \u00eatre d\u00e9finies ailleurs dans le code.</p> <p>Parameters:</p> Name Type Description Default <code>dict_web_episode</code> <code>Dict[str, Any]</code> <p>Dictionnaire contenant les informations de l'\u00e9pisode.</p> required <p>Returns:</p> Name Type Description <code>WEB_episode</code> <code>WEB_episode</code> <p>Une instance de WEB_episode initialis\u00e9e avec les donn\u00e9es fournies.</p> Source code in <code>nbs/mongo_episode.py</code> <pre><code>@classmethod\ndef from_webpage_entry(cls, dict_web_episode: Dict[str, Any]) -&gt; \"WEB_episode\":\n    \"\"\"Cr\u00e9e une instance de WEB_episode \u00e0 partir d'un dictionnaire repr\u00e9sentant une entr\u00e9e de page web.\n\n    Le dictionnaire doit contenir les cl\u00e9s : 'title', 'url', 'description', 'date', 'duration'.\n    La variable DATE_FORMAT et la m\u00e9thode get_string_from_date doivent \u00eatre d\u00e9finies ailleurs dans le code.\n\n    Args:\n        dict_web_episode (Dict[str, Any]): Dictionnaire contenant les informations de l'\u00e9pisode.\n\n    Returns:\n        WEB_episode: Une instance de WEB_episode initialis\u00e9e avec les donn\u00e9es fournies.\n    \"\"\"\n    date_web: Optional[datetime] = cls.parse_web_date(dict_web_episode[\"date\"])\n    date_web_str: str = cls.get_string_from_date(\n        date_web, DATE_FORMAT\n    )  # DATE_FORMAT doit \u00eatre d\u00e9fini en amont\n    inst: WEB_episode = cls(\n        date=date_web_str,\n        titre=dict_web_episode[\"title\"],\n    )\n    inst.description = dict_web_episode[\"description\"]\n    inst.type = \"livres\"\n    inst.url_telechargement = cls.get_audio_url(dict_web_episode[\"url\"])\n    inst.duree = cls.get_duree_in_seconds(dict_web_episode[\"duration\"])\n    return inst\n</code></pre>"},{"location":"mongo_episode/#mongo_episode.WEB_episode.get_audio_url","title":"<code>get_audio_url(url)</code>  <code>staticmethod</code>","text":"<p>R\u00e9cup\u00e8re l'URL du fichier audio (.m4a ou .mp3) \u00e0 partir de la page d'un \u00e9pisode.</p> <p>Recherche dans une balise"},{"location":"mongo_livre/","title":"Module mongo_livre","text":""},{"location":"mongo_livre/#mongo_livre.Livre","title":"<code>Livre</code>","text":"<p>               Bases: <code>BaseEntity</code></p> Source code in <code>nbs/mongo_livre.py</code> <pre><code>class Livre(BaseEntity):\n    collection: str = \"livres\"\n\n    def __init__(self, titre: str) -&gt; None:\n        \"\"\"Initialise une instance de livre.\n\n        Args:\n            nom (str): Le titre du livre.\n        \"\"\"\n        super().__init__(titre, self.collection)\n        self.titre = titre  # je le duplique pour la comprehension du concept de livre\n        self.auteur = None  # on mettra l'oid de l'auteur\n        self.editeur = None  # on mettra l'oid de l'editeur\n\n    def add_auteur(self, auteur: Auteur):\n        if auteur is not None:\n            self.auteur = auteur.get_oid()\n\n    def add_editeur(self, editeur: Editeur):\n        if editeur is not None:\n            self.editeur = editeur.get_oid()\n\n    @classmethod\n    def with_details(cls, titre: str, auteur: Auteur, editeur: Editeur):\n        \"\"\"Alternative constructor to instantiate a Livre with title, auteur and editeur.\n\n        Args:\n            titre (str): The title of the book.\n            auteur (Auteur): Instance of Auteur.\n            editeur (Editeur): Instance of Editeur.\n        Returns:\n            Livre: An instance of Livre.\n        \"\"\"\n        instance = cls(titre)\n        instance.add_auteur(auteur)\n        instance.add_editeur(editeur)\n        return instance\n\n    @classmethod\n    def from_oid(cls: Type[T], oid: ObjectId) -&gt; T:\n        \"\"\"Creates an instance of Livre class from a MongoDB ObjectId.\n        Returns None if the ObjectId is not found in the database or is None.\n\n        Args:\n            oid (ObjectId): The MongoDB ObjectId.\n\n        Returns:\n            T: An instance of the derived class.\n        \"\"\"\n        if oid is None:\n            return None\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n        )\n        document = collection.find_one({\"_id\": oid})\n        if document is None:\n            return None\n        inst = cls.with_details(\n            document.get(\"titre\"),\n            Auteur.from_oid(document.get(\"auteur\")),\n            Editeur.from_oid(document.get(\"editeur\")),\n        )\n        return inst\n\n    def __str__(self) -&gt; str:\n        \"\"\"Official string representation of the entity.\n\n        Returns:\n            str: The name of the entity: Titre, Auteur, Editeur.\n        \"\"\"\n        return f\"\"\"\n        Titre: {self.titre}\n        Auteur: {Auteur.from_oid(self.auteur) if self.auteur is not None else None}\n        Editeur: {Editeur.from_oid(self.editeur) if self.editeur is not None else None}\n        \"\"\"\n</code></pre>"},{"location":"mongo_livre/#mongo_livre.Livre.__init__","title":"<code>__init__(titre)</code>","text":"<p>Initialise une instance de livre.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>str</code> <p>Le titre du livre.</p> required Source code in <code>nbs/mongo_livre.py</code> <pre><code>def __init__(self, titre: str) -&gt; None:\n    \"\"\"Initialise une instance de livre.\n\n    Args:\n        nom (str): Le titre du livre.\n    \"\"\"\n    super().__init__(titre, self.collection)\n    self.titre = titre  # je le duplique pour la comprehension du concept de livre\n    self.auteur = None  # on mettra l'oid de l'auteur\n    self.editeur = None  # on mettra l'oid de l'editeur\n</code></pre>"},{"location":"mongo_livre/#mongo_livre.Livre.__str__","title":"<code>__str__()</code>","text":"<p>Official string representation of the entity.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the entity: Titre, Auteur, Editeur.</p> Source code in <code>nbs/mongo_livre.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Official string representation of the entity.\n\n    Returns:\n        str: The name of the entity: Titre, Auteur, Editeur.\n    \"\"\"\n    return f\"\"\"\n    Titre: {self.titre}\n    Auteur: {Auteur.from_oid(self.auteur) if self.auteur is not None else None}\n    Editeur: {Editeur.from_oid(self.editeur) if self.editeur is not None else None}\n    \"\"\"\n</code></pre>"},{"location":"mongo_livre/#mongo_livre.Livre.from_oid","title":"<code>from_oid(oid)</code>  <code>classmethod</code>","text":"<p>Creates an instance of Livre class from a MongoDB ObjectId. Returns None if the ObjectId is not found in the database or is None.</p> <p>Parameters:</p> Name Type Description Default <code>oid</code> <code>ObjectId</code> <p>The MongoDB ObjectId.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the derived class.</p> Source code in <code>nbs/mongo_livre.py</code> <pre><code>@classmethod\ndef from_oid(cls: Type[T], oid: ObjectId) -&gt; T:\n    \"\"\"Creates an instance of Livre class from a MongoDB ObjectId.\n    Returns None if the ObjectId is not found in the database or is None.\n\n    Args:\n        oid (ObjectId): The MongoDB ObjectId.\n\n    Returns:\n        T: An instance of the derived class.\n    \"\"\"\n    if oid is None:\n        return None\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=cls.collection\n    )\n    document = collection.find_one({\"_id\": oid})\n    if document is None:\n        return None\n    inst = cls.with_details(\n        document.get(\"titre\"),\n        Auteur.from_oid(document.get(\"auteur\")),\n        Editeur.from_oid(document.get(\"editeur\")),\n    )\n    return inst\n</code></pre>"},{"location":"mongo_livre/#mongo_livre.Livre.with_details","title":"<code>with_details(titre, auteur, editeur)</code>  <code>classmethod</code>","text":"<p>Alternative constructor to instantiate a Livre with title, auteur and editeur.</p> <p>Parameters:</p> Name Type Description Default <code>titre</code> <code>str</code> <p>The title of the book.</p> required <code>auteur</code> <code>Auteur</code> <p>Instance of Auteur.</p> required <code>editeur</code> <code>Editeur</code> <p>Instance of Editeur.</p> required <p>Returns:     Livre: An instance of Livre.</p> Source code in <code>nbs/mongo_livre.py</code> <pre><code>@classmethod\ndef with_details(cls, titre: str, auteur: Auteur, editeur: Editeur):\n    \"\"\"Alternative constructor to instantiate a Livre with title, auteur and editeur.\n\n    Args:\n        titre (str): The title of the book.\n        auteur (Auteur): Instance of Auteur.\n        editeur (Editeur): Instance of Editeur.\n    Returns:\n        Livre: An instance of Livre.\n    \"\"\"\n    instance = cls(titre)\n    instance.add_auteur(auteur)\n    instance.add_editeur(editeur)\n    return instance\n</code></pre>"},{"location":"readme_data_model/","title":"data model","text":""},{"location":"readme_data_model/#data-model","title":"\ud83c\udfa8 Data model","text":"<p>Here is the data model used for this application \ud83d\udd0d</p> <p> \ud83d\uddbc\ufe0f</p>"},{"location":"readme_data_model/#edit","title":"\ud83d\uddbc\ufe0f Edit","text":"<p>To edit it, I use drawio: lmelp.drawio \u270f\ufe0f</p>"},{"location":"readme_doc/","title":"manage doc","text":"<ul> <li>\ud83d\udcda \u00c9tapes \u00e0 suivre</li> <li>\ud83d\udd27 Installer les d\u00e9pendances</li> <li>\ud83d\ude80 Initialiser le projet MkDocs</li> <li>\u2699\ufe0f Configurer le fichier <code>mkdocs.yml</code></li> <li>\ud83d\udcdd Cr\u00e9er les pages Markdown pour int\u00e9grer la doc extraite</li> <li>\u270f\ufe0f Modifier les docstrings</li> <li>\ud83d\udda5\ufe0f Lancer le serveur de d\u00e9veloppement</li> <li>\ud83c\udfd7\ufe0f G\u00e9n\u00e9rer la documentation statique</li> <li>\ud83d\udea2 Pousser sous github pages</li> <li>\ud83e\udd16 automatisation complete avec github-actions github-pages</li> <li>\ud83d\udcc4 R\u00e9sum\u00e9</li> </ul> <p>Voici une solution compl\u00e8te pour cr\u00e9er une documentation avec MkDocs et le th\u00e8me Material, en incluant l'extraction automatique de la doc de vos fichiers .py gr\u00e2ce \u00e0 l'extension mkdocstrings. \ud83d\udca1</p>"},{"location":"readme_doc/#etapes-a-suivre","title":"\ud83d\udcda \u00c9tapes \u00e0 suivre","text":""},{"location":"readme_doc/#installer-les-dependances","title":"\ud83d\udd27 Installer les d\u00e9pendances","text":"<p>Voici les requirements \u00e0 installer : MkDocs, mkdocs-material, mkdocstrings[python] et mkdocs-include-markdown-plugin. \ud83d\udca1</p> <pre><code>mkdocs \nmkdocs-material \nmkdocstrings[python]\nmkdocs-include-markdown-plugin\n</code></pre>"},{"location":"readme_doc/#initialiser-le-projet-mkdocs","title":"\ud83d\ude80 Initialiser le projet MkDocs","text":"<p>Dans la racine de votre repo, initialisez MkDocs (si vous n\u2019avez pas d\u00e9j\u00e0 de fichier mkdocs.yml) : \ud83d\udca1</p> <pre><code># avec uv\nuv run mkdocs new .\n# avec conda/pip\nmkdocs new .\n</code></pre> <p>Cela cr\u00e9e un fichier <code>mkdocs.yml</code> et un dossier <code>docs/</code>. \ud83d\udca1</p>"},{"location":"readme_doc/#configurer-le-fichier-mkdocsyml","title":"\u2699\ufe0f Configurer le fichier <code>mkdocs.yml</code>","text":"<p>Modifiez le fichier mkdocs.yml pour d\u00e9finir le nom du site, la navigation, le th\u00e8me et la configuration de mkdocstrings. Par exemple : \ud83d\udca1</p> <pre><code>site_name: Documentation des APIs du repo lmelp\nnav:\n  - Accueil: index.md\n  - Modules:\n      - Module config: config.md\n      - Module llm: llm.md\n      - Module whisper: whisper.md\n      - Module web: web.md\n      - Module rss: rss.md\n      - Module mongo: mongo.md\n      - Module mongo_episode: mongo_episode.md\n      - Module mongo_auteur: mongo_auteur.md\n      - Module mongo_livre: mongo_livre.md\n  - Other kind of docs:\n      - manage doc: readme_doc.md\n      - write markdown: readme_markdown.md\n      - some vs_code hints: readme_vscode_hints.md\n      - about Google services: readme_google.md\n      - data model: readme_data_model.md\ntheme:\n  name: material\n\n# Configuration de mkdocstrings pour extraire la documentation de vos .py\nmarkdown_extensions:\n  - toc:\n      permalink: true\n\nplugins:\n  - search\n  - include-markdown\n  - mkdocstrings:\n      default_handler: python\n      handlers:\n        python:\n          paths: [nbs]\n</code></pre> <p>Quelques points \u00e0 noter : \u2b50 - Vous pouvez organiser votre navigation comme vous le souhaitez. \u2b50 - La section <code>plugins</code> avec mkdocstrings permet d'extraire la doc des fichiers Python. \u2b50  </p>"},{"location":"readme_doc/#creer-les-pages-markdown-pour-integrer-la-doc-extraite","title":"\ud83d\udcdd Cr\u00e9er les pages Markdown pour int\u00e9grer la doc extraite","text":"<p>Dans le dossier <code>docs/</code>, cr\u00e9ez par exemple un fichier <code>mongo_auteur.md</code> pour documenter le module <code>mongo_auteur.py</code> : \ud83d\udca1</p> <pre><code># Module mongo_auteur\n\n::: mongo_auteur\n    rendering:\n      show_root_full_path: false\n</code></pre> <p>De m\u00eame, cr\u00e9ez un fichier <code>mongo_episode.md</code> pour documenter <code>mongo_episode.py</code> : \ud83d\udca1</p> <pre><code># Module mongo_episode\n\n::: mongo_episode\n    rendering:\n      show_root_full_path: false\n</code></pre> <p>L'op\u00e9rateur <code>:::</code> indique \u00e0 mkdocstrings (via la syntaxe Python) d'extraire automatiquement les docstrings du module nomm\u00e9 (<code>mongo_auteur</code> ou <code>mongo_episode</code>). \ud83d\udca1 Assurez-vous que ces modules soient dans votre <code>PYTHONPATH</code> ou que vous sp\u00e9cifiiez leur chemin relatif si besoin. \ud83d\udca1</p>"},{"location":"readme_doc/#modifier-les-docstrings","title":"\u270f\ufe0f Modifier les docstrings","text":"<p>J'utilise copilot avec le prompt suivant : \ud83d\udca1</p> <pre><code>peux-tu ajouter des docstrings au format Google style utilisables par mkdocs ou les modifier pour qu'ils soient utilisables par mkdocs et t'assurer qu'ils soient au format Google style ?\nprecise egalement les bons types dans la signature des methodes/fonctions ainsi que le type de sortie s'il y a lieu.\n</code></pre>"},{"location":"readme_doc/#lancer-le-serveur-de-developpement","title":"\ud83d\udda5\ufe0f Lancer le serveur de d\u00e9veloppement","text":"<p>Pour visualiser la documentation, ex\u00e9cutez : \ud83d\udca1</p> <pre><code>mkdocs serve\n</code></pre> <p>ou avec uv  </p> <pre><code>uv run mkdocs serve\n</code></pre> <p>Vous pourrez alors acc\u00e9der \u00e0 l\u2019interface web sur http://127.0.0.1:8000. \ud83d\udca1</p>"},{"location":"readme_doc/#generer-la-documentation-statique","title":"\ud83c\udfd7\ufe0f G\u00e9n\u00e9rer la documentation statique","text":"<p>Quand vous \u00eates satisfait, g\u00e9n\u00e9rez le site statique : \ud83d\udca1</p> <pre><code>mkdocs build\n</code></pre> <p>ou avec uv  </p> <pre><code>uv run mkdocs build\n</code></pre> <p>Le site sera cr\u00e9\u00e9 dans le dossier <code>site/</code>, pr\u00eat \u00e0 \u00eatre d\u00e9ploy\u00e9. \ud83d\udca1</p>"},{"location":"readme_doc/#pousser-sous-github-pages","title":"\ud83d\udea2 Pousser sous github pages","text":"<pre><code>mkdocs gh-deploy\n</code></pre> <p>ou avec uv  </p> <pre><code>uv run mkdocs gh-deploy\n</code></pre>"},{"location":"readme_doc/#automatisation-complete-avec-github-actions-github-pages","title":"\ud83e\udd16 automatisation complete avec github-actions github-pages","text":"<p>doc Material for MkDocs: Publishing your site\u00b6 \ud83d\udca1</p> <p>Several steps: \ud83d\udca1 - copy/paste <code>.github/workflows/ci.yml</code> \u2b50 - at each commit/push (in main), this fires, builds and deploys doc \u2b50 - it is accessible in https://castorfou.github.io/lmelp \u2b50 - display a link to doc from repo GitHub page: <code>Edit repository details</code> &gt; Check <code>Use your GitHub Pages website</code> \u2b50  </p>"},{"location":"readme_doc/#resume","title":"\ud83d\udcc4 R\u00e9sum\u00e9","text":"<ul> <li>Vous installez MkDocs, Material, et mkdocstrings. \u2b50  </li> <li>Vous configurez <code>mkdocs.yml</code> pour int\u00e9grer mkdocstrings et vous indiquez dans la navigation les pages souhait\u00e9es. \u2b50  </li> <li>Dans vos pages Markdown, vous utilisez la syntaxe <code>:::</code> pour extraire automatiquement la doc de vos fichiers Python. \u2b50  </li> <li>Vous lancez le serveur MkDocs pour v\u00e9rifier l'interface web moderne et bien organis\u00e9e. \u2b50  </li> </ul> <p>Cette approche vous permettra d'avoir une documentation conviviale et rapidement mise \u00e0 jour \u00e0 partir de vos docstrings. \ud83d\udca1</p>"},{"location":"readme_github/","title":"github","text":"<ul> <li>\ud83d\ude80 issue - branch - merge</li> <li>merge to main</li> <li>\ud83e\udd16 github actions</li> </ul>"},{"location":"readme_github/#issue-branch-merge","title":"\ud83d\ude80 issue - branch - merge","text":"<p>As much as possible I want to use this approach \ud83d\udc4d</p> <p>From https://github.com/castorfou/lmelp, \ud83d\udd17</p> <ul> <li>create an issue \ud83d\udcdd</li> <li>from issue create a branch (Development &gt; Create a branch) \ud83d\udd00</li> <li>work from this branch \ud83d\udcbb</li> <li>when satisfied merge to main (then github actions will trigger) \u2705</li> </ul>"},{"location":"readme_github/#merge-to-main","title":"merge to main","text":"<p>from <code>Pull requests</code> tab, should automatically suggest <code>Compare &amp; pull request</code> </p> <p>then <code>View pull request</code> &gt; <code>Merge pull request</code> &gt; <code>Confirm merge</code> &gt; <code>Delete branch</code></p>"},{"location":"readme_github/#github-actions","title":"\ud83e\udd16 github actions","text":"<p>configured in <code>.github/workflows/ci.yml</code> \u2699\ufe0f</p>"},{"location":"readme_github/#tests-automatiques","title":"Tests automatiques","text":"<p>Le projet dispose de tests automatiques configur\u00e9s via GitHub Actions dans <code>.github/workflows/tests.yml</code> \ud83e\uddea</p>"},{"location":"readme_github/#configuration-des-tests","title":"Configuration des tests","text":"<ul> <li>Framework : pytest avec couverture de code</li> <li>Environnement : Python 3.12 sur Ubuntu Latest</li> <li>D\u00e9clenchement : Push et Pull Request sur toutes les branches</li> <li>Couverture minimale : 90% (configurable dans le workflow)</li> </ul>"},{"location":"readme_github/#structure-des-tests","title":"Structure des tests","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/                    # Tests unitaires par module\n\u2502   \u251c\u2500\u2500 test_config.py      # Tests nbs/config.py (97% couverture)\n\u2502   \u251c\u2500\u2500 test_mongo.py       # Tests nbs/mongo.py (98% couverture) \n\u2502   \u251c\u2500\u2500 test_llm.py         # Tests nbs/llm.py (100% couverture)\n\u2502   \u251c\u2500\u2500 test_rss.py         # Tests nbs/rss.py (100% couverture)\n\u2502   \u2514\u2500\u2500 test_fixtures.py    # Tests infrastructure donn\u00e9es\n\u251c\u2500\u2500 integration/             # Tests d'int\u00e9gration\n\u2502   \u2514\u2500\u2500 test_workflows.py   # Tests workflows RSS\u2192MongoDB\u2192LLM\n\u251c\u2500\u2500 ui/                     # Tests interface utilisateur\n\u2502   \u2514\u2500\u2500 test_streamlit.py   # Tests basiques Streamlit\n\u2514\u2500\u2500 fixtures/               # Donn\u00e9es de test\n    \u251c\u2500\u2500 sample_config.json\n    \u251c\u2500\u2500 sample_episode.json\n    \u251c\u2500\u2500 sample_transcription.txt\n    \u2514\u2500\u2500 sample_rss_feed.xml\n</code></pre>"},{"location":"readme_github/#commandes-de-test-locales","title":"Commandes de test locales","text":"<pre><code># Tous les tests\npytest\n\n# Tests avec couverture\npytest --cov=nbs --cov-report=term-missing\n\n# Tests sp\u00e9cifiques\npytest tests/unit/test_config.py -v\n\n# Rapport HTML de couverture  \npytest --cov=nbs --cov-report=html\n# Voir htmlcov/index.html\n</code></pre>"},{"location":"readme_github/#metriques-actuelles","title":"M\u00e9triques actuelles","text":"<ul> <li>Total : 124 tests (104 unitaires + 11 int\u00e9gration + 9 UI)</li> <li>Couverture modules test\u00e9s : 98.75% moyenne</li> <li><code>config.py</code> : 97%</li> <li><code>llm.py</code> : 100% </li> <li><code>mongo.py</code> : 98%</li> <li><code>rss.py</code> : 100%</li> <li>Statut : \u2705 Tous les tests passent</li> </ul>"},{"location":"readme_github/#integration-cicd","title":"Int\u00e9gration CI/CD","text":"<p>Le workflow <code>.github/workflows/tests.yml</code> :</p> <ol> <li>Installation : Python + d\u00e9pendances depuis <code>tests/requirements.txt</code></li> <li>Ex\u00e9cution : <code>pytest</code> avec couverture de code</li> <li>Validation : \u00c9choue si couverture &lt; 90% (sur modules test\u00e9s)</li> <li>Robustesse : Tests depuis r\u00e9pertoire externe pour valider portabilit\u00e9</li> </ol> <p>Voir \ud83d\udcd6 Guide complet des tests unitaires pour plus de d\u00e9tails.</p>"},{"location":"readme_google/","title":"about Google services","text":"<ul> <li>Google services\ud83d\ude80</li> <li>Create a Google project\ud83c\udf1f</li> <li>Dashboard\ud83d\udcca</li> <li>API key\ud83d\udd11</li> <li>Quotas\ud83d\udcc8</li> </ul>"},{"location":"readme_google/#google-services","title":"Google services\ud83d\ude80","text":"<p>To use Gemini or Search, I followed these steps \ud83d\ude0e</p>"},{"location":"readme_google/#create-a-google-project","title":"Create a Google project\ud83c\udf1f","text":"<p>Set it up on Google Cloud Console \ud83d\udda5\ufe0f. My project is named <code>lmelp</code> \ud83d\udd12 (please verify if this info is sensitive).</p>"},{"location":"readme_google/#dashboard","title":"Dashboard\ud83d\udcca","text":"<p>Check out an overview of your project. \ud83d\udd0d I have pinned a few awesome products that might be really useful \ud83d\udcaa</p> <p></p>"},{"location":"readme_google/#api-key","title":"API key\ud83d\udd11","text":"<p>From the dashboard, navigate to generate your API key \ud83d\ude80: Dashboard &gt; APIs &amp; Services &gt; Credentials \ud83d\udc49</p> <p></p> <p>I configured one with: \u2705 - Restricted IP access (my two homes \ud83c\udfe0) - Restricted API access \ud83d\udd10     - Custom Search API \ud83d\udd0d     - Gemini for Google Cloud API \ud83c\udf0c     - Generative Language API \ud83c\udf10</p> <p>Then, I added this key in <code>.env</code> to be used by the project under two entries: <code>GEMINI_API_KEY</code> and <code>GOOGLE_CUSTOM_SEARCH_API_KEY</code> \ud83d\udd11</p>"},{"location":"readme_google/#quotas","title":"Quotas\ud83d\udcc8","text":"<p>APIs have quotas and they can be accessed at \u2139\ufe0f</p> <p>Dashboard &gt; IAMs &amp; Admin &gt; Quotas \u27a1\ufe0f</p> <p>Or dedicated page per API: \ud83d\udc47</p> <p>Custom Search API \ud83d\udd0d</p> <p></p> <p>Gemini for Google Cloud API \ud83c\udf0c</p> <p>Generative Language API \ud83c\udf0c</p> <p>When out of quotas (rateLimitExceeded), service will answer Error 429 \u26a0\ufe0f:</p> <pre><code>Erreur lors de la recherche Google: &lt;HttpError 429 when requesting https://customsearch.googleapis.com/customsearch/v1?q=B%C3%A9n%C3%A9dicte+Lacapria&amp;cx=c2af590ab41ca4fac&amp;key=AIzaSyCE59lk7YhoSSL7T4vDRAPMv7yhYfWZTHg&amp;alt=json returned \"Quota exceeded for quota metric 'Queries' and limit 'Queries per day' of service 'customsearch.googleapis.com' for consumer 'project_number:my_project_number'.\". Details: \"[{'message': \"Quota exceeded for quota metric 'Queries' and limit 'Queries per day' of service 'customsearch.googleapis.com' for consumer 'project_number:my_project_number'.\", 'domain': 'global', 'reason': 'rateLimitExceeded'}]\"&gt;\n</code></pre> <p>Will find a way to properly handle this case. \ud83d\udc4d</p>"},{"location":"readme_import_strategy/","title":"Strat\u00e9gie d'imports - Projet LMELP","text":""},{"location":"readme_import_strategy/#vue-densemble","title":"Vue d'ensemble","text":"<p>Le projet LMELP utilise diff\u00e9rentes strat\u00e9gies d'imports selon le contexte, optimis\u00e9es pour chaque usage.</p>"},{"location":"readme_import_strategy/#strategies-par-contexte","title":"Strat\u00e9gies par contexte","text":""},{"location":"readme_import_strategy/#nbs-modules-principaux","title":"\ud83d\udcc1 <code>nbs/</code> - Modules principaux","text":"<p>Pattern : Imports directs (m\u00eame dossier)</p> <pre><code># \u2705 Dans nbs/mongo.py\nfrom config import get_DB_VARS\n</code></pre> <p>Justification : Modules dans le m\u00eame dossier, imports simples et directs.</p>"},{"location":"readme_import_strategy/#scripts-scripts-utilitaires","title":"\ud83d\udcc1 <code>scripts/</code> - Scripts utilitaires","text":"<p>Pattern : Ajout explicite au sys.path</p> <pre><code># \u2705 Dans scripts/*.py\nimport sys\nimport os\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"../nbs\")))\nfrom config import get_RSS_URL\n</code></pre> <p>Justification : Scripts ponctuels ex\u00e9cut\u00e9s depuis diff\u00e9rents endroits, besoin de chemin absolu.</p>"},{"location":"readme_import_strategy/#ui-interface-streamlit","title":"\ud83d\udcc1 <code>ui/</code> - Interface Streamlit","text":"<p>Pattern : Fonction centralis\u00e9e add_to_sys_path()</p> <pre><code># \u2705 Dans ui/pages/*.py  \nfrom ui_tools import add_to_sys_path\nadd_to_sys_path()\nfrom mongo_episode import Episodes\n</code></pre> <p>Justification : Apps Streamlit avec logique r\u00e9utilisable, fonction centralis\u00e9e dans ui_tools.py.</p>"},{"location":"readme_import_strategy/#tests-tests-unitaires","title":"\ud83d\udcc1 <code>tests/</code> - Tests unitaires","text":"<p>Pattern : Imports explicites avec chemin complet</p> <pre><code># \u2705 Dans tests/unit/*.py\nfrom nbs.config import get_RSS_URL\nfrom nbs.mongo import get_collection\n</code></pre> <p>Justification : Isolation maximale, tra\u00e7abilit\u00e9 claire, pas de modification sys.path.</p>"},{"location":"readme_import_strategy/#avantages-de-cette-approche","title":"Avantages de cette approche","text":"Contexte Avantage <code>nbs/</code> Simple, pas de configuration <code>scripts/</code> Portable, fonctionne de partout <code>ui/</code> Centralis\u00e9, facile \u00e0 maintenir <code>tests/</code> Isol\u00e9, explicite, pas d'effets de bord"},{"location":"readme_import_strategy/#convention-de-nommage-des-tests","title":"Convention de nommage des tests","text":"<pre><code>tests/unit/test_config.py     \u2190 teste nbs/config.py\ntests/unit/test_mongo.py      \u2190 teste nbs/mongo.py  \ntests/unit/test_llm.py        \u2190 teste nbs/llm.py\n</code></pre> <p>Pattern : <code>test_&lt;module&gt;.py</code> teste <code>nbs/&lt;module&gt;.py</code></p>"},{"location":"readme_import_strategy/#exemples-concrets","title":"Exemples concrets","text":""},{"location":"readme_import_strategy/#import-dans-un-test","title":"Import dans un test","text":"<pre><code># tests/unit/test_config.py\nfrom nbs.config import get_RSS_URL  # \u2705 Explicite et clair\n\ndef test_get_RSS_URL_with_env_var():\n    # Test code...\n</code></pre>"},{"location":"readme_import_strategy/#import-dans-un-script","title":"Import dans un script","text":"<pre><code># scripts/get_transcription.py\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"../nbs\")))\nfrom config import get_RSS_URL  # \u2705 Apr\u00e8s modification sys.path\n</code></pre>"},{"location":"readme_import_strategy/#import-dans-streamlit","title":"Import dans Streamlit","text":"<pre><code># ui/pages/episodes.py\nfrom ui_tools import add_to_sys_path\nadd_to_sys_path()\nfrom mongo_episode import Episodes  # \u2705 Apr\u00e8s add_to_sys_path()\n</code></pre>"},{"location":"readme_import_strategy/#evolutions-futures","title":"\u00c9volutions futures","text":"<p>Si le projet grandit, consid\u00e9rer : - Package Python installable : <code>pip install -e .</code> pour d\u00e9veloppement - Imports absolus partout : <code>from lmelp.config import get_RSS_URL</code> - Structure package standard : <code>src/lmelp/</code> layout</p> <p>Pour l'instant, le status quo fonctionne bien et respecte les contraintes de chaque contexte.</p>"},{"location":"readme_markdown/","title":"write markdown","text":"<ul> <li>\ud83d\udcd8 How to properly write usefull markdown files (.md) in this project</li> <li>\ud83d\udee0\ufe0f Standard vscode options</li> <li>\u2728 Markdown All in One vscode extension<ul> <li>\u2328\ufe0f shortcuts</li> <li>\ud83d\udcd1 table of contents</li> </ul> </li> <li>\ud83d\ude0a emojis</li> <li>\ud83d\uddbc\ufe0f images</li> </ul>"},{"location":"readme_markdown/#how-to-properly-write-usefull-markdown-files-md-in-this-project","title":"\ud83d\udcd8 How to properly write usefull markdown files (.md) in this project","text":""},{"location":"readme_markdown/#standard-vscode-options","title":"\ud83d\udee0\ufe0f Standard vscode options","text":"<p><code>Ctrl-k V</code> to open preview to the side \ud83d\udc40</p>"},{"location":"readme_markdown/#markdown-all-in-one-vscode-extension","title":"\u2728 Markdown All in One vscode extension","text":"<p>It helps with all you need for Markdown (keyboard shortcuts, table of contents, auto preview and more) \ud83e\udd16</p>"},{"location":"readme_markdown/#shortcuts","title":"\u2328\ufe0f shortcuts","text":"<p><code>Ctrl-B</code> to toggle bold \ud83d\udcaa</p>"},{"location":"readme_markdown/#table-of-contents","title":"\ud83d\udcd1 table of contents","text":"<p>Run command \"Create Table of Contents\" (in the VS Code Command Palette) to insert a new table of contents \ud83d\udd16</p>"},{"location":"readme_markdown/#emojis","title":"\ud83d\ude0a emojis","text":"<p>Use GitHub Copilot Rewrite: Modify using Copilot \ud83e\udd16</p> <p> \ud83d\uddbc\ufe0f</p> <p>Select everything, modify using Copilot with this prompt \u270d\ufe0f</p> <pre><code>Add nice emojis to this markdown text.\nIt has to be informative and helpful.\nNo more than 1 emoji per line.\nI would like emojis at beginning of text (after #s though) for titles or sections, \nand at end of line for regular lines.\n</code></pre>"},{"location":"readme_markdown/#images","title":"\ud83d\uddbc\ufe0f images","text":"<p>put them in <code>docs/img</code> \ud83d\udcc2</p>"},{"location":"readme_unit_test/","title":"Guide des Tests Unitaires \ud83e\uddea","text":""},{"location":"readme_unit_test/#vue-densemble","title":"Vue d'ensemble","text":"<p>Le projet LMELP utilise pytest comme framework de tests avec une approche de mocking complet pour isoler les tests de l'environnement ext\u00e9rieur (MongoDB, APIs, syst\u00e8me de fichiers).</p>"},{"location":"readme_unit_test/#architecture-des-tests","title":"Architecture des Tests","text":""},{"location":"readme_unit_test/#structure-des-dossiers","title":"Structure des Dossiers","text":"<pre><code>tests/\n\u251c\u2500\u2500 __init__.py                 # Package principal\n\u251c\u2500\u2500 conftest.py                # Configuration globale et fixtures\n\u251c\u2500\u2500 requirements.txt           # \ud83c\udd95 D\u00e9pendances minimales pour tests\n\u251c\u2500\u2500 fixtures/                  # \ud83c\udd95 Donn\u00e9es de test et utilitaires\n\u2502   \u251c\u2500\u2500 __init__.py           #     Fonctions load_sample_json/text\n\u2502   \u2514\u2500\u2500 data/                 #     Donn\u00e9es d'exemple\n\u2502       \u2514\u2500\u2500 sample_config.json\n\u2514\u2500\u2500 unit/                      # Tests unitaires\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 test_config.py         # Tests du module nbs/config.py\n    \u251c\u2500\u2500 test_fixtures.py       # \ud83c\udd95 Tests infrastructure fixtures\n    \u2514\u2500\u2500 test_mongo.py          # Tests du module nbs/mongo.py (\u00e0 venir)\n\n# Infrastructure CI/CD\n.env.test                      # \ud83c\udd95 Variables d'environnement de test\n.github/workflows/tests.yml    # \ud83c\udd95 GitHub Actions pour CI/CD\n</code></pre>"},{"location":"readme_unit_test/#configuration","title":"Configuration","text":"<ul> <li>pytest.ini : Configuration principale avec chemins et options + pytest-env</li> <li>.env.test : Variables d'environnement isol\u00e9es pour tests</li> <li>tests/requirements.txt : D\u00e9pendances optimis\u00e9es (sans PyTorch/ML)</li> <li>conftest.py : Fixtures globales et fonction <code>load_env_test()</code></li> </ul>"},{"location":"readme_unit_test/#infrastructure-cicd","title":"Infrastructure CI/CD \ud83d\ude80","text":""},{"location":"readme_unit_test/#github-actions","title":"GitHub Actions","text":"<p>Le projet utilise GitHub Actions pour l'int\u00e9gration continue avec un workflow optimis\u00e9 :</p> <pre><code># .github/workflows/tests.yml\nname: Tests Unitaires\non:\n  push:\n    branches: [ main, develop, \"**devops**\", \"**test**\" ]\n  pull_request:\n    branches: [ main, develop ]\n</code></pre> <p>Optimisations cl\u00e9s : - \u2705 D\u00e9pendances minimales : <code>pip install -r tests/requirements.txt</code> (30s vs 2m30s) - \u2705 Coverage cibl\u00e9e : <code>--cov=nbs.config</code> (97% sur module test\u00e9) - \u2705 Chemins portables : Fonction <code>get_project_root()</code> pour dev/CI - \u2705 Tests robustesse : Validation CI/CD depuis <code>/tmp</code></p>"},{"location":"readme_unit_test/#performance","title":"Performance","text":"Avant Apr\u00e8s Gain 2m30s installation 30s installation 5x plus rapide Tests sur tout <code>nbs/</code> Tests sur <code>nbs.config</code> Focus cibl\u00e9 Chemins absolus Chemins relatifs Portable"},{"location":"readme_unit_test/#frameworks-et-outils","title":"Frameworks et Outils","text":""},{"location":"readme_unit_test/#dependances","title":"D\u00e9pendances","text":"<pre><code># tests/requirements.txt - D\u00e9pendances minimales optimis\u00e9es\npytest&gt;=7.0           # Framework de tests\npytest-mock&gt;=3.10     # Mocking avanc\u00e9\npytest-env&gt;=0.8       # Variables d'environnement\npytest-cov&gt;=4.0       # Couverture de code\npython-dotenv&gt;=1.0.0  # Gestion .env\nPyYAML&gt;=6.0           # Parsing YAML (workflow tests)\nrequests&gt;=2.25.0      # HTTP (tests futurs)\n</code></pre>"},{"location":"readme_unit_test/#patterns-de-test","title":"Patterns de Test","text":""},{"location":"readme_unit_test/#1-structure-arrange-act-assert","title":"1. Structure ARRANGE-ACT-ASSERT","text":"<pre><code>def test_example_function(self, monkeypatch):\n    # ARRANGE : Pr\u00e9parer les donn\u00e9es et mocks\n    test_value = \"example\"\n    monkeypatch.setenv(\"TEST_VAR\", test_value)\n\n    # ACT : Ex\u00e9cuter la fonction \u00e0 tester\n    result = function_to_test()\n\n    # ASSERT : V\u00e9rifier les r\u00e9sultats\n    assert result == expected_value\n</code></pre>"},{"location":"readme_unit_test/#2-mocking-avec-monkeypatch","title":"2. Mocking avec Monkeypatch","text":"<pre><code># Variables d'environnement\nmonkeypatch.setenv(\"API_KEY\", \"fake_key\")\nmonkeypatch.delenv(\"OPTIONAL_VAR\", raising=False)\n\n# Fonctions et m\u00e9thodes\ndef mock_function():\n    return \"fake_result\"\n\nmonkeypatch.setattr(\"module.real_function\", mock_function)\n</code></pre>"},{"location":"readme_unit_test/#3-organisation-en-classes","title":"3. Organisation en Classes","text":"<pre><code>class TestConfigModule:\n    \"\"\"Tests pour le module de configuration\"\"\"\n\n    def test_specific_feature(self, monkeypatch):\n        # Test sp\u00e9cifique\n        pass\n</code></pre>"},{"location":"readme_unit_test/#strategies-de-mocking","title":"Strat\u00e9gies de Mocking","text":""},{"location":"readme_unit_test/#1-isolation-complete","title":"1. Isolation Compl\u00e8te","text":"<p>Principe : Aucun test ne doit d\u00e9pendre de ressources externes.</p> <pre><code># \u274c Mauvais : Test d\u00e9pend de MongoDB r\u00e9el\ndef test_save_entity():\n    entity = Entity(\"test\")\n    entity.save()  # Sauvegarde dans la vraie DB\n\n# \u2705 Bon : Test avec MongoDB mock\u00e9\n@patch('module.get_collection')\ndef test_save_entity(mock_get_collection):\n    mock_collection = Mock()\n    mock_get_collection.return_value = mock_collection\n\n    entity = Entity(\"test\")\n    entity.save()\n\n    mock_collection.insert_one.assert_called_once()\n</code></pre>"},{"location":"readme_unit_test/#11-mocking-des-dependances-lourdes-mlia","title":"1.1. Mocking des D\u00e9pendances Lourdes (ML/IA) \ud83e\udd16","text":"<p>Probl\u00e8me : Les d\u00e9pendances ML comme PyTorch, transformers, llama_index sont lourdes et causent des \u00e9checs en CI/CD.</p> <p>Solution : Mock pr\u00e9coce au niveau <code>sys.modules</code> avant tout import.</p> <pre><code>import sys\nfrom unittest.mock import Mock\n\n# \ud83d\udd25 CRITIQUE : Mocking AVANT les imports\n# Mock des modules ML lourds\nsys.modules['torch'] = Mock()\nsys.modules['transformers'] = Mock()\nsys.modules['datasets'] = Mock()\n\n# Mock des modules syst\u00e8me probl\u00e9matiques\nsys.modules['dbus'] = Mock()\nsys.modules['dbus.mainloop'] = Mock()\nsys.modules['dbus.mainloop.glib'] = Mock()\n\n# Mock des modules LlamaIndex et sous-modules\nsys.modules['llama_index'] = Mock()\nsys.modules['llama_index.core'] = Mock()\nsys.modules['llama_index.core.base'] = Mock()\nsys.modules['llama_index.core.base.embeddings'] = Mock()\nsys.modules['llama_index.embeddings'] = Mock()\nsys.modules['llama_index.embeddings.azure_openai'] = Mock()\n\n# Mock des modules Google AI\nsys.modules['google'] = Mock()\nsys.modules['google.generativeai'] = Mock()\nsys.modules['google.oauth2'] = Mock()\nsys.modules['google.oauth2.service_account'] = Mock()\n\n# PUIS seulement apr\u00e8s, importer le module \u00e0 tester\nfrom nbs.mongo_episode import MongoEpisode\n</code></pre> <p>Cas d'Usage Typiques :</p> <pre><code>class TestMongoEpisodeWithML:\n    \"\"\"Tests n\u00e9cessitant du mocking ML complet\"\"\"\n\n    def setup_method(self):\n        \"\"\"Mocking pr\u00e9coce pour chaque test\"\"\"\n        # D\u00e9j\u00e0 fait au niveau module, mais on peut renforcer\n        pass\n\n    def test_transcription_without_torch(self):\n        \"\"\"Test de transcription sans installer PyTorch\"\"\"\n        # Le module est d\u00e9j\u00e0 mock\u00e9, on peut tester la logique\n        episode = MongoEpisode()\n        # Test de la logique m\u00e9tier sans d\u00e9pendances ML\n        assert episode.collection_name == \"episodes\"\n</code></pre> <p>\u26a0\ufe0f Points Critiques : - Le mocking doit \u00eatre fait AVANT tout import du module test\u00e9 - Utiliser <code>sys.modules</code> plut\u00f4t que <code>@patch</code> pour les d\u00e9pendances transversales - Mocker les sous-modules \u00e9galement (ex: <code>llama_index.core.base</code>) - Tester en environnement propre (ex: nouveau terminal) pour valider</p>"},{"location":"readme_unit_test/#2-variables-denvironnement","title":"2. Variables d'Environnement","text":"<pre><code>def test_config_with_env(self, monkeypatch):\n    # Test avec variable d\u00e9finie\n    monkeypatch.setenv(\"API_KEY\", \"test_key\")\n    result = get_api_key()\n    assert result == \"test_key\"\n\ndef test_config_without_env(self, monkeypatch):\n    # Test sans variable (valeur par d\u00e9faut)\n    monkeypatch.delenv(\"API_KEY\", raising=False)\n    result = get_api_key()\n    assert result is None  # ou valeur par d\u00e9faut\n</code></pre>"},{"location":"readme_unit_test/#3-mocking-de-classes-et-methodes","title":"3. Mocking de Classes et M\u00e9thodes","text":"<pre><code>@patch('nbs.mongo.pymongo.MongoClient')\ndef test_database_connection(mock_client):\n    mock_db = Mock()\n    mock_client.return_value = {\"test_db\": mock_db}\n\n    collection = get_collection(\"localhost\", \"test_db\", \"test_coll\")\n\n    mock_client.assert_called_once_with(\"mongodb://localhost:27017/\")\n</code></pre>"},{"location":"readme_unit_test/#fixtures-globales","title":"Fixtures Globales","text":""},{"location":"readme_unit_test/#fixtures-disponibles-conftestpy","title":"Fixtures Disponibles (conftest.py)","text":"<pre><code>@pytest.fixture\ndef test_environment():\n    \"\"\"Environnement de test isol\u00e9\"\"\"\n\n@pytest.fixture  \ndef mock_mongodb():\n    \"\"\"Mock complet de MongoDB\"\"\"\n\n@pytest.fixture\ndef test_config():\n    \"\"\"Configuration de test standard\"\"\"\n</code></pre>"},{"location":"readme_unit_test/#utilisation-des-fixtures","title":"Utilisation des Fixtures","text":"<pre><code>def test_with_fixtures(self, test_environment, mock_mongodb):\n    # Les fixtures sont automatiquement inject\u00e9es\n    # test_environment et mock_mongodb sont disponibles\n    pass\n</code></pre>"},{"location":"readme_unit_test/#couverture-de-code","title":"Couverture de Code","text":""},{"location":"readme_unit_test/#mesurer-la-couverture","title":"Mesurer la Couverture","text":"<pre><code># Couverture pour un module\npytest tests/unit/test_config.py --cov=nbs.config --cov-report=term-missing\n\n# Couverture globale\npytest --cov=nbs --cov-report=html\n\n# Couverture avec seuil minimum\npytest --cov=nbs --cov-fail-under=90\n</code></pre>"},{"location":"readme_unit_test/#interpreter-les-resultats","title":"Interpr\u00e9ter les R\u00e9sultats","text":"<pre><code>Name            Stmts   Miss  Cover   Missing\n---------------------------------------------\nnbs/config.py      60      2    97%   43, 154\n---------------------------------------------\nTOTAL              60      2    97%\n</code></pre> <ul> <li>Stmts : Nombre total de lignes de code</li> <li>Miss : Lignes non test\u00e9es</li> <li>Cover : Pourcentage de couverture</li> <li>Missing : Num\u00e9ros de lignes manquantes</li> </ul>"},{"location":"readme_unit_test/#objectifs-de-couverture","title":"Objectifs de Couverture","text":"<ul> <li>Minimum acceptable : 80%</li> <li>Objectif : 90%+</li> <li>Excellence : 95%+</li> </ul>"},{"location":"readme_unit_test/#commandes-principales","title":"Commandes Principales","text":""},{"location":"readme_unit_test/#execution-des-tests","title":"Ex\u00e9cution des Tests","text":"<pre><code># Tous les tests\npytest\n\n# Tests avec verbosit\u00e9\npytest -v\n\n# Tests sp\u00e9cifiques\npytest tests/unit/test_config.py\npytest tests/unit/test_config.py::TestConfig::test_specific\n\n# Tests avec pattern\npytest -k \"test_config\"\n</code></pre>"},{"location":"readme_unit_test/#debug-et-developpement","title":"Debug et D\u00e9veloppement","text":"<pre><code># Arr\u00eater au premier \u00e9chec\npytest -x\n\n# Mode debug avec pdb\npytest --pdb\n\n# Afficher les print()\npytest -s\n\n# Tests en parall\u00e8le (avec pytest-xdist)\npytest -n auto\n</code></pre>"},{"location":"readme_unit_test/#rapports","title":"Rapports","text":"<pre><code># Rapport HTML de couverture\npytest --cov=nbs --cov-report=html\n# Voir tests/htmlcov/index.html\n\n# Rapport XML (pour CI/CD)\npytest --cov=nbs --cov-report=xml\n\n# Rapport JUnit\npytest --junit-xml=tests/results.xml\n</code></pre>"},{"location":"readme_unit_test/#bonnes-pratiques","title":"Bonnes Pratiques","text":""},{"location":"readme_unit_test/#1-nommage","title":"1. Nommage","text":"<ul> <li>Fichiers : <code>test_module_name.py</code></li> <li>Classes : <code>TestModuleName</code></li> <li>Fonctions : <code>test_specific_behavior</code></li> </ul>"},{"location":"readme_unit_test/#2-documentation","title":"2. Documentation","text":"<pre><code>def test_function_behavior(self, monkeypatch):\n    \"\"\"Test que la fonction retourne la valeur attendue quand X\"\"\"\n    # Commentaires expliquant les \u00e9tapes complexes\n</code></pre>"},{"location":"readme_unit_test/#3-isolation","title":"3. Isolation","text":"<ul> <li>Chaque test doit \u00eatre ind\u00e9pendant</li> <li>Utiliser des mocks pour les d\u00e9pendances externes</li> <li>Nettoyer apr\u00e8s chaque test (automatique avec fixtures)</li> </ul>"},{"location":"readme_unit_test/#4-lisibilite","title":"4. Lisibilit\u00e9","text":"<ul> <li>Un test = Un comportement</li> <li>Arrange-Act-Assert clairement s\u00e9par\u00e9s</li> <li>Noms explicites pour les variables de test</li> </ul>"},{"location":"readme_unit_test/#5-mocking-des-dependances-lourdes-lecons-github-actions","title":"5. Mocking des D\u00e9pendances Lourdes (Le\u00e7ons GitHub Actions) \ud83d\ude80","text":"<p>Probl\u00e8me R\u00e9solu : Import failures en CI/CD avec d\u00e9pendances ML/IA</p> <p>Strat\u00e9gie Gagnante : 1. Mock pr\u00e9coce : <code>sys.modules</code> avant imports 2. Mock exhaustif : Inclure tous les sous-modules 3. Test isolated : Valider en environnement propre 4. Requirements split : <code>tests/requirements.txt</code> minimal</p> <pre><code># Pattern \u00e9prouv\u00e9 pour nouveaux tests ML\nimport sys\nfrom unittest.mock import Mock\n\n# Mock AVANT imports (dans l'ordre de d\u00e9couverte des erreurs)\nsys.modules['torch'] = Mock()\nsys.modules['transformers'] = Mock() \nsys.modules['dbus'] = Mock()\nsys.modules['llama_index'] = Mock()\nsys.modules['google.generativeai'] = Mock()\n\n# Puis import du module\nfrom nbs.module_with_ml import ModuleToTest\n</code></pre> <p>M\u00e9triques de Succ\u00e8s : - \u2705 214 tests passent en GitHub Actions - \u2705 Installation CI : 30s (vs 2m30s avant) - \u2705 Couverture maintenue : 72.72% - \u2705 Z\u00e9ro d\u00e9pendance ML en tests</p>"},{"location":"readme_unit_test/#patterns-avances","title":"Patterns Avanc\u00e9s","text":""},{"location":"readme_unit_test/#1-mocking-de-hierarchies-complexes","title":"1. Mocking de Hi\u00e9rarchies Complexes","text":"<pre><code>class MockRepo:\n    def __init__(self, path, search_parent_directories=True):\n        self.git = MockGit()\n\nclass MockGit:\n    def rev_parse(self, option):\n        return \"/fake/git/root\"\n\nmonkeypatch.setattr(\"nbs.config.Repo\", MockRepo)\n</code></pre>"},{"location":"readme_unit_test/#2-tests-parametres","title":"2. Tests Param\u00e9tr\u00e9s","text":"<pre><code>@pytest.mark.parametrize(\"input,expected\", [\n    (\"test1\", \"result1\"),\n    (\"test2\", \"result2\"),\n    (\"test3\", \"result3\"),\n])\ndef test_multiple_cases(input, expected):\n    assert function(input) == expected\n</code></pre>"},{"location":"readme_unit_test/#3-tests-dexception","title":"3. Tests d'Exception","text":"<pre><code>def test_function_raises_error():\n    with pytest.raises(ValueError, match=\"Expected error message\"):\n        function_that_should_fail()\n</code></pre>"},{"location":"readme_unit_test/#depannage","title":"D\u00e9pannage","text":""},{"location":"readme_unit_test/#problemes-courants","title":"Probl\u00e8mes Courants","text":""},{"location":"readme_unit_test/#variables-denvironnement-persistantes","title":"Variables d'Environnement Persistantes","text":"<pre><code># \u274c Les vraies variables interf\u00e8rent\ndef test_without_env():\n    result = get_env_var()  # Utilise la vraie variable !\n\n# \u2705 Mock complet\ndef test_without_env(self, monkeypatch):\n    def mock_getenv(key, default=None):\n        return None\n    monkeypatch.setattr(os, \"getenv\", mock_getenv)\n</code></pre>"},{"location":"readme_unit_test/#imports-et-paths","title":"Imports et Paths","text":"<pre><code># \u2705 Imports explicites pour les tests\nfrom nbs.config import function_to_test\n\n# \u2705 Mocking avec le path complet\nmonkeypatch.setattr(\"nbs.config.function\", mock_function)\n</code></pre>"},{"location":"readme_unit_test/#debug-des-tests","title":"Debug des Tests","text":"<pre><code># Afficher les valeurs pour debug\ndef test_debug(self, monkeypatch):\n    result = function()\n    print(f\"Debug: result = {result}\")  # Visible avec pytest -s\n    assert result == expected\n</code></pre>"},{"location":"readme_unit_test/#evolution-et-maintenance","title":"\u00c9volution et Maintenance","text":""},{"location":"readme_unit_test/#ajout-de-nouveaux-tests","title":"Ajout de Nouveaux Tests","text":"<ol> <li>Identifier le module \u00e0 tester</li> <li>Cr\u00e9er le fichier <code>test_module.py</code></li> <li>D\u00e9finir les classes et m\u00e9thodes de test</li> <li>Impl\u00e9menter les mocks n\u00e9cessaires</li> <li>V\u00e9rifier la couverture</li> </ol>"},{"location":"readme_unit_test/#refactoring","title":"Refactoring","text":"<ul> <li>Maintenir la couverture lors des changements</li> <li>Adapter les mocks aux nouvelles signatures</li> <li>Regrouper les fixtures communes</li> </ul> <p>Ce guide \u00e9volue avec le projet. N'h\u00e9sitez pas \u00e0 l'enrichir ! \ud83d\ude80</p>"},{"location":"readme_uv_devcontainer/","title":"devcontainer and uv","text":"<p>As explained in README, this project uses devcontainer and uv.</p>"},{"location":"readme_uv_devcontainer/#devcontainer","title":"devcontainer","text":"<p>Everything is in <code>.devcontainer</code></p>"},{"location":"readme_uv_devcontainer/#update-requirements","title":"update requirements","text":"<p>make modifications in <code>.devcontainer/requirements.txt</code></p> <p>to apply modifications </p> <pre><code>source .venv/bin/activate\nexport UV_LINK_MODE=copy\nuv pip install -r .devcontainer/requirements.txt\n</code></pre> <p>(or you can decide to rebuild devcontainer but it is longer)</p>"},{"location":"readme_uv_devcontainer/#venv","title":"venv","text":"<p>on this project, virtualenv is in <code>.venv</code></p>"},{"location":"readme_uv_devcontainer/#uv","title":"uv","text":"<p>to execute python code from our venv,</p> <pre><code>source .venv/bin/activate\nuv run python --version\n</code></pre>"},{"location":"readme_vscode_hints/","title":"some vs_code hints","text":"<ul> <li>\ud83d\udee0\ufe0f Vscode hints</li> <li>\ud83d\udd04 multicurseur pour remplacer des variables par ex</li> <li>\ud83d\udccb multicurseur sur chaque ligne d'un texte</li> <li>\ud83d\ude48 cacher un repertoire du workspace (par exemple pycache)</li> <li>\u2328\ufe0f ctrl-c ctrl-v dans le terminal</li> <li>\ud83d\udd0c ajouter des sources pour pylance</li> <li>\ud83d\udc0d tester un petit code python en REPL</li> <li>\ud83d\udcdd editer des fichiers markdown</li> <li>\ud83d\udce6 utiliser dev container</li> </ul>"},{"location":"readme_vscode_hints/#vscode-hints","title":"\ud83d\udee0\ufe0f Vscode hints","text":""},{"location":"readme_vscode_hints/#multicurseur-pour-remplacer-des-variables-par-ex","title":"\ud83d\udd04 multicurseur pour remplacer des variables par ex","text":"<p>sur le mot <code>Ctrl-d</code> autant de fois que le nombre de variable \u00e0 remplacer \ud83d\udca1</p>"},{"location":"readme_vscode_hints/#multicurseur-sur-chaque-ligne-dun-texte","title":"\ud83d\udccb multicurseur sur chaque ligne d'un texte","text":"<p>(pour inserer un &gt; par ex en debut de ligne) \u27a1\ufe0f selection du texte puis <code>Shift-Alt-i</code> \ud83d\udc49</p>"},{"location":"readme_vscode_hints/#cacher-un-repertoire-du-workspace-par-exemple-pycache","title":"\ud83d\ude48 cacher un repertoire du workspace (par exemple pycache)","text":"<p>ouvrir settings.json : <code>Ctrl-Shift-p</code> et taper Preferences: Open Settings (JSON) \u2699\ufe0f ajouter une entree dans <code>files.exclude</code> \u2795</p> <pre><code>    \"files.exclude\": {\n        \"**/.git\": true,\n        \"**/__pycache__\": true,\n        \"**/.ipynb_checkpoints\": true,\n        \"**/.venv\": true,\n    },\n</code></pre>"},{"location":"readme_vscode_hints/#ctrl-c-ctrl-v-dans-le-terminal","title":"\u2328\ufe0f ctrl-c ctrl-v dans le terminal","text":"<pre><code>Go to \u2018Preferences &gt; Keyboard Shortcuts\u2019\nSet the \u2018Terminal: Copy Selection\u2019 keybindings to Ctrl-C\nSet the \u2018Terminal: Paste into Active Terminal\u2019 keybinding to Ctrl-V\n</code></pre> <p>And that seemed to be that. When there is a selection Ctrl-C will copy without sending SIGINT and if there is no selection VS Code sends a SIGINT \ud83d\udca1</p>"},{"location":"readme_vscode_hints/#ajouter-des-sources-pour-pylance","title":"\ud83d\udd0c ajouter des sources pour pylance","text":"<p>ouvrir settings.json : <code>Ctrl-Shift-p</code> et taper Preferences: Open Settings (JSON) \u2699\ufe0f ajouter une entree dans <code>python.analysis.extraPaths</code> \u2795</p> <pre><code>    \"python.analysis.extraPaths\": [\n        \"./nbs\"\n    ],\n</code></pre>"},{"location":"readme_vscode_hints/#tester-un-petit-code-python-en-repl","title":"\ud83d\udc0d tester un petit code python en REPL","text":"<p>doc vscode native REPL \ud83d\udd17  </p> <p>You can open the Native REPL via the Command Palette (Ctrl+Shift+P) by searching for Python: Start Native REPL. Furthermore, you can send code to the Native REPL via Smart Send (Shift+Enter) and Run Selection/Line in Python REPL by setting <code>\"python.REPL.sendToNativeREPL\": true</code> in your settings.json file. \ud83d\ude80  </p> <p>ca fait tourner un notebook Untitled-1.ipnb juste a cote. \ud83d\udd0d</p>"},{"location":"readme_vscode_hints/#editer-des-fichiers-markdown","title":"\ud83d\udcdd editer des fichiers markdown","text":"<p>readme_markdown \ud83d\udcc4</p>"},{"location":"readme_vscode_hints/#utiliser-dev-container","title":"\ud83d\udce6 utiliser dev container","text":"<p>Ressources: \ud83d\udcda</p> <ul> <li>vscode doc website Create a dev container \ud83d\udcd6</li> <li>youtube Get Started with Dev Containers in VS Code \ud83c\udfa5</li> <li>youtube Beginner's Series to: Dev Containers \ud83c\udfac</li> </ul> <p>Etapes: \ud83d\udcdd</p> <ol> <li>installer <code>dev containers</code> extension \u2b07\ufe0f</li> <li>palette: <code>Dev Containers: Add Dev Container Configuration Files...</code> using ms-python3, <code>Reopen in Container</code> \ud83c\udfa8</li> <li>extensions: les extensions installees localement qui m'interessent pour ce projet, <code>Manage &gt; Add to devcontainer.json</code>, et en sauvant je rebuilde le container \ud83d\udd27</li> <li>requirements: les lib python necessaires pour ce projet \ud83d\udccc</li> <li>postCommand.sh: j'installe cmake et dbus (pour supprimer la mise en veille), la locale fr_FR.UTF-8 pour la conversion de dates, les libs python, pre-commit et le safe.directory git (car les utilisateurs host et docker sont differents) \u26a1</li> <li>runArgs: \ud83d\ude80  </li> <li><code>--network=host</code> pour acceder au container depuis le host (pour streamlit) \ud83c\udf10  </li> <li><code>--label com.centurylinklabs.watchtower.enable=false</code> pour exclure le container de la mise a jour watchtower \ud83d\udeab  </li> <li><code>--env CONTAINER_NAME=vscode-dev-container-lmelp</code> pour retrouver le nom du container depuis un script execute depuis host \ud83c\udd94</li> <li>forwardPorts pour acceder a streamlit \ud83d\udd00</li> <li>shutdownAction a \"none\" pour empecher que le container ne s'arrete a la sortie de vscode (utile pour lancer les scripts ou streamlit) \ud83d\uded1</li> </ol> <p>A chaque modification, faire un <code>Dev Containers: Rebuild Container</code>. </p> <p>Depuis Windows+WSL, il faut activer <code>Dev&gt;Containers: Execute in WSL</code>, cela utilisera le docker de WSL et pas le docker Windows (que je n'ai pas) \ud83d\udc33</p> <p></p> <p>Voir dans <code>.devcontainer</code> pour le detail. \ud83d\udcc2</p>"},{"location":"rss/","title":"Module rss","text":""},{"location":"rss/#rss.Podcast","title":"<code>Podcast</code>","text":"Source code in <code>nbs/rss.py</code> <pre><code>class Podcast:\n    def __init__(self):\n        \"\"\"\n        Initialise la classe Podcast en analysant le flux RSS et en obtenant la collection MongoDB.\n        \"\"\"\n        self.parsed_flow = feedparser.parse(get_RSS_URL())\n        DB_HOST, DB_NAME, _ = get_DB_VARS()\n        self.collection = get_collection(\n            target_db=DB_HOST, client_name=DB_NAME, collection_name=\"episodes\"\n        )\n\n    def get_most_recent_episode_from_DB(self) -&gt; Optional[datetime]:\n        \"\"\"\n        R\u00e9cup\u00e8re la date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s dans la base de donn\u00e9es.\n\n        Returns:\n            Optional[datetime]: La date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s, ou None si aucun \u00e9pisode n'est trouv\u00e9.\n        \"\"\"\n        most_recent_document = self.collection.find().sort({\"date\": -1}).limit(1)\n        most_recent_date = None\n        for doc in most_recent_document:\n            most_recent_date = doc[\"date\"].replace(tzinfo=pytz.timezone(\"Europe/Paris\"))\n        return most_recent_date\n\n    def list_last_large_episodes(\n        self, duree_mini_minutes: int = 15\n    ) -&gt; List[FeedParserDict]:\n        \"\"\"\n        Liste les \u00e9pisodes RSS qui sont plus r\u00e9cents que le plus r\u00e9cent \u00e9pisode stock\u00e9 dans la base de donn\u00e9es\n        et qui durent plus de `duree_mini_minutes` minutes.\n\n        Args:\n            duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 lister. Par d\u00e9faut \u00e0 15 minutes.\n\n        Returns:\n            List[FeedParserDict]: Une liste d'entr\u00e9es RSS correspondant aux crit\u00e8res.\n        \"\"\"\n        last_large_episodes = []\n        for entry in self.parsed_flow.entries:\n            date_rss = datetime.strptime(entry.published, RSS_DATE_FORMAT)\n            date_db = self.get_most_recent_episode_from_DB()\n            if date_db and date_rss &gt; date_db:\n                if (\n                    RSS_episode.get_duree_in_seconds(entry.itunes_duration)\n                    &gt; duree_mini_minutes * 60\n                ):\n                    last_large_episodes.append(entry)\n        return last_large_episodes\n\n    def store_last_large_episodes(self, duree_mini_minutes: int = 15) -&gt; None:\n        \"\"\"\n        Parcourt la liste des \u00e9pisodes longs r\u00e9cents, instancie RSS_episode et les conserve dans la base de donn\u00e9es.\n        Affiche le nombre de mises \u00e0 jour r\u00e9ussies dans la base de donn\u00e9es.\n\n        Args:\n            duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 stocker. Par d\u00e9faut \u00e0 15 minutes.\n        \"\"\"\n        updates = 0\n        last_large_episodes = self.list_last_large_episodes(duree_mini_minutes)\n        for entry in last_large_episodes:\n            rss_entry = RSS_episode.from_feed_entry(entry)\n            updates += rss_entry.keep()\n        print(f\"Updated episodes: {updates}\")\n</code></pre>"},{"location":"rss/#rss.Podcast.__init__","title":"<code>__init__()</code>","text":"<p>Initialise la classe Podcast en analysant le flux RSS et en obtenant la collection MongoDB.</p> Source code in <code>nbs/rss.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialise la classe Podcast en analysant le flux RSS et en obtenant la collection MongoDB.\n    \"\"\"\n    self.parsed_flow = feedparser.parse(get_RSS_URL())\n    DB_HOST, DB_NAME, _ = get_DB_VARS()\n    self.collection = get_collection(\n        target_db=DB_HOST, client_name=DB_NAME, collection_name=\"episodes\"\n    )\n</code></pre>"},{"location":"rss/#rss.Podcast.get_most_recent_episode_from_DB","title":"<code>get_most_recent_episode_from_DB()</code>","text":"<p>R\u00e9cup\u00e8re la date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s dans la base de donn\u00e9es.</p> <p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Optional[datetime]: La date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s, ou None si aucun \u00e9pisode n'est trouv\u00e9.</p> Source code in <code>nbs/rss.py</code> <pre><code>def get_most_recent_episode_from_DB(self) -&gt; Optional[datetime]:\n    \"\"\"\n    R\u00e9cup\u00e8re la date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s dans la base de donn\u00e9es.\n\n    Returns:\n        Optional[datetime]: La date la plus r\u00e9cente des \u00e9pisodes stock\u00e9s, ou None si aucun \u00e9pisode n'est trouv\u00e9.\n    \"\"\"\n    most_recent_document = self.collection.find().sort({\"date\": -1}).limit(1)\n    most_recent_date = None\n    for doc in most_recent_document:\n        most_recent_date = doc[\"date\"].replace(tzinfo=pytz.timezone(\"Europe/Paris\"))\n    return most_recent_date\n</code></pre>"},{"location":"rss/#rss.Podcast.list_last_large_episodes","title":"<code>list_last_large_episodes(duree_mini_minutes=15)</code>","text":"<p>Liste les \u00e9pisodes RSS qui sont plus r\u00e9cents que le plus r\u00e9cent \u00e9pisode stock\u00e9 dans la base de donn\u00e9es et qui durent plus de <code>duree_mini_minutes</code> minutes.</p> <p>Parameters:</p> Name Type Description Default <code>duree_mini_minutes</code> <code>int</code> <p>La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 lister. Par d\u00e9faut \u00e0 15 minutes.</p> <code>15</code> <p>Returns:</p> Type Description <code>List[FeedParserDict]</code> <p>List[FeedParserDict]: Une liste d'entr\u00e9es RSS correspondant aux crit\u00e8res.</p> Source code in <code>nbs/rss.py</code> <pre><code>def list_last_large_episodes(\n    self, duree_mini_minutes: int = 15\n) -&gt; List[FeedParserDict]:\n    \"\"\"\n    Liste les \u00e9pisodes RSS qui sont plus r\u00e9cents que le plus r\u00e9cent \u00e9pisode stock\u00e9 dans la base de donn\u00e9es\n    et qui durent plus de `duree_mini_minutes` minutes.\n\n    Args:\n        duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 lister. Par d\u00e9faut \u00e0 15 minutes.\n\n    Returns:\n        List[FeedParserDict]: Une liste d'entr\u00e9es RSS correspondant aux crit\u00e8res.\n    \"\"\"\n    last_large_episodes = []\n    for entry in self.parsed_flow.entries:\n        date_rss = datetime.strptime(entry.published, RSS_DATE_FORMAT)\n        date_db = self.get_most_recent_episode_from_DB()\n        if date_db and date_rss &gt; date_db:\n            if (\n                RSS_episode.get_duree_in_seconds(entry.itunes_duration)\n                &gt; duree_mini_minutes * 60\n            ):\n                last_large_episodes.append(entry)\n    return last_large_episodes\n</code></pre>"},{"location":"rss/#rss.Podcast.store_last_large_episodes","title":"<code>store_last_large_episodes(duree_mini_minutes=15)</code>","text":"<p>Parcourt la liste des \u00e9pisodes longs r\u00e9cents, instancie RSS_episode et les conserve dans la base de donn\u00e9es. Affiche le nombre de mises \u00e0 jour r\u00e9ussies dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>duree_mini_minutes</code> <code>int</code> <p>La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 stocker. Par d\u00e9faut \u00e0 15 minutes.</p> <code>15</code> Source code in <code>nbs/rss.py</code> <pre><code>def store_last_large_episodes(self, duree_mini_minutes: int = 15) -&gt; None:\n    \"\"\"\n    Parcourt la liste des \u00e9pisodes longs r\u00e9cents, instancie RSS_episode et les conserve dans la base de donn\u00e9es.\n    Affiche le nombre de mises \u00e0 jour r\u00e9ussies dans la base de donn\u00e9es.\n\n    Args:\n        duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes \u00e0 stocker. Par d\u00e9faut \u00e0 15 minutes.\n    \"\"\"\n    updates = 0\n    last_large_episodes = self.list_last_large_episodes(duree_mini_minutes)\n    for entry in last_large_episodes:\n        rss_entry = RSS_episode.from_feed_entry(entry)\n        updates += rss_entry.keep()\n    print(f\"Updated episodes: {updates}\")\n</code></pre>"},{"location":"rss/#rss.extraire_dureesummary","title":"<code>extraire_dureesummary(summary)</code>","text":"<p>Extrait la dur\u00e9e d'un \u00e9pisode du masque.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str</code> <p>Le r\u00e9sum\u00e9 de l'\u00e9pisode contenant la dur\u00e9e.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Le nombre de secondes correspondant \u00e0 la dur\u00e9e d'un \u00e9pisode.</p> <code>int</code> <p>Retourne -1 si la dur\u00e9e n'est pas trouv\u00e9e.</p> Source code in <code>nbs/rss.py</code> <pre><code>def extraire_dureesummary(summary: str) -&gt; int:\n    \"\"\"\n    Extrait la dur\u00e9e d'un \u00e9pisode du masque.\n\n    Args:\n        summary (str): Le r\u00e9sum\u00e9 de l'\u00e9pisode contenant la dur\u00e9e.\n\n    Returns:\n        int: Le nombre de secondes correspondant \u00e0 la dur\u00e9e d'un \u00e9pisode.\n        Retourne -1 si la dur\u00e9e n'est pas trouv\u00e9e.\n    \"\"\"\n    # Expression r\u00e9guli\u00e8re pour extraire la dur\u00e9e\n    pattern_duree = r\"dur\u00e9e\\s*:\\s*(\\d{2}:\\d{2}:\\d{2})\"\n\n    # Recherche de la dur\u00e9e dans le texte\n    match = re.search(pattern_duree, summary)\n\n    if match:\n        duree_str = match.group(1)\n        heures, minutes, secondes = map(int, duree_str.split(\":\"))\n        return heures * 3600 + minutes * 60 + secondes\n    else:\n        return -1\n</code></pre>"},{"location":"rss/#rss.extraire_urls_rss","title":"<code>extraire_urls_rss(duree_mini_minutes=15)</code>","text":"<p>Extrait les URLs des balises <code>enclosure</code> d'un flux RSS des \u00e9pisodes durant plus de <code>duree_mini_minutes</code> minutes.</p> <p>Parameters:</p> Name Type Description Default <code>duree_mini_minutes</code> <code>int</code> <p>La dur\u00e9e minimale en minutes des \u00e9pisodes du flux.</p> <code>15</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Une liste d'URLs.</p> Source code in <code>nbs/rss.py</code> <pre><code>def extraire_urls_rss(duree_mini_minutes: int = 15) -&gt; List[str]:\n    \"\"\"\n    Extrait les URLs des balises `enclosure` d'un flux RSS des \u00e9pisodes durant plus de `duree_mini_minutes` minutes.\n\n    Args:\n        duree_mini_minutes (int): La dur\u00e9e minimale en minutes des \u00e9pisodes du flux.\n\n    Returns:\n        List[str]: Une liste d'URLs.\n    \"\"\"\n    url_flux = get_RSS_URL()\n\n    flux = feedparser.parse(url_flux)\n    urls = []\n    for entree in flux.entries:\n        for link in entree.links:\n            if link.type == \"audio/mpeg\":\n                if extraire_dureesummary(entree.summary) &gt; duree_mini_minutes * 60:\n                    urls.append(link.href)\n    return urls\n</code></pre>"},{"location":"web/","title":"Module web","text":""},{"location":"web/#web.WebPage","title":"<code>WebPage</code>","text":"Source code in <code>nbs/web.py</code> <pre><code>class WebPage:\n    def __init__(self):\n        \"\"\"\n        Initialize the WebPage object.\n\n        This method reads the HTML content from the file specified by the\n        `WEB_LMELP_FILENAME` environment variable, parses it using BeautifulSoup,\n        and extracts information about the episodes.\n        \"\"\"\n        file_path = get_WEB_filename()\n\n        # Lire le contenu du fichier HTML\n        with open(file_path, \"r\", encoding=\"utf-8\") as file:\n            html_content = file.read()\n\n        # Analyser le contenu HTML avec BeautifulSoup\n        soup = BeautifulSoup(html_content, \"html.parser\")\n\n        # Extraire les informations des \u00e9pisodes\n        self.episodes: List[Dict[str, Any]] = []\n\n        # Rechercher les \u00e9l\u00e9ments contenant les informations des \u00e9pisodes\n        for item in soup.find_all(\"li\", class_=\"Collection-section-items-item\"):\n            title_element = item.find(\"span\", class_=\"CardTitle\")\n            link_element = item.find(\"a\", class_=\"underline-hover\")\n            description_element = item.find(\"div\", class_=\"CardDescription\")\n            date_elements = item.find(\n                \"div\", class_=\"DefaultDetails-secondLine\"\n            ).find_all(\"p\")\n\n            if (\n                title_element\n                and link_element\n                and description_element\n                and len(date_elements) &gt;= 3\n            ):\n                title = title_element.get_text(strip=True)\n                url = link_element[\"href\"]\n                description = description_element.get_text(strip=True)\n                date = date_elements[0].get_text(strip=True)\n                duration = date_elements[2].get_text(strip=True)\n\n                self.episodes.append(\n                    {\n                        \"title\": title,\n                        \"url\": url,\n                        \"description\": description,\n                        \"date\": date,\n                        \"duration\": duration,\n                    }\n                )\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the WebPage object.\n\n        Returns:\n            str: A string containing the details of all episodes.\n        \"\"\"\n        output = \"\"\n        for episode in self.episodes:\n            output += f\"\"\"\nTitle: {episode['title']}\nURL: {episode['url']}\nDescription: {episode['description']}\nDate: {episode['date']}\nDuration: {episode['duration']}\n\n            \"\"\"\n        return output\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the WebPage object for debugging.\n\n        Returns:\n            str: A string containing the details of all episodes.\n        \"\"\"\n        return self.__str__()\n\n    def __getitem__(self, index: int) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get an episode by its index.\n\n        Args:\n            index (int): The index of the episode to retrieve.\n\n        Returns:\n            dict: A dictionary containing the details of the episode.\n        \"\"\"\n        return self.episodes[index]\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Get the number of episodes.\n\n        Returns:\n            int: The number of episodes.\n        \"\"\"\n        return len(self.episodes)\n</code></pre>"},{"location":"web/#web.WebPage.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get an episode by its index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the episode to retrieve.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing the details of the episode.</p> Source code in <code>nbs/web.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get an episode by its index.\n\n    Args:\n        index (int): The index of the episode to retrieve.\n\n    Returns:\n        dict: A dictionary containing the details of the episode.\n    \"\"\"\n    return self.episodes[index]\n</code></pre>"},{"location":"web/#web.WebPage.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the WebPage object.</p> <p>This method reads the HTML content from the file specified by the <code>WEB_LMELP_FILENAME</code> environment variable, parses it using BeautifulSoup, and extracts information about the episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize the WebPage object.\n\n    This method reads the HTML content from the file specified by the\n    `WEB_LMELP_FILENAME` environment variable, parses it using BeautifulSoup,\n    and extracts information about the episodes.\n    \"\"\"\n    file_path = get_WEB_filename()\n\n    # Lire le contenu du fichier HTML\n    with open(file_path, \"r\", encoding=\"utf-8\") as file:\n        html_content = file.read()\n\n    # Analyser le contenu HTML avec BeautifulSoup\n    soup = BeautifulSoup(html_content, \"html.parser\")\n\n    # Extraire les informations des \u00e9pisodes\n    self.episodes: List[Dict[str, Any]] = []\n\n    # Rechercher les \u00e9l\u00e9ments contenant les informations des \u00e9pisodes\n    for item in soup.find_all(\"li\", class_=\"Collection-section-items-item\"):\n        title_element = item.find(\"span\", class_=\"CardTitle\")\n        link_element = item.find(\"a\", class_=\"underline-hover\")\n        description_element = item.find(\"div\", class_=\"CardDescription\")\n        date_elements = item.find(\n            \"div\", class_=\"DefaultDetails-secondLine\"\n        ).find_all(\"p\")\n\n        if (\n            title_element\n            and link_element\n            and description_element\n            and len(date_elements) &gt;= 3\n        ):\n            title = title_element.get_text(strip=True)\n            url = link_element[\"href\"]\n            description = description_element.get_text(strip=True)\n            date = date_elements[0].get_text(strip=True)\n            duration = date_elements[2].get_text(strip=True)\n\n            self.episodes.append(\n                {\n                    \"title\": title,\n                    \"url\": url,\n                    \"description\": description,\n                    \"date\": date,\n                    \"duration\": duration,\n                }\n            )\n</code></pre>"},{"location":"web/#web.WebPage.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of episodes.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of episodes.\n\n    Returns:\n        int: The number of episodes.\n    \"\"\"\n    return len(self.episodes)\n</code></pre>"},{"location":"web/#web.WebPage.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the WebPage object for debugging.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing the details of all episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the WebPage object for debugging.\n\n    Returns:\n        str: A string containing the details of all episodes.\n    \"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"web/#web.WebPage.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the WebPage object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing the details of all episodes.</p> Source code in <code>nbs/web.py</code> <pre><code>    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the WebPage object.\n\n        Returns:\n            str: A string containing the details of all episodes.\n        \"\"\"\n        output = \"\"\n        for episode in self.episodes:\n            output += f\"\"\"\nTitle: {episode['title']}\nURL: {episode['url']}\nDescription: {episode['description']}\nDate: {episode['date']}\nDuration: {episode['duration']}\n\n            \"\"\"\n        return output\n</code></pre>"},{"location":"whisper/","title":"Module whisper","text":""},{"location":"whisper/#whisper.extract_whisper","title":"<code>extract_whisper(audio_filename)</code>","text":"<p>Extrait la transcription d'un fichier audio en utilisant le mod\u00e8le Whisper.</p> <p>Parameters:</p> Name Type Description Default <code>audio_filename</code> <code>str</code> <p>Le chemin du fichier audio \u00e0 transcrire.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>La transcription du fichier audio.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def extract_whisper(audio_filename: str) -&gt; str:\n    \"\"\"\n    Extrait la transcription d'un fichier audio en utilisant le mod\u00e8le Whisper.\n\n    Args:\n        audio_filename (str): Le chemin du fichier audio \u00e0 transcrire.\n\n    Returns:\n        str: La transcription du fichier audio.\n    \"\"\"\n    device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n    torch_dtype = torch.float16 if torch.cuda.is_available() else torch.float32\n\n    model_id = \"openai/whisper-large-v3-turbo\"\n\n    model = AutoModelForSpeechSeq2Seq.from_pretrained(\n        model_id, torch_dtype=torch_dtype, low_cpu_mem_usage=True, use_safetensors=True\n    )\n    model.to(device)\n\n    processor = AutoProcessor.from_pretrained(model_id)\n\n    generate_kwargs = {\n        \"language\": \"french\",\n    }\n\n    pipe = pipeline(\n        \"automatic-speech-recognition\",\n        model=model,\n        tokenizer=processor.tokenizer,\n        feature_extractor=processor.feature_extractor,\n        torch_dtype=torch_dtype,\n        device=device,\n        chunk_length_s=30,\n        batch_size=16,  # batch size for inference - set based on your device\n        generate_kwargs=generate_kwargs,\n    )\n\n    dataset = load_dataset(\n        \"distil-whisper/librispeech_long\", \"clean\", split=\"validation\"\n    )\n    sample = dataset[0][\"audio\"]\n\n    result = pipe(\n        audio_filename,\n        return_timestamps=True,\n    )\n\n    return result[\"text\"]\n</code></pre>"},{"location":"whisper/#whisper.list_audio_files","title":"<code>list_audio_files(audio_path=AUDIO_PATH)</code>","text":"<p>Liste tous les fichiers audio (MP3 et M4A) dans le r\u00e9pertoire sp\u00e9cifi\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>audio_path</code> <code>str</code> <p>Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.</p> <code>AUDIO_PATH</code> <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>Une liste des chemins de fichiers audio (MP3 et M4A) trouv\u00e9s.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def list_audio_files(audio_path=AUDIO_PATH) -&gt; List[str]:\n    \"\"\"\n    Liste tous les fichiers audio (MP3 et M4A) dans le r\u00e9pertoire sp\u00e9cifi\u00e9.\n\n    Args:\n        audio_path (str): Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.\n\n    Returns:\n        list: Une liste des chemins de fichiers audio (MP3 et M4A) trouv\u00e9s.\n    \"\"\"\n    fullpath = get_audio_path(audio_path, year=\"\")\n\n    mp3_files = glob.glob(os.path.join(fullpath, \"**/*.mp3\"), recursive=True)\n    m4a_files = glob.glob(os.path.join(fullpath, \"**/*.m4a\"), recursive=True)\n\n    return mp3_files + m4a_files\n</code></pre>"},{"location":"whisper/#whisper.list_mp3_files","title":"<code>list_mp3_files(audio_path=AUDIO_PATH)</code>","text":"<p>Liste tous les fichiers MP3 dans le r\u00e9pertoire sp\u00e9cifi\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>audio_path</code> <code>str</code> <p>Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.</p> <code>AUDIO_PATH</code> <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>Une liste des chemins de fichiers MP3 trouv\u00e9s.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def list_mp3_files(audio_path=AUDIO_PATH) -&gt; List[str]:\n    \"\"\"\n    Liste tous les fichiers MP3 dans le r\u00e9pertoire sp\u00e9cifi\u00e9.\n\n    Args:\n        audio_path (str): Le chemin du r\u00e9pertoire contenant les fichiers audio. Par d\u00e9faut, utilise la constante AUDIO_PATH.\n\n    Returns:\n        list: Une liste des chemins de fichiers MP3 trouv\u00e9s.\n    \"\"\"\n    fullpath = get_audio_path(audio_path, year=\"\")\n    return glob.glob(os.path.join(fullpath, \"**/*.mp3\"), recursive=True)\n</code></pre>"},{"location":"whisper/#whisper.store_whisper_in_db","title":"<code>store_whisper_in_db(whisper, collection, oid, force=False, verbose=False)</code>","text":"<p>Stocke la transcription Whisper dans la base de donn\u00e9es.</p> <p>Parameters:</p> Name Type Description Default <code>whisper</code> <code>str</code> <p>La transcription du fichier audio.</p> required <code>collection</code> <code>Collection</code> <p>La collection pymongo.</p> required <code>oid</code> <code>str</code> <p>L'identifiant de l'\u00e9pisode.</p> required <code>force</code> <code>bool</code> <p>Si True, \u00e9crase le Whisper existant. Par d\u00e9faut, False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Si True, affiche des messages d\u00e9taill\u00e9s. Par d\u00e9faut, False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si le Whisper a \u00e9t\u00e9 stock\u00e9, False sinon.</p> Source code in <code>nbs/whisper.py</code> <pre><code>def store_whisper_in_db(\n    whisper: str,\n    collection: pymongo.collection.Collection,\n    oid: str,\n    force: bool = False,\n    verbose: bool = False,\n) -&gt; bool:\n    \"\"\"\n    Stocke la transcription Whisper dans la base de donn\u00e9es.\n\n    Args:\n        whisper (str): La transcription du fichier audio.\n        collection: La collection pymongo.\n        oid (str): L'identifiant de l'\u00e9pisode.\n        force (bool, optional): Si True, \u00e9crase le Whisper existant. Par d\u00e9faut, False.\n        verbose (bool, optional): Si True, affiche des messages d\u00e9taill\u00e9s. Par d\u00e9faut, False.\n\n    Returns:\n        bool: True si le Whisper a \u00e9t\u00e9 stock\u00e9, False sinon.\n    \"\"\"\n    # R\u00e9cup\u00e9ration du document\n    document_entry = collection.find_one({\"_id\": ObjectId(oid)})\n\n    if document_entry is None:\n        if verbose:\n            print(f\"Document avec l'oid {oid} non trouv\u00e9\")\n        return False\n\n    if \"whisper\" in document_entry and not force:\n        if verbose:\n            print(\n                f\"Whisper d\u00e9j\u00e0 stock\u00e9 pour l'oid {oid}, et on ne force pas le stockage\"\n            )\n        return False\n    else:\n        document_entry[\"whisper\"] = whisper\n        collection.update_one({\"_id\": ObjectId(oid)}, {\"$set\": document_entry})\n        if verbose:\n            print(f\"Whisper stock\u00e9 pour l'oid {oid}\")\n        return True\n</code></pre>"}]}