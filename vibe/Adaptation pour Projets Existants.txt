 *******************************************************
 *                                                     *
 *        ADAPTATION POUR PROJETS EXISTANTS            *
 *                                                     *
 *          Auteur : Korben                            *
 *          Fait avec ‚ù§Ô∏è pour les Patreons             *
 *                                                     *
 ******************************************************/

Phase 0 : Capture du Contexte (Nouvelle phase pr√©alable)

Utilisez un outil comme Repomix pour capturer votre codebase :
# Installer repomix globalement
npm install -g repomix

# G√©n√©rer output.txt avec le contexte du projet
repomix --output output.txt --ignore "node_modules,dist,build"

Prompt de contextualisation :

Voici le code source de mon projet existant. Analyse-le et g√©n√®re :

1. **project-summary.md** : Vue d'ensemble du projet
   - Architecture actuelle
   - Technologies utilis√©es
   - Structure des fichiers
   - Patterns identifi√©s
   
2. **current-state.md** : √âtat actuel
   - Fonctionnalit√©s existantes
   - Points forts du code
   - Probl√®mes identifi√©s
   - Dette technique

<CODE>
[Coller output.txt ou utiliser la fonction de lecture de fichiers]
</CODE>

==============================

Phase 1 : Sp√©cification des Modifications (Adapt√©e)

J'ai un projet existant [d√©crire bri√®vement] et je veux [VOTRE NOUVELLE FONCTIONNALIT√â/MODIFICATION].

Contexte du projet :
- [Coller project-summary.md]
- [Coller current-state.md si pertinent]

Pose-moi des questions pour comprendre :
- Comment cette modification s'int√®gre dans l'existant
- Quels fichiers seront impact√©s
- Les contraintes de r√©trocompatibilit√©
- Les risques de r√©gression
- La strat√©gie de migration si n√©cessaire

Compile ensuite :
1. **modification-spec.md** : Sp√©cification des changements
2. **impact-analysis.md** : Analyse d'impact sur le code existant
3. **integration-strategy.md** : Strat√©gie d'int√©gration

==============================
Phase 2 : Planification Incr√©mentale (Adapt√©e)

Prends cette sp√©cification de modification et le contexte du projet :

<MODIFICATION_SPEC>
[Coller modification-spec.md]
</MODIFICATION_SPEC>

<PROJECT_CONTEXT>
[Coller les parties pertinentes de output.txt ou project-summary.md]
</PROJECT_CONTEXT>

Cr√©e un plan qui :
1. Minimise les modifications du code existant
2. Respecte les patterns et conventions actuels
3. Permet un rollback facile si n√©cessaire

G√©n√®re :

## modification-plan.csv
Status,Action,File,Type,Priority,Complexity,Current State,Target State,Tests to Update,Rollback Strategy
TODO,CREATE/MODIFY/REFACTOR,[fichier],[New/Update/Refactor],HIGH,[Low/Medium/High],[√©tat actuel],[√©tat cible],[tests √† modifier],[strat√©gie rollback]

## incremental-prompts.md
Des prompts pour chaque modification qui :
- Incluent le contexte n√©cessaire du code existant
- D√©finissent pr√©cis√©ment les changements
- Pr√©servent la compatibilit√©
- Incluent les tests de r√©gression

## migration-checklist.md
- [ ] Backup du code actuel
- [ ] Tests de r√©gression passent
- [ ] Nouvelles fonctionnalit√©s impl√©ment√©es
- [ ] Documentation mise √† jour
- [ ] Code review effectu√©e

==============================

Phase 3 : Ex√©cution avec Pr√©servation (Adapt√©e)
Je vais modifier le projet existant. Pour chaque session :

CONTEXTE ACTUEL :
[Coller les fichiers pertinents actuels ou utiliser repomix]

MODIFICATION √Ä FAIRE :
[R√©f√©rencer la ligne du modification-plan.csv]

Pour chaque modification :
1. Montre d'abord les changements exacts (diff style)
2. Explique pourquoi ces changements sont n√©cessaires
3. G√©n√®re le code modifi√© complet
4. Adapte/cr√©e les tests
5. V√©rifie qu'aucune r√©gression n'est introduite

Apr√®s chaque modification, mets √† jour :
- modification-plan.csv : Status ‚Üí DONE, ajoute Result Notes
- Cr√©e un git-friendly changelog entry
- Note tout effet de bord d√©couvert

==============================
Phase 4 : Documentation et Analyse Post-Modification

Maintiens ces fichiers sp√©cifiques aux modifications :

## modification-log.md
[Date] - [Feature/Fix]
- Fichiers modifi√©s : [liste avec lignes chang√©es]
- Raison : [justification]
- Impact : [effets sur le syst√®me]
- Tests : [nouveaux/modifi√©s]
- Rollback : [comment revenir en arri√®re]

## regression-tests.md
Liste des tests √† ex√©cuter pour v√©rifier qu'aucune r√©gression :
- [ ] [Test 1] - [Fichier] - [R√©sultat attendu]
- [ ] [Test 2] - [Fichier] - [R√©sultat attendu]

## technical-debt.md
Dette technique ajout√©e/r√©solue :
- R√©solue : [description]
- Ajout√©e : [description + plan pour la r√©soudre]
- √Ä surveiller : [points d'attention]

## code-review-notes.md
Points √† v√©rifier en revue de code :
- Respect des conventions existantes
- Performance maintenue/am√©lior√©e
- S√©curit√© pr√©serv√©e
- Documentation √† jour

==============================

üí° Conseils Pratiques en bonus !

1. Utilisez des branches Git : Cr√©ez une nouvelle branche pour chaque session de modification
2. Contexte s√©lectif : Ne donnez que les parties pertinentes du code pour √©conomiser les tokens# Exemple : capturer seulement certains dossiers repomix src/components src/api --output context.txt
3. Tests de r√©gression d'abord : Avant toute modification, v√©rifiez que les tests existants passent
4. Commits atomiques : Committez apr√®s chaque fichier modifi√© avec succ√®s
5. Prompts sp√©cialis√©s pour l'analyse :Analyse ce code et g√©n√®re :
6. - Les tests manquants
7. - Les probl√®mes de s√©curit√©
8. - Les opportunit√©s de refactoring
9. - Les violations des patterns existants
